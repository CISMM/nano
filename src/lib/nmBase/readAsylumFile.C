/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// Read data from a "ibw" file, Igor Binary Wave.
// This is the native format for the Asylum MFP-3D afm.
// Largely copied from an Igor example, "TN003 Igor binary format"
// Aron Helser, 3rdTech, 1/07

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "IgorBin.h"

#include "BCGrid.h"
#include "BCPlane.h"
#include "Asylum.h"

#define CTL_Z	(26)

static void
ReorderBytes(void *p, int bytesPerPoint, long numValues)	// Reverses byte order.
{
   unsigned char ch, *p1, *p2, *pEnd;
	
   pEnd = (unsigned char *)p + numValues*bytesPerPoint;
   while (p < (void *)pEnd) {
      p1 = (unsigned char *)p;
      p2 = (unsigned char *)p + bytesPerPoint-1;
      while (p1 < p2) {
         ch = *p1;
         *p1++ = *p2;
         *p2-- = ch;
      }
      p = (unsigned char *)p + bytesPerPoint;
   }
}

static void
ReorderShort(void* sp)
{
   ReorderBytes(sp, 2, 1);
}

static void
ReorderLong(void* lp)
{
   ReorderBytes(lp, 4, 1);
}

static void
ReorderDouble(void* dp)
{
   ReorderBytes(dp, 8, 1);
}

static void
ReorderBinHeader1(BinHeader1* p)
{
   ReorderShort(&p->version);
   ReorderLong(&p->wfmSize);
   ReorderShort(&p->checksum);
}

static void
ReorderBinHeader2(BinHeader2* p)
{
   ReorderShort(&p->version);
   ReorderLong(&p->wfmSize);
   ReorderLong(&p->noteSize);
   ReorderLong(&p->pictSize);
   ReorderShort(&p->checksum);
}

static void
ReorderBinHeader3(BinHeader3* p)
{
   ReorderShort(&p->version);
   ReorderLong(&p->wfmSize);
   ReorderLong(&p->noteSize);
   ReorderLong(&p->formulaSize);
   ReorderLong(&p->pictSize);
   ReorderShort(&p->checksum);
}

static void
ReorderBinHeader5(BinHeader5* p)
{
   ReorderShort(&p->version);
   ReorderShort(&p->checksum);
   ReorderLong(&p->wfmSize);
   ReorderLong(&p->formulaSize);
   ReorderLong(&p->noteSize);
   ReorderLong(&p->dataEUnitsSize);
   ReorderBytes(&p->dimEUnitsSize, 4, 4);
   ReorderBytes(&p->dimLabelsSize, 4, 4);
   ReorderLong(&p->sIndicesSize);
   ReorderLong(&p->optionsSize1);
   ReorderLong(&p->optionsSize2);
}

static void
ReorderWaveHeader2(WaveHeader2* p)
{
   ReorderShort(&p->type);
   ReorderLong(&p->next);
   // char bname does not need to be reordered.
   ReorderShort(&p->whVersion);
   ReorderShort(&p->srcFldr);
   ReorderLong(&p->fileName);
   // char dataUnits does not need to be reordered.
   // char xUnits does not need to be reordered.
   ReorderLong(&p->npnts);
   ReorderShort(&p->aModified);
   ReorderDouble(&p->hsA);
   ReorderDouble(&p->hsB);
   ReorderShort(&p->wModified);
   ReorderShort(&p->swModified);
   ReorderShort(&p->fsValid);
   ReorderDouble(&p->topFullScale);
   ReorderDouble(&p->botFullScale);
   // char useBits does not need to be reordered.
   // char kindBits does not need to be reordered.
   ReorderLong(&p->formula);
   ReorderLong(&p->depID);
   ReorderLong(&p->creationDate);
   // char wUnused does not need to be reordered.
   ReorderLong(&p->modDate);
   ReorderLong(&p->waveNoteH);
   // The wData field marks the start of the wave data which will be reordered separately.
}

static void
ReorderWaveHeader5(WaveHeader5* p)
{
   ReorderLong(&p->next);
   ReorderLong(&p->creationDate);
   ReorderLong(&p->modDate);
   ReorderLong(&p->npnts);
   ReorderShort(&p->type);
   ReorderShort(&p->dLock);
   // char whpad1 does not need to be reordered.
   ReorderShort(&p->whVersion);
   // char bname does not need to be reordered.
   ReorderLong(&p->whpad2);
   ReorderLong(&p->dFolder);
   ReorderBytes(&p->nDim, 4, 4);
   ReorderBytes(&p->sfA, 8, 4);
   ReorderBytes(&p->sfB, 8, 4);
   // char dataUnits does not need to be reordered.
   // char dimUnits does not need to be reordered.
   ReorderShort(&p->fsValid);
   ReorderShort(&p->whpad3);
   ReorderDouble(&p->topFullScale);
   ReorderDouble(&p->botFullScale);
   ReorderLong(&p->dataEUnits);
   ReorderBytes(&p->dimEUnits, 4, 4);
   ReorderBytes(&p->dimLabels, 4, 4);
   ReorderLong(&p->waveNoteH);
   ReorderBytes(&p->whUnused, 4, 16);
   ReorderShort(&p->aModified);
   ReorderShort(&p->wModified);
   ReorderShort(&p->swModified);
   // char useBits does not need to be reordered.
   // char kindBits does not need to be reordered.
   ReorderLong(&p->formula);
   ReorderLong(&p->depID);
   ReorderShort(&p->whpad4);
   ReorderShort(&p->srcFldr);
   ReorderLong(&p->fileName);
   ReorderLong(&p->sIndices);
   // The wData field marks the start of the wave data which will be reordered separately.
}

static int
CPNumberOfBytesInFile(FILE* fileRef, long* numBytesPtr)
{
	long originalPos;

	originalPos = ftell(fileRef);
	if (fseek(fileRef, 0, SEEK_END) != 0)
           return -1;
	*numBytesPtr = ftell(fileRef);
	if (*numBytesPtr == -1L)
           return -1;
	if (fseek(fileRef, originalPos, SEEK_SET) != 0)
           return -1;
	return 0;
}

static int
Checksum(short *data, int needToReorderBytes, int oldcksum, int numbytes)
{
   unsigned short s;
	
   numbytes >>= 1;				// 2 bytes to a short -- ignore trailing odd byte.
   while(numbytes-- > 0) {
      s = *data++;
      if (needToReorderBytes)
         ReorderShort(&s);
      oldcksum += s;
   }
   return oldcksum&0xffff;
}

/*	NumBytesPerPoint(int type)
	
Given a numeric wave type, returns the number of data bytes per point.
*/
static int
NumBytesPerPoint(int type)
{
   int numBytesPerPoint;
	
   // Consider the number type, not including the complex bit or the unsigned bit.
   switch(type & ~(NT_CMPLX | NT_UNSIGNED)) {
   case NT_I8:
      numBytesPerPoint = 1;		// char
      break;
   case NT_I16:
      numBytesPerPoint = 2;		// short
      break;
   case NT_I32:
      numBytesPerPoint = 4;		// long
      break;
   case NT_FP32:
      numBytesPerPoint = 4;		// float
      break;
   case NT_FP64:
      numBytesPerPoint = 8;		// double
      break;
   default:
      return 0;
      break;
   }

   if (type & NT_CMPLX)
      numBytesPerPoint *= 2;			// Complex wave - twice as many points.
	
   return numBytesPerPoint;
}

/*	LoadNumericWaveData(fr, type, npnts, waveDataSize, needToReorderBytes, pp)

fr is a file reference.
type is the Igor number type.
npnts is the total number of elements in all dimensions.
waveDataSize is the number of data bytes stored in the file.
needToReorderBytes if the byte ordering of the file is not the byte ordering of the current platform.
pp is a pointer to a pointer.
	
If an error occurs, LoadWaveData returns a non-zero error code and sets
*pp to NULL.
	
If no error occurs, LoadWaveData returns 0 and sets *pp to a pointer allocated
via malloc. This pointer must be delete [] by the calling routine.
*/
static int
LoadNumericWaveData(FILE* fr, int type, long npnts, unsigned long waveDataSize, int needToReorderBytes, void**pp)
{
   int numBytesPerPoint;
   unsigned long numBytesToRead, numBytesToAllocate;
   unsigned long numBytesRead;
   void* p;
	
   *pp = NULL;
   // Assume that we can not allocate memory.

   numBytesPerPoint = NumBytesPerPoint(type);
   if (numBytesPerPoint <= 0) {
      printf("Invalid wave type (0x%x).\n", type);
      return -1;
   }
   numBytesToRead = npnts * numBytesPerPoint;

   numBytesToAllocate = numBytesToRead;
   // make aligned array, rounding up.
   p = new double[numBytesToAllocate/8 + 1];
   // Allocate memory to store the wave data.
   if (p == NULL) {
      printf("Unable to allocate %ld bytes to store data.\n", numBytesToAllocate);
      return -1;
   }
   if (numBytesToRead > 0) {
      if (waveDataSize < numBytesToRead) {
         /*	If here, this should be a wave governed by a dependency formula
                for which no wave data was written to the file. Since we can't
                execute the dependency formula we have no way to recreate the wave's
                data. Therefore, we return 0 for all points in the wave.
         */
         memset(p, 0, numBytesToRead);
      }
      else {
         numBytesRead = fread(p, 1, numBytesToRead, fr);
         if (numBytesRead < numBytesToRead || ferror(fr)) {
            delete [] p;
            printf("Error occurred while reading the wave data.\n");
            return -1;
         }
         if (needToReorderBytes) {
            if (type != 0)				// Text wave data does not need to be reordered.
               ReorderBytes(p, numBytesPerPoint, numBytesToRead/numBytesPerPoint);
         }
      }
   }
	
   *pp = p;
   // Return the pointer to the calling routine.
   return 0;
}

/*	ReadWave(fr, typePtr, npntsPtr, waveDataPtrPtr)

Reads the wave file and prints some information about it.
	
Returns to the calling routine the wave's type, number of points, and the
wave data. The calling routine must delete[] *waveDataPtrPtr if it is
not null.
	
Returns 0 or an error code.
	
This routine is written such that it could be used to read waves
from an Igor packed experiment file as well as from a standalone
Igor binary wave file. In order to achieve this, we must not assume
that the wave is at the start of the file. We do assume that, on entry
to this routine, the file position is at the start of the wave.
*/
/** Read Asylum MFP-3D file. 
*/
int BCGrid::readAsylumFile(FILE* fr, const char *filename)
{
   void* waveDataPtr;

   long startFilePos;
   short version;
   short check;
   int binHeaderSize, waveHeaderSize, checkSumSize;
   unsigned long waveDataSize;
   unsigned long numBytesRead;
   int needToReorderBytes;
   char buffer[512];
   unsigned long modDate;
   long wfmSize, bytesInFile;
   long npnts;
   int type;
   char name[64];
   int i, err;
	

   if ((startFilePos = ftell(fr)) == -1L) {
      return -1;
   }
   // Read the file version field.
   numBytesRead = fread(&version, 1, 2, fr);
   if (numBytesRead < 2 || ferror(fr)) {
      printf("Error occurred while reading the file version.\n");
      return -1;
   }
	
   /*	Reorder version field bytes if necessary.
        If the low order byte of the version field of the BinHeader structure
        is zero then the file is from a platform that uses different byte-ordering
        and therefore all data will need to be reordered.
   */
   needToReorderBytes = (version & 0xFF) == 0;
   if (needToReorderBytes)
      ReorderShort(&version);
		
   // Check the version.
   switch(version) {
   case 1:
      printf("This is a version 1 file.\n");
      binHeaderSize = sizeof(BinHeader1);
      waveHeaderSize = sizeof(WaveHeader2);
      checkSumSize = binHeaderSize + waveHeaderSize;
      break;
   case 2:
      printf("This is a version 2 file.\n");
      binHeaderSize = sizeof(BinHeader2);
      waveHeaderSize = sizeof(WaveHeader2);
      checkSumSize = binHeaderSize + waveHeaderSize;
      break;
   case 3:
      printf("This is a version 3 file.\n");
      binHeaderSize = sizeof(BinHeader3);
      waveHeaderSize = sizeof(WaveHeader2);
      checkSumSize = binHeaderSize + waveHeaderSize;
      break;
   case 5:
      printf("This is a version 5 file.\n");
      binHeaderSize = sizeof(BinHeader5);
      waveHeaderSize = sizeof(WaveHeader5);
      checkSumSize = binHeaderSize + waveHeaderSize - 4;
      // Version 5 checksum does not include the wData field.
      break;
   default:
      printf("This does not appear to be a valid Igor binary wave file. The version field = %d.\n", version);
      return -1;
      break;	
   }
	
   // Load the BinHeader and the WaveHeader into memory.
   if (fseek(fr, startFilePos, SEEK_SET) != 0) return -1;
   
   numBytesRead = fread(buffer, 1, binHeaderSize+waveHeaderSize, fr);
   if ((int)numBytesRead < binHeaderSize+waveHeaderSize || ferror(fr)) {
      printf("Error occurred while reading the file headers.\n");
      return -1;
   }
	
   // Check the checksum.	
   check = Checksum((short*)buffer, needToReorderBytes, 0, checkSumSize);
   if (check != 0) {
      printf("Error in checksum - should be 0, is %d.\n", check);
      printf("This does not appear to be a valid Igor binary wave file.\n");
      return -1;
   }
	
   // Do byte reordering if the file is from another platform.	
   if (needToReorderBytes) {
      switch(version) {
      case 1:
         ReorderBinHeader1((BinHeader1*)buffer);
         break;
      case 2:
         ReorderBinHeader2((BinHeader2*)buffer);
         break;
      case 3:
         ReorderBinHeader3((BinHeader3*)buffer);
         break;
      case 5:
         ReorderBinHeader5((BinHeader5*)buffer);
         break;
      }
      switch(version) {
      case 1:				// Version 1 and 2 files use WaveHeader2.
      case 2:
      case 3:
         ReorderWaveHeader2((WaveHeader2*)(buffer+binHeaderSize));
         break;
      case 5:
         ReorderWaveHeader5((WaveHeader5*)(buffer+binHeaderSize));
         break;
      }
   }
	
   // Read some of the BinHeader fields.
   switch(version) {
   case 1:
   {
      BinHeader1* b1;
      b1 = (BinHeader1*)buffer;
      wfmSize = b1->wfmSize;
   }
   break;
			
   case 2:
   {
      BinHeader2* b2;
      b2 = (BinHeader2*)buffer;
      wfmSize = b2->wfmSize;
   }
   break;
			
   case 3:
   {
      BinHeader3* b3;
      b3 = (BinHeader3*)buffer;
      wfmSize = b3->wfmSize;
   }
   break;
			
   case 5:
   {
      BinHeader5* b5;
      b5 = (BinHeader5*)buffer;
      wfmSize = b5->wfmSize;
   }
   break;
   }
	
   // Read some of the WaveHeader fields.
   switch(version) {
   case 1:
   case 2:
   case 3:
   {
      WaveHeader2* w2;
      w2 = (WaveHeader2*)(buffer+binHeaderSize);
      modDate = w2->modDate;
      npnts = w2->npnts;
      type = w2->type;
      strcpy(name, w2->bname);
   }
   break;
			
   case 5:
   {
      WaveHeader5* w5 = (WaveHeader5*)(buffer+binHeaderSize);
      modDate = w5->modDate;
      npnts = w5->npnts;
      type = w5->type;
      strcpy(name, w5->bname);
   }
   break;
   }
   CPNumberOfBytesInFile(fr, &bytesInFile);
   printf("Wave name=%s, npnts=%ld, type=0x%x, wfmSize=%ld.\n", name, npnts, type, wfmSize);
   printf("Bytes left over %ld.\n", bytesInFile - wfmSize);
	
   // Determine the number of bytes of wave data in the file.
   switch(version) {
   case 1:
   case 2:
   case 3:
      waveDataSize = wfmSize - offsetof(WaveHeader2, wData) - 16;
      break;
   case 5:
      waveDataSize = wfmSize - offsetof(WaveHeader5, wData);
      break;
   }
	
   // Position the file pointer to the start of the wData field.
   switch(version) {
   case 1:
   case 2:
   case 3:
      if (fseek(fr, startFilePos+binHeaderSize+waveHeaderSize-16, SEEK_SET) != 0) return -1;
      // 16 = size of wData field in WaveHeader2 structure.
      break;
   case 5:
      if (fseek(fr, startFilePos+binHeaderSize+waveHeaderSize-4, SEEK_SET) != 0) return -1;
      // 4 = size of wData field in WaveHeader2 structure.
      break;
   }
	
   if (type == 0) {
      // For simplicity, we don't load text wave data in this example program.
      printf("This is a text wave.\n");
      return -1;
   }

   // Load the data and allocates memory to store it.
   if ((err = LoadNumericWaveData(fr, type, npnts, waveDataSize, needToReorderBytes, &waveDataPtr)) != 0) {
      return err;
   }
   if (!feof(fr) && version == 5) {
      BinHeader5* b5 = (BinHeader5*)buffer;
      WaveHeader5* w5 = (WaveHeader5*)(buffer+binHeaderSize);
      long num_bytes_left = bytesInFile -
         (binHeaderSize + waveHeaderSize - 4 + waveDataSize);
      char *notes_str = new char[num_bytes_left + 1];
      unsigned long numBytesRead;
      int notes_length;
      // layer dimensions contained in nDim[0], nDim[1]
    // We know the file size, set our own grid size.
      setGridSize(w5->nDim[0], w5->nDim[1]);
      int num_layers = w5->nDim[2]; // 3rd dimension, number of layers.
      char wave_name[32];
      memset(&(wave_name[0]), '\0', 32);
      
      numBytesRead = fread(notes_str, 1, num_bytes_left, fr);
      if ((long)numBytesRead < num_bytes_left || ferror(fr)) {
         delete [] notes_str;
         return -1;
      }
      notes_str[num_bytes_left] = '\0';
      //for (i = 0; i < num_bytes_left; i++) {
      //   if (notes_str[i] == '\r') {
            //notes_str[i] = '\n';
      //   }
      //}

      notes_length = strlen(notes_str);
      // find size params in the notes string:
      char *ptoken = strtok(notes_str, "\r\n");
      float val = 0;
      _min_x = _min_y = 0.0;
      // Scan the file until we get to the end or find our info.
      while ( (NULL != ptoken ) && (CTL_Z != *ptoken) ) {
         if (!strncasecmp(ptoken, "FastScanSize: ", strlen("FastScanSize: ")) ) {
            if (1 == sscanf(ptoken + strlen("FastScanSize: "), "%f", &val)) {
               _max_x = val * 1e9; // meters ->nm
            }
         } else if (!strncasecmp(ptoken, "SlowScanSize:", strlen("SlowScanSize:")) ) {
            if (1 == sscanf(ptoken + strlen("SlowScanSize: "), "%f", &val)) {
               _max_y = val * 1e9; // meters ->nm
            }
            // last token we care about, but it's duplicated later in header.
            break;
         }
         ptoken = strtok(NULL, "\r\n");
      }
      if ((NULL == ptoken) || (CTL_Z == *ptoken)) {
         fprintf(stderr, "BCGrid::Asylum: Can't read scan info.!");
         //return -1;
      }
         
      //printf(notes_str);
      // labels - immediately after the notes string, there are 32 byte blocks
      // that have labels for each image in this wave.
      // Starts 32 bytes after the end of the notes_str.
      for(i = 0; i < num_layers; i++) {
         strncpy(wave_name, &notes_str[notes_length + (i + 1)*(MAX_WAVE_NAME5 + 1)], MAX_WAVE_NAME5 + 1);
         // add whole-file Igor name to end, to make it unique across files.
         string unique_name = string(wave_name) + "_" + name;
         // make plane.
         if (type == NT_FP32) {
            float scale = 1;
            BCPlane *plane = NULL;
             if (!strncasecmp(wave_name, "Height", strlen("Height")) ||
                 !strncasecmp(wave_name, "Amplitude", strlen("Amplitude")) ||
                 !strncasecmp(wave_name, "Deflection", strlen("Deflection")) ||
                 !strncasecmp(wave_name, "ZSensor", strlen("ZSensor")) ) {
               plane = addNewPlane(unique_name, "nm", NOT_TIMED);
               scale = 1e9;
            } else if (!strncasecmp(wave_name, "Phase", strlen("Phase"))||
                       !strncasecmp(wave_name, "UserCalc", strlen("UserCalc")) ) {
               plane = addNewPlane(unique_name, "deg", NOT_TIMED);
               scale = 1.0;
            } else if (!strncasecmp(wave_name, "UserIn", strlen("UserIn")) ||
                       !strncasecmp(wave_name, "Input", strlen("Input")) ||
                       !strncasecmp(wave_name, "Lateral", strlen("Lateral")) ) {
               // UserIn includes 0, 1, 2
               // Input includes Inputi, Inputq
               // some mV and some V??
               plane = addNewPlane(unique_name, "V", NOT_TIMED);
               scale = 1.0;
            } else if (!strncasecmp(wave_name, "Frequency", strlen("Frequency")) ) {
               plane = addNewPlane(unique_name, "Hz", NOT_TIMED);
               scale = 1.0;
            } else if (!strncasecmp(wave_name, "Current", strlen("Current")) ) {
               plane = addNewPlane(unique_name, "A", NOT_TIMED);
               scale = 1.0;
            } else if (!strncasecmp(wave_name, "Count", strlen("Count")) ) {
               // no units displayed - it's a tally, no units.
               plane = addNewPlane(unique_name, "", NOT_TIMED);
               scale = 1.0;
            } else {
               // Assume V, probably a rename of User fields.
               plane = addNewPlane(unique_name, "V", NOT_TIMED);
               scale = 1.0;
            }
            float *float_data = &(((float *)waveDataPtr)[w5->nDim[0] * w5->nDim[1] * i]);
            plane->readAsylumData(float_data, scale);
         }
      }

      delete [] notes_str;
      delete [] waveDataPtr;
      if (type != NT_FP32) {
         return -1;
      }

      //------------------------
      //now that we've got some data, do a write test, too.
      /*
      {
         FILE *fp = fopen("test_out.ibw", "wb");
         
         if (!fp) return 0;
         fwrite(b5, 1, sizeof(BinHeader5), fp);
         fwrite(w5, 1, sizeof(WaveHeader5) - 4 , fp);
         fwrite(*waveDataPtrPtr, sizeof(float), npnts , fp);
         if (notes_length > 0) {
            fwrite(notes_str, 1, notes_length, fp);
         }
         // 32 byte pad of zeros
         memset(&(wave_name[0]), '\0', 32);
         fwrite(wave_name, 1, 32, fp);
         // labels for each layer.
         for(i = 0; i < num_layers; i++) {
            strncpy(wave_name, &notes_str[notes_length + (i + 1)*(MAX_WAVE_NAME5 + 1)], MAX_WAVE_NAME5 + 1);
            fwrite(wave_name, 1, 32, fp);
            
         }
           fclose(fp);
      } */     
   }
   return 0;
}


int BCGrid::writeAsylumFile(FILE* fp, AsylumFile& af)
{
   BinHeader5 b5;
   WaveHeader5 w5;
   int num_layers = 0; // 3rd dimension, number of layers.
   char wave_name[32];
   memset(&(b5), 0, sizeof(BinHeader5));
   memset(&(w5), 0, sizeof(WaveHeader5));

   w5.whVersion = 1;

   w5.nDim[0] = numX();
   w5.nDim[1] = numY();

   // count number of non-calc planes. 
   w5.nDim[2] = num_layers;
   w5.npnts = w5.nDim[0] * w5.nDim[1] * w5.nDim[2];
   
   fwrite(&b5, 1, sizeof(BinHeader5), fp);
   fwrite(&w5, 1, sizeof(WaveHeader5) - 4 , fp);
   
   BCPlane* nextplane;
   for (nextplane = head(); nextplane != NULL; nextplane = nextplane->_next) {
      fwrite(nextplane->flatValueArray(), sizeof(float), w5.nDim[0] * w5.nDim[1] , fp);
    }
   if (af.valid()) {
      fwrite(af.getHeader(), 1, af.getLength(), fp);
   }
   // 32 byte pad of zeros
   memset(&(wave_name[0]), '\0', 32);
   fwrite(wave_name, 1, 32, fp);
   // labels for each layer.
   for (nextplane = head(); nextplane != NULL; nextplane = nextplane->_next) {
      memset(&(wave_name[0]), '\0', 32);
      strncpy(wave_name, nextplane->name()->c_str(), MAX_WAVE_NAME5 + 1);
      fwrite(wave_name, 1, 32, fp);
   }
   return 0;
}
