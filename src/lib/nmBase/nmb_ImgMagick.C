/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*===3rdtech===
  Copyright (c) 2001 by 3rdTech, Inc.
  All Rights Reserved.

  This file may not be distributed without the permission of 
  3rdTech, Inc. 
  ===3rdtech===*/
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#define QuantumLeap
#define _LIB  // Needed for ImageMagick to build and link statically.
#include <magick/api.h>

#include "BCGrid.h"
#include "BCPlane.h"
#include "nmb_Image.h"
#include "nmb_ImgMagick.h"

#ifdef _WIN32
// turns off warning C4290: C++ Exception Specification ignored
#pragma warning( push )
#pragma warning( disable : 4290 4996 )
#endif

/** Initialize ImageMagick library. Pass in argv[0] */
void nmb_ImgMagick::initMagick(char * argv) {
    InitializeMagick(argv);
}

/**
   Read an arbitrary image file using the ImageMagick library, and put the
   image data into a new BCPlane in the BCGrid provided.
@param filename full path to the file
@param name desired name for BCPlane we add to grid
@param grid BCGrid to add BCPlane to. 
@return -1 on error, 0 on success. 
*/
int nmb_ImgMagick::readFileMagick(const char * filename, const char * name, BCGrid * grid) {
    ExceptionInfo
        exception;

      Image
          *image;

      ImageInfo
        *image_info;

      PixelPacket * pixels;
      ViewInfo * vinfo;

      //Initialize the image info structure and read an image.
      GetExceptionInfo(&exception);
      image_info=CloneImageInfo((ImageInfo *) NULL);
      (void) strcpy(image_info->filename,filename);
      image=ReadImage(image_info,&exception);
      if (image == (Image *) NULL) {
          // print out something to let us know we are missing the 
          // delegates.mgk or whatever if that is the problem instead of just
          // saying the file can't be loaded later
          fprintf(stderr, "nmb_ImgMagic: %s: %s\n",
                 exception.reason,exception.description);
          //MagickError(exception.severity,exception.reason,exception.description);
          // Get here if we can't decipher the file, let caller handle it. 
          return -1;
      }

      // Set the grid size to accomodate this new image. 
      grid->setGridSize(image->columns,image->rows);

      // This is the method for reading pixels that compiles and works, 
      // as opposed to GetImagePixels or GetOnePixel, which wouldn't compile. 
      vinfo = OpenCacheView(image);
      pixels = GetCacheView(vinfo, 0,0,image->columns,image->rows);
      if(!pixels) {
          fprintf(stderr, "readFileMagick: unable to get pixel cache.\n"); 
          return(-1);
      }

      BCPlane * plane = grid->addNewPlane(name, "nm", NOT_TIMED);
      if (!plane) {
          fprintf(stderr, "readFileMagick: null plane, memory error.\n"); 
          return(-1);
      }
      double scale = 1;
      if (QuantumDepth == 16) {
        scale = 1.0 / 256;
      }
      for (unsigned int j=0; j<image->rows; j++) {
          for (unsigned int i=0; i < image->columns; i++) {
              // Because we are using QuantumLeap, the images are stored as
              // 16-bit unsigned values; 8-bit images are stored in the upper
              // 8 bits.  So, we need to divide by 256 to get them into the correct
              // range when we are using a quantum depth of 16.
              // This produces data ranging from 0 to 255 for 8-bit images, and
              // from 0 to almost 256 for 16-bit images.  It is arguable whether we
              // would rather have the data map from 0.0 through almost 1.0, but
              // the present behavior matches how the application used to behave.
              // Swap data vertically, to match NM convention.
              plane->setValue(i,image->rows-1-j,pixels[i + image->columns*j].red * scale);
          }
      }
      CloseCacheView(vinfo);
      //printf("%d %d %d\n", pixels[0].red, pixels[0].green, pixels[0].blue);
      DestroyImageInfo(image_info);
      DestroyImage(image);
      return(0);
}

int nmb_ImgMagick::writeFileMagick(const char * filename, 
				   const char * mgk_filetype, 
				   int cols, int rows, 
				   int /*bpp*/, unsigned char * pixels)
{
    ExceptionInfo exception;
    Image *image, *flip_image;
    ImageInfo *image_info;

    //Initialize the image with provided data. 
    GetExceptionInfo(&exception);
    image=ConstituteImage(cols, rows, "RGB", CharPixel, pixels, &exception);
    if (image == (Image *) NULL) {
        fprintf(stderr, "writeFileMagick: Can't create image.\n");
        // Get here if we can't create the image, let caller handle it. 
        return -1;
    }

    // Image is flipped vertically, with data coming from frame buffer. 
    flip_image = FlipImage(image, &exception);
    DestroyImage(image);
    if (!flip_image) {
        fprintf(stderr, 
            "writeFileMagick: Memory error, can't create flipped image.\n");
        return -1;
    }
    image_info=CloneImageInfo((ImageInfo *) NULL);

    // Zip is the only one that works (well) for TIF files, but some programs
    // don't read it. 
    // LZW is not even available. 
    image_info->compression=NoCompression;
    //SetImageInfo(image_info,true,&exception);

    if ((mgk_filetype == NULL) || (mgk_filetype[0] == '\0')){
        strcpy(flip_image->filename,filename);
    } else {
        sprintf(flip_image->filename, "%s:%s", mgk_filetype, filename);
    }

    // Write 8-bit image.
    image_info->depth = 8;
    flip_image->depth = 8;

    if(!WriteImage(image_info, flip_image)) {
	fprintf(stderr, "nmb_ImgMagick::writeFileMagick Can't write image because %s: %s\n", flip_image->exception.reason, flip_image->exception.description);
        return -1;
    }
    DestroyImageInfo(image_info);
    DestroyImage(flip_image);
    // Do not destroy the original image -- it causes a seg fault.  It must
    // do something in-place with the old image?
    return(0);
}

int nmb_ImgMagick::writeFileMagick(const char * filename, 
                    const char * mgk_filetype, BCPlane * plane)
{
    ExceptionInfo exception;
    Image *image;
    ImageInfo *image_info;

    int w = plane->numX(), h =plane->numY();
    unsigned char * pixels = new unsigned char[3*w*h];

    if (!pixels) {
        fprintf(stderr, "writeFileMagick: Out of memory.\n");
        return -1;
    }
    double scale = 254.0 / (plane->maxNonZeroValue() - 
                            plane->minNonZeroValue());
      
    unsigned int val;
    int x, y;
      
    for(y = 0; y <h ; y++ ) {
        for(x = 0; x < w; x++ ) {
            // Flip access of data vertically, 
            // so data looks upright in external viewers. 
            if (plane->value(x,h-1-y) < plane->minNonZeroValue()) {
                val = 0;
            } else {
                val = 1 + 
                    (unsigned)((plane->value(x, h-1-y) - 
                                plane->minNonZeroValue()) * scale);
            }
            pixels[3*y*w + 3*x] = 
                pixels[3*y*w + 3*x + 1] = 
                pixels[3*y*w + 3*x + 2] = val;
        }
    }
     
    //Initialize the image with provided data. 
    GetExceptionInfo(&exception);
    image=ConstituteImage(w, h, "RGB", CharPixel, pixels, &exception);
    if (image == (Image *) NULL) {
        fprintf(stderr, "writeFileMagick: Can't create image.\n");
        // Get here if we can't create the image, let caller handle it. 
        return -1;
    }

    image_info=CloneImageInfo((ImageInfo *) NULL);
    if ((mgk_filetype == NULL) || (mgk_filetype[0] == '\0')){
        strcpy(image->filename,filename);
    } else {
        sprintf(image->filename, "%s:%s", mgk_filetype, filename);
    }
    // Some experimental parameters. 
    image_info->colorspace=RGBColorspace;
    // 75 default for JPEG, PNG; increase for better quality. JPEG manual
    // says 100 is overkill, 95 max.
    image_info->quality=90;
    //Default is NoCompression. BZipCompression, JPEGCompression,
    // LosslessJPEGCompression, LZWCompression, RunlengthEncodedCompression
    // ZipCompression
    // Zip is the only one that works (well) for TIF files, but some programs
    // don't read it. 
    // LZW is not even available. 
    image_info->compression=NoCompression;

    // Write 8-bit image.
    image_info->depth = 8;
    image->depth = 8;

    if(!WriteImage(image_info, image)) {
	fprintf(stderr, "nmb_ImgMagick::writeFileMagick Can't write image because %s: %s\n", image->exception.reason, image->exception.description);
        return -1;
    }
    DestroyImageInfo(image_info);
    DestroyImage(image);
    return(0);
}

int nmb_ImgMagick::writeFileMagick(const char * filename,
                    const char * mgk_filetype, nmb_Image *data)
{
    ExceptionInfo exception;
    Image *image;
    ImageInfo *image_info;

    int w = data->width(), h = data->height();
    unsigned char * pixels = new unsigned char[3*w*h];

    if (!pixels) {
        fprintf(stderr, "writeFileMagick: Out of memory.\n");
        return -1;
    }
    double scale = 254.0 / (data->maxNonZeroValue() -
                            data->minNonZeroValue());

    unsigned int val;
    int x, y;

    for(y = 0; y <h ; y++ ) {
        for(x = 0; x < w; x++ ) {
            // Flip access of data vertically,
            // so data looks upright in external viewers.
            if (data->getValue(x,h-1-y) < data->minNonZeroValue()) {
                val = 0;
            } else {
                val = 1 +
                    (unsigned)((data->getValue(x, h-1-y) -
                                data->minNonZeroValue()) * scale);
            }
            pixels[3*y*w + 3*x] =
                pixels[3*y*w + 3*x + 1] =
                pixels[3*y*w + 3*x + 2] = val;
        }
    }

    //Initialize the image with provided data.
    GetExceptionInfo(&exception);
    image=ConstituteImage(w, h, "RGB", CharPixel, pixels, &exception);
    if (image == (Image *) NULL) {
        fprintf(stderr, "writeFileMagick: Can't create image.\n");
        // Get here if we can't create the image, let caller handle it.
        return -1;
    }

    image_info=CloneImageInfo((ImageInfo *) NULL);
    if ((mgk_filetype == NULL) || (mgk_filetype[0] == '\0')){
        strcpy(image->filename,filename);
    } else {
        sprintf(image->filename, "%s:%s", mgk_filetype, filename);
    }
    // Some experimental parameters.
    image_info->colorspace=RGBColorspace;
    // 75 default for JPEG, PNG; increase for better quality. JPEG manual
    // says 100 is overkill, 95 max.
    image_info->quality=90;
    //Default is NoCompression. BZipCompression, JPEGCompression,
    // LosslessJPEGCompression, LZWCompression, RunlengthEncodedCompression
    // ZipCompression
    // Zip is the only one that works (well) for TIF files, but some programs
    // don't read it. 
    // LZW is not even available. 
    image_info->compression=NoCompression;

    // Write 8-bit image.
    image_info->depth = 8;
    image->depth = 8;

    if(!WriteImage(image_info, image)) {
	fprintf(stderr, "nmb_ImgMagick::writeFileMagick Can't write image because %s: %s\n", image->exception.reason, image->exception.description);
        return -1;
    }
    DestroyImageInfo(image_info);
    DestroyImage(image);
    return(0);
}

#ifdef _WIN32
#pragma warning( pop )
#endif
