/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "nmb_Decoration.h"

#include <string.h>  // memcpy()
#include <stdio.h>

#ifndef min
#define min(a,b) ((a)<(b)?(a):(b))
#endif
#ifndef max
#define max(a,b) ((a)<(b)?(b):(a))
#endif


nmb_Decoration::nmb_Decoration (void) :
  selectedRegionMinX(0), selectedRegionMinY(0),
  selectedRegionMaxX(0), selectedRegionMaxY(0),
  selectedRegion_changed (1),
  //red_changed (1),
  //green_changed (1),
  //blue_changed (1),
  mode (IMAGE),
  elapsedTime (0),
  rateOfTime (1),
  user_mode (0),
  //std_dev_color_scale (1.0f),
  num_markers_shown (1000),
  trueTipLocation_changed (0),
  modSetpoint(0), modSetpointMin(0), modSetpointMax(0),
  imageSetpoint(0), imageSetpointMin(0), imageSetpointMax(0),
  scanlineSetpoint(0), scanlineSetpointMin(0), scanlineSetpointMax(0),
  first_line_avg(0), first_line_avg_prev(0),
  num_pulses (0),
  max_num_pulses (10),
  pulses (new nmb_LocationInfo [max_num_pulses]),
  num_scrapes (0),
  max_num_scrapes (10),
  scrapes (new nmb_LocationInfo [max_num_scrapes]),
  scan_line (NULL),
  scanLineCount (0),
  drawScanLine (1),
  num_slow_line_3d_markers (0),
  scrapeHeightScale(1),
  scrapeHeightOffset(0),
  scrapeMaxDepth(0),
  scrapeCallbacks (NULL),
  pulseCallbacks (NULL),
  ds_sphere_axis(0),
  ds_red_ss(1),
  ds_green_ss(1),
  ds_blue_ss(1)
  //  max_num_slow_line_3d_markers (2)
  //  slowLine3dMarkers ( new PointType [max_num_slow_line_3d_markers] )
{
  if (!pulses)
    max_num_pulses = 0;
  if (!scrapes)
    max_num_scrapes = 0;
}


nmb_Decoration::nmb_Decoration (int markerHeight, int numMarkers) :
  selectedRegionMinX(0), selectedRegionMinY(0),
  selectedRegionMaxX(0), selectedRegionMaxY(0),
  selectedRegion_changed (1),
  //red_changed (1),
  //green_changed (1),
  //blue_changed (1),
  mode (IMAGE),
  elapsedTime (0),
  rateOfTime (1),
  user_mode (0),
  //std_dev_color_scale (1.0f),
  trueTipLocation_changed (0),
  modSetpoint(0), modSetpointMin(0), modSetpointMax(0),
  imageSetpoint(0), imageSetpointMin(0), imageSetpointMax(0),
  scanlineSetpoint(0), scanlineSetpointMin(0), scanlineSetpointMax(0),
  first_line_avg(0), first_line_avg_prev(0),
  num_pulses (0),
  max_num_pulses (10),
  pulses (new nmb_LocationInfo [max_num_pulses]),
  num_scrapes (0),
  max_num_scrapes (10),
  scrapes (new nmb_LocationInfo [max_num_scrapes]),
  scrapeCallbacks (NULL),
  pulseCallbacks (NULL),
  scan_line (NULL),
  scanLineCount (0),
  drawScanLine (1),
  num_slow_line_3d_markers (0),
  scrapeHeightScale(1),
  scrapeHeightOffset(0),
  scrapeMaxDepth(0),
  ds_sphere_axis(0)
  //  max_num_slow_line_3d_markers (2)
  //  slowLine3dMarkers ( new PointType [max_num_slow_line_3d_markers] )
{
  marker_height = markerHeight;
  num_markers_shown = numMarkers;

  if (!pulses)
    max_num_pulses = 0;
  if (!scrapes)
    max_num_scrapes = 0;
}


nmb_Decoration::~nmb_Decoration (void) {
  callbackEntry * t0, * t1;

  if (pulses)
    delete [] pulses;
  if (scrapes)
    delete [] scrapes;
  if (scan_line) {
    delete [] scan_line;
    scan_line = NULL;
  }

  t0 = scrapeCallbacks;
  while (t0) {
    t1 = t0->next;
    delete t0;
    t0 = t1;
  }

  t0 = pulseCallbacks;
  while (t0) {
    t1 = t0->next;
    delete t0;
    t0 = t1;
  }
  // Okay, for some reason, if I delete this object when the program is shutting down
  // it causes a seg fault.  However, if I just leave it alone, everything's just fine
  // and dandy.  In other words, something is killing this besides me and I have
  // no idea what it is.  Maybe the PointType class?
  
  /*
  if (slowLine3dMarkers) {
    // printf("Deleting memory.\n"); // This fixes the seg. fault problem :)
    delete [] slowLine3dMarkers;
    printf("Cleared memory.\n");
    slowLine3dMarkers = NULL;
  }
  */
  
}

void nmb_Decoration::addSlowLine3dMarker(float x, float y, float z) {
  if (num_slow_line_3d_markers < max_num_slow_line_3d_markers) {
    slowLine3dMarkers[num_slow_line_3d_markers][0] = x;
    slowLine3dMarkers[num_slow_line_3d_markers][1] = y;
    slowLine3dMarkers[num_slow_line_3d_markers][2] = z;
    num_slow_line_3d_markers++;
  }
}

void nmb_Decoration::initScanline(long lineCount) {
    if (lineCount <=0) {
        clearScanline();
        return;
    }
    if (scanLineCount != lineCount) {
        clearScanline();
    }
    scanLineCount = lineCount;
    scan_line = new PointType[scanLineCount];
}

void nmb_Decoration::clearScanline() {
    if (scan_line) {
        delete [] scan_line;
        scan_line = NULL;
    }
    scanLineCount = 0;
}

void nmb_Decoration::addScrapeMark (PointType Top, PointType Bottom,
				    double surface_z) {
  nmb_LocationInfo * temp;
  callbackEntry * nce;

  // The top does not take into account the height of the scrapeHeight
  // Top[2] += marker_height + surface_z;

  // Grow virtual memory if needed
  if (num_scrapes >= max_num_scrapes) {
    temp = new nmb_LocationInfo [2 * max_num_scrapes];
    if (!temp) {
      fprintf(stderr, "nmb_Decoration::addScrapeMark:  Out of memory.\n");
      return;
    }
    memcpy(temp, scrapes, num_scrapes * sizeof(nmb_LocationInfo));
    delete [] scrapes;
    scrapes = temp;
    max_num_scrapes *= 2;
  }

  // we will use this later to shift all scrape marks up by the same
  // height needed to make them all visible
  if (surface_z - Bottom[2] > scrapeMaxDepth) {
     scrapeMaxDepth = (float)(surface_z - Bottom[2]);
  }

  // Add a scrapes indicator to the list
  scrapes[num_scrapes].x = Top[0];
  scrapes[num_scrapes].y = Top[1];
  scrapes[num_scrapes].top = Top[2];
  scrapes[num_scrapes].bottom = Bottom[2];
  num_scrapes++; 

//fprintf(stderr, "Scraping at %.2f %.2f %.2f-%.2f\n", Top[0], Top[1], Top[2],
//Bottom[2]);

  // do callbacks
  for (nce = scrapeCallbacks;  nce;  nce = nce->next)
    if (nce->f(Top, Bottom, nce->userdata)) return;
}


void nmb_Decoration::addPulseMark (PointType Top, PointType Bottom) {
  nmb_LocationInfo * temp;
  callbackEntry * nce;

  // Grow virtual memory if needed
  if (num_pulses >= max_num_pulses) {
    temp = new nmb_LocationInfo [2 * max_num_pulses];
    if (!temp) {
      fprintf(stderr, "nmb_Decoration::addScrapeMark:  Out of memory.\n");
      return;
    }
    memcpy(temp, pulses, num_pulses * sizeof(nmb_LocationInfo));
    delete [] pulses;
    pulses = temp;
    max_num_pulses *= 2;
  }

  // Add a pulse indicator to the list
  pulses[num_pulses].x = Top[0];
  pulses[num_pulses].y = Top[1];
  pulses[num_pulses].top = Top[2];
  pulses[num_pulses].bottom = Bottom[2];
  num_pulses++;

  // do callbacks
  for (nce = pulseCallbacks;  nce;  nce = nce->next)
    if (nce->f(Top, Bottom, nce->userdata)) return;
}

void nmb_Decoration::clearScrapes (void) {
  num_scrapes = 0;
  // set offset to 0 so we can compute the max surface height for the
  // the next batch of scrape points (we're assuming they're positive)
  scrapeMaxDepth = 0;
}

void nmb_Decoration::clearPulses (void) {
  num_pulses = 0;
}

void nmb_Decoration::registerNewScrapeCallback
      (nmb_SURFACE_MARKER_CALLBACK f, void * userdata) {
  callbackEntry * nce;

  nce = new callbackEntry;
  if (!nce) {
    fprintf(stderr, "nmb_Decoration::registerNewScrapeCallback:  "
                    "Out of memory!\n");
    return;
  }

  nce->f = f;
  nce->userdata = userdata;
  nce->next = scrapeCallbacks;
  scrapeCallbacks = nce;
  return;
}

void nmb_Decoration::registerNewPulseCallback
      (nmb_SURFACE_MARKER_CALLBACK f, void * userdata) {
  callbackEntry * nce;

  nce = new callbackEntry;
  if (!nce) {
    fprintf(stderr, "nmb_Decoration::registerNewPulseCallback:  "
                    "Out of memory!\n");
    return;
  }

  nce->f = f;
  nce->userdata = userdata;
  nce->next = pulseCallbacks;
  pulseCallbacks = nce;
  return;
}

void nmb_Decoration::traverseVisibleScrapes
          (int (* f) (const nmb_LocationInfo &, void *), void * userdata) {
  int i;
  int numToShow;
  float top_save, bottom_save;

  numToShow = num_markers_shown;
  numToShow = min(numToShow, num_scrapes);
  numToShow = max(numToShow, 0);

//fprintf(stderr, "Traversing %d scrapes\n", numToShow);

  int result;
  for (i = num_scrapes - numToShow; i < num_scrapes; i++){
    top_save = scrapes[i].top;
    bottom_save = scrapes[i].bottom;
    scrapes[i].top = scrapeHeightScale*(scrapes[i].top + 
                                        marker_height + scrapeMaxDepth);
    scrapes[i].bottom = scrapeHeightScale*(scrapes[i].bottom);
    result = f(scrapes[i], userdata);
    scrapes[i].top = top_save;
    scrapes[i].bottom = bottom_save;
    if (result) return;
  }

}


void nmb_Decoration::traverseVisiblePulses
          (int (* f) (const nmb_LocationInfo &, void *), void * userdata) {
  int i;
  int numToShow;

  numToShow = num_markers_shown;
  numToShow = min(numToShow, num_pulses);
  numToShow = max(numToShow, 0);

  for (i = num_pulses - numToShow; i < num_pulses; i++)
    if (f(pulses[i], userdata)) return;

}

void nmb_Decoration::setScrapeHeightScale(float scale)
{
  scrapeHeightScale = scale;
}

float nmb_Decoration::getScrapeHeightScale()
{
  return scrapeHeightScale;
}

void nmb_Decoration::setScrapeHeightOffset(float offset)
{
  scrapeHeightOffset = offset;
}

float nmb_Decoration::getScrapeHeightOffset()
{
  return scrapeHeightOffset; 
}

