/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#ifdef sgi
#include <unistd.h>  // for gethostname
#endif
#ifdef _WIN32
#include <winsock2.h>  // for gethostname
#endif

#include <iostream>

#include "nmb_FlattenedPlane.h"
#include "BCPlane.h"
#include "nmb_Dataset.h"

#ifdef _WIN32
// turns off warning C4290: C++ Exception Specification ignored
#pragma warning( push )
#pragma warning( disable : 4290 4996 )
#endif

nmb_FlattenedPlane::
nmb_FlattenedPlane( const char* inputPlaneName,
		    const char* outputPlaneName,
		    float redX, float greenX, float blueX,
		    float redY, float greenY, float blueY,
		    nmb_Dataset* dataset )
  throw( nmb_CalculatedPlaneCreationException )
  : nmb_CalculatedPlane( outputPlaneName, dataset )
{
  // Are all the pointer arguments valid?
  if( inputPlaneName == NULL || dataset == NULL 
      || dataset->inputGrid == NULL )
    {
      char s[] = "Internal error in nmb_FlattenPlane:  invalid argument.";
      throw nmb_CalculatedPlaneCreationException( s );
    }

  // Is the destination plane name the same as the source plane name?
  if( strcmp( outputPlaneName, inputPlaneName ) == 0 ) 
    {
      char s[] = "Cannot create flattened plane.  "
	"Plane cannot flatten from itself.";
      throw nmb_CalculatedPlaneCreationException( s );
    }
  
  // try to get the requested source plane...
  this->sourcePlane = dataset->inputGrid->getPlaneByName(inputPlaneName);
  if( this->sourcePlane == NULL )
    {
      char s[] = "Cannot create flattened plane.  "
	"Could not get input plane:  ";
      char msg[1024];
      sprintf( msg, "%s%s.", s, inputPlaneName );
      throw nmb_CalculatedPlaneCreationException( msg );
    }

  // Calculate dx, dy and offset.
  calculateDxDyOffset( dataset, redX, greenX, blueX, redY, greenY, blueY );
    
  // create output plane
  char newunits[1000];
  sprintf(newunits, "%s_flat", sourcePlane->units()->c_str());
  createCalculatedPlane( newunits, sourcePlane, dataset );
  
  // fill in the new plane.
  short xmin = 0, ymin = 0, xmax = 0, ymax = 0;
  sourcePlane->findValidDataRange( &xmin, &xmax, &ymin, &ymax );
  for(int x = xmin; x <= xmax; x++) 
  {
    for( int y = ymin; y <= ymax; y++) 
    {
      calculatedPlane->setValue( x, y,
        (float) ( sourcePlane->value(x, y) 
        + offset - dx * x - dy * y ) );
    }
  }

  // register ourselves to receive plane updates
  sourcePlane->add_callback( sourcePlaneChangeCallback, this );

} // end nmb_FlattenedPlane( ... )


// this contructor is non-public, and is used in
// conjunction with _handle_PlaneSynch
nmb_FlattenedPlane::
nmb_FlattenedPlane( const char* inputPlaneName,
                    const char* outputPlaneName,
                    nmb_Dataset* dataset )
  throw( nmb_CalculatedPlaneCreationException )
  : nmb_CalculatedPlane( outputPlaneName, dataset )
{
  // Are all the pointer arguments valid?
  if( inputPlaneName == NULL || dataset == NULL 
      || dataset->inputGrid == NULL )
    {
      char s[] = "Internal error in nmb_FlattenPlane:  invalid argument.";
      throw nmb_CalculatedPlaneCreationException( s );
    }

  // Is the destination plane name the same as the source plane name?
  if( strcmp( outputPlaneName, inputPlaneName ) == 0 ) 
    {
      char s[] = "Cannot create flattened plane.  "
	"Plane cannot flatten from itself.";
      throw nmb_CalculatedPlaneCreationException( s );
    }
  
  // try to get the requested source plane...
  this->sourcePlane = dataset->inputGrid->getPlaneByName(inputPlaneName);
  if( this->sourcePlane == NULL )
    {
      char s[] = "Cannot create flattened plane.  "
	"Could not get input plane:  ";
      char msg[1024];
      sprintf( msg, "%s%s.", s, inputPlaneName );
      throw nmb_CalculatedPlaneCreationException( msg );
    }

  // registering ourselves to receive plane updates is deferred
  // to _handle_PlaneSynch

} // end nmb_FlattenedPlane( ... )


nmb_FlattenedPlane::
~nmb_FlattenedPlane( )
{
  // unregister ourselves to receive plane updates
  if( sourcePlane != NULL )
  {
    sourcePlane->remove_callback( sourcePlaneChangeCallback, this );
  }
} // end ~nmb_FlattenedPlane


bool nmb_FlattenedPlane::
dependsOnPlane( const BCPlane* const plane )
{
  if( plane == NULL ) return false;
  if( plane == sourcePlane /* pointer comparison */ )
    return true;
  else
    return false;
}


bool nmb_FlattenedPlane::
dependsOnPlane( const char* planeName )
{
  if( planeName == NULL ) return false;
  if( this->sourcePlane->name()->compare(planeName) )
    return true;
  else
    return false;
}


void nmb_FlattenedPlane::
calculateDxDyOffset( nmb_Dataset* dataset,
		     float redX, float greenX, float blueX,
		     float redY, float greenY, float blueY )
  throw( nmb_CalculatedPlaneCreationException )
{
  // solve for dx, dy in:
  //  z3 - z1 = dx * ( x3 - x1 ) + dy * ( y3 - y1 )
  //  z2 - z1 = dx * ( x2 - x1 ) + dy * ( y2 - y1 )
  // as so:
  //  dy = (z2 - z1 + (z1 - z3) * k) / (y2 - y1 + (y1 - y3) * k)
  //  dx = (z3 - z1 - dy * (y3 - y1)) / (x3 - x1)
  //  where k = ( x2 - x1 ) / ( x3 - x1 )
  double x1, y1, z1;
  double x2, y2, z2;
  double x3, y3, z3;

  x1 = sourcePlane->xInGrid(redX);    y1 = sourcePlane->yInGrid(redY);
  x2 = sourcePlane->xInGrid(greenX);  y2 = sourcePlane->yInGrid(greenY);
  x3 = sourcePlane->xInGrid(blueX);   y3 = sourcePlane->yInGrid(blueY);
  
  // Are the three points co-linear?
  if( (y2-y1) * (x3-x1) + (y1-y3) * (x2-x1) == 0 ) 
    {
      char s[] = "Could not create flattened plane.  Points are collinear.";
      throw nmb_CalculatedPlaneCreationException( s );
    }
 
  // Are pt1 and pt3 co-linear in x?
  // If so, swap pt 2 and pt 3, or division will go bad.
  if( x3 == x1 ) 
    {
      double temp = x3;  x3 = x2;  x2 = temp;
      temp = y3;  y3 = y2;  y2 = temp;
    }

  // have points been requested that are outside the plane?
  if( sourcePlane->valueAt(&z1, redX, redY) == -1 ||
      sourcePlane->valueAt(&z2, greenX, greenY) == -1 ||
      sourcePlane->valueAt(&z3, blueX, blueY) == -1 )
    {
      char s[] = "Could not create flattened plane.  "
	"Points are out of bounds.";
      throw nmb_CalculatedPlaneCreationException( s );
    }
  
  double k = ( x2 - x1 ) / ( x3 - x1 );
  this->dy = (z2 - z1 + (z1 - z3) * k) / (y2 - y1 + (y1 - y3) * k);
  this->dx = (z3 - z1 - this->dy * (y3 - y1)) / (x3 - x1);
  this->offset = dx * dataset->inputGrid->numX() / 2 
    + dy * dataset->inputGrid->numY() / 2;

} // end nmb_FlattenedPlane::calculateDxDyOffset( ... )


/* static */
void nmb_FlattenedPlane::
sourcePlaneChangeCallback( BCPlane* plane, int x, int y,
			   void* userdata )
{
  nmb_FlattenedPlane* us = (nmb_FlattenedPlane*) userdata;
  if( plane != us->sourcePlane ) 
    {
      cerr << "Internal Error:  nmb_FlattenedPlane::sourcePlaneChangeCallback "
	   << "called with inconsistent nmb_FlattenedPlane and source plane." 
	   << endl;
      return;
    }
  us->_handleSourcePlaneChange( x, y );
} // end sourcePlaneChangeCallback



void nmb_FlattenedPlane::
_handleSourcePlaneChange( int x, int y )
{
  float value = (float) (sourcePlane->value(x, y) +
                         this->offset - this->dx * x 
			 - this->dy * y );
  this->calculatedPlane->setValue(x, y, value);
} // end _handleSourcePlaneChange


void nmb_FlattenedPlane::
sendCalculatedPlane( vrpn_Connection* conn, vrpn_int32 senderID,
		     vrpn_int32 synchCalculatedPlaneMessageType ) const
{
  char planemsg [1024];
  char * bufptr = planemsg;
  vrpn_int32 msglen = 1024;

  vrpn_buffer( &bufptr, &msglen, (vrpn_int32) FLATTENED_PLANE_TYPE );
  vrpn_buffer( &bufptr, &msglen, (vrpn_float64) dx );
  vrpn_buffer( &bufptr, &msglen, (vrpn_float64) dy );
  vrpn_buffer( &bufptr, &msglen, (vrpn_float64) offset );
  vrpn_buffer( &bufptr, &msglen, (vrpn_int32) calculatedPlane->name()->length() );
  vrpn_buffer( &bufptr, &msglen, (vrpn_int32) sourcePlane->name()->length() );
  vrpn_buffer( &bufptr, &msglen, calculatedPlane->name()->c_str(),
	      calculatedPlane->name()->length() );
  vrpn_buffer( &bufptr, &msglen, sourcePlane->name()->c_str(),
	      sourcePlane->name()->length() );
  
  timeval now;
  gettimeofday(&now, NULL);
  conn->pack_message(1024 - msglen, now, synchCalculatedPlaneMessageType, 
		     senderID, planemsg, vrpn_CONNECTION_RELIABLE);

} // end sendCalculatedPlane( ... )



/* static */
nmb_CalculatedPlane* nmb_FlattenedPlane::
_handle_PlaneSynch( vrpn_HANDLERPARAM p, nmb_Dataset* dataset )
  throw( nmb_CalculatedPlaneCreationException )
{
  const char * bufptr = p.buffer;
  vrpn_int32 planeType;

  vrpn_unbuffer( &bufptr, &planeType );
  if( planeType != nmb_CalculatedPlane::FLATTENED_PLANE_TYPE )
    {
      char s[] = "Could not create flattened plane from remote source.  "
	"Wrong type.";
      throw nmb_CalculatedPlaneCreationException( s );
    }

  vrpn_int32 outputPlaneNameLen;
  vrpn_int32 sourcePlaneNameLen;
  vrpn_float64 dx;
  vrpn_float64 dy;
  vrpn_float64 offset;

  vrpn_unbuffer( &bufptr, &dx );
  vrpn_unbuffer( &bufptr, &dy );
  vrpn_unbuffer( &bufptr, &offset );
  vrpn_unbuffer( &bufptr, &outputPlaneNameLen );
  vrpn_unbuffer( &bufptr, &sourcePlaneNameLen );

  char* outputPlaneName = new char[ outputPlaneNameLen + 1 ];
  char* sourcePlaneName = new char[ sourcePlaneNameLen + 1 ];
  vrpn_unbuffer( &bufptr, outputPlaneName, outputPlaneNameLen );
  vrpn_unbuffer( &bufptr, sourcePlaneName, sourcePlaneNameLen );
  outputPlaneName[outputPlaneNameLen] = '\0';
  sourcePlaneName[sourcePlaneNameLen] = '\0';

  // test for idempotency
  nmb_FlattenedPlane* samePlane 
    = dynamic_cast<nmb_FlattenedPlane*>( nmb_CalculatedPlane::getCalculatedPlane( outputPlaneName ) );
  // samePlane will be NULL EITHER if there is currently no plane of the given name,
  // OR if the run-time identified type of the plane with the given name is not 
  // nmb_FlattenedPlane
  if( samePlane != NULL )
  { // see if we got a message to recreate the same plane
    if( dx == samePlane->dx
        && dy == samePlane->dy
        && offset == samePlane->offset
        && samePlane->sourcePlane->name()->compare(sourcePlaneName) == 0 )
    {
      // the requested plane is exactly the same as one that already exists,
      // so don't change anything
      delete outputPlaneName;
      delete sourcePlaneName;
      return samePlane;
    }
  }

  nmb_FlattenedPlane* newFlatPlane 
     = new nmb_FlattenedPlane( sourcePlaneName, outputPlaneName, dataset );
  newFlatPlane->dx = dx;
  newFlatPlane->dy = dy;
  newFlatPlane->offset = offset;
  
  // try to get the requested source plane...
  newFlatPlane->sourcePlane 
    = dataset->inputGrid->getPlaneByName(sourcePlaneName);
  if( newFlatPlane->sourcePlane == NULL )
    {
      char s[] = "Cannot create flattened plane from remote source.  "
	"Could not get input plane:  ";
      char msg[1024];
      sprintf( msg, "%s%s.", s, sourcePlaneName );
      throw nmb_CalculatedPlaneCreationException( msg );
    }

  // create output plane
  char newunits[1000];
  sprintf(newunits, "%s_flat", 
	  newFlatPlane->sourcePlane->units()->c_str());
  newFlatPlane->createCalculatedPlane( newunits, 
				       newFlatPlane->sourcePlane, dataset );

  // fill in the new plane.
  short xmin = 0, ymin = 0, xmax = 0, ymax = 0;
  newFlatPlane->sourcePlane->findValidDataRange( &xmin, &xmax, &ymin, &ymax );
  for(int x = xmin; x <= xmax; x++) 
  {
    for( int y = ymin; y <= ymax; y++) 
    {
      newFlatPlane->calculatedPlane->setValue( x, y,
                                               (float) ( newFlatPlane->sourcePlane->value(x, y) 
                                               + offset - dx * x - dy * y ) );
    }
  }
  
  // register new flattened plane to receive plane updates
  newFlatPlane->sourcePlane->add_callback( sourcePlaneChangeCallback, 
					   newFlatPlane );

  delete outputPlaneName;
  delete sourcePlaneName;
  return newFlatPlane;
} // _handle_PlaneSynch( ... )


#ifdef _WIN32
#pragma warning( pop )
#endif

