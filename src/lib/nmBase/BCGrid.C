/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*===3rdtech===
  Copyright (c) 2000 by 3rdTech, Inc.
  All Rights Reserved.

  This file may not be distributed without the permission of 
  3rdTech, Inc. 
  ===3rdtech===*/

#ifdef	_WIN32
#include <io.h>
#endif

// make the SGI compile without tons of warnings
#ifdef sgi
#pragma set woff 1110,1424,3201
#endif

#include <fcntl.h> // for open()
#include <errno.h> // for perror()
#include <time.h> // for time() and ctime()
#include <limits.h>
#include <math.h> // for exp()
#include <iostream>

// and reset the warnings
#ifdef sgi
#pragma reset woff 1110,1424,3201
#endif

#ifndef _WIN32
#include <unistd.h>
#endif

#include "BCGrid.h"
#include "BCPlane.h"
#include "MicroscopeFlavors.h"
#include "nmb_ImgMagick.h"

#ifdef _WIN32
// Turns off warnings for Visual Studio compiler
#pragma warning( push )
#pragma warning( disable : 4290 4996 )
#endif

//#include "readNanoscopeFile.h"
//#include "readNanoscopeFile.C" // Include BCGrid functions to read DI files

const char * EMPTY_PLANE_NAME = "Empty-HeightPlane";

const double STANDARD_DEVIATIONS = 3.0;

int BCGrid::_times_invoked = 0;

#ifdef	_WIN32
// Windows doesn't have the strncasecmp function.
int	strncasecmp(const char *s1, const char *s2, size_t n)
{
	unsigned i = 0;	// Index passing through the characters

	for (i = 0; i < n; i++) {
		// See if we've reached the end of one or both strings
		if ( s1[i] == 0 ) {
			if ( s2[i] == 0 ) return 0;
			else return -1;
		} else if ( s2[i] == 0 ) {
			return 1;
		}

		// See if this character breaks the tie
		if ( tolower(s1[i]) < tolower(s2[i]) ) return -1;
		if ( tolower(s1[i]) > tolower(s2[i]) ) return 1;
	}
	return 0;	// Got to the end of the characters to test
}
#endif


/**
BCGrid --> constructor
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
BCGrid::BCGrid(short num_x, short num_y, 
	       double min_x, double max_x, 
	       double min_y, double max_y,
		       int read_mode) :
    _next(NULL),
    d_minMaxCB(NULL),

    _num_x(num_x),
    _num_y(num_y),
    _min_x(min_x),
    _max_x(max_x),
    _min_y(min_y),
    _max_y(max_y),
    _derange_x(1.0), 
    _derange_y(1.0), 
    _num_planes(0),

    _head(NULL),

    _detection_sensitivity(1.0),
    _attenuation_in_z(1.0),
    _z_max(-1.0e33),
    _input_sensitivity(1.0),
    _z_sensitivity(1.0),
    _input_1_max(1.0),
    _input_2_max(1.0),
    _modified(1),
    _read_mode(read_mode)

{    

}

BCGrid::BCGrid() :
    _next(NULL),
    d_minMaxCB(NULL),

    _num_x(3),
    _num_y(3),
    _min_x(-1),
    _max_x(1),
    _min_y(-1),
    _max_y(1),
    _derange_x(1.0), 
    _derange_y(1.0), 
    _num_planes(0),

    _head(NULL),

    _detection_sensitivity(1.0),
    _attenuation_in_z(1.0),
    _z_max(-1.0e33),
    _input_sensitivity(1.0),
    _z_sensitivity(1.0),
    _input_1_max(1.0),
    _input_2_max(1.0),
    _modified(1),
    _read_mode(READ_FILE)
{    
}

// Copy constructor
BCGrid::BCGrid (const BCGrid * grid) :
  _next (NULL),
  d_minMaxCB ( NULL),
  _num_x (grid->_num_x),
  _num_y (grid->_num_y),
  _min_x (grid->_min_x),
  _max_x (grid->_max_x),
  _min_y (grid->_min_y),
  _max_y (grid->_max_y),
  _derange_x (grid->_derange_x),
  _derange_y (grid->_derange_y),
  _num_planes (grid->_num_planes),
  _head (NULL),
  _detection_sensitivity (grid->_detection_sensitivity),
  _attenuation_in_z (grid->_attenuation_in_z),
  _z_scale (grid->_z_scale),
  _z_scale_auxc (grid->_z_scale_auxc),
  _z_max (grid->_z_max),
  _input_sensitivity (grid->_input_sensitivity),
  _z_sensitivity (grid->_z_sensitivity),
  _input_1_max (grid->_input_1_max),
  _input_2_max (grid->_input_2_max),
  _modified (1),
  _read_mode(grid->_read_mode)
{

  BCPlane * pp;

  for (pp = grid->_head; pp; pp = pp->_next) {
    addPlaneCopy(pp);
  }
}

/**
~BCGrid --> destructor
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
BCGrid::~BCGrid()
{   
    BCPlane* current;
    BCPlane* next;

    current = _head;

    while (current != NULL)
    {
	next = current->_next;

	delete(current);
	
	current = next;
    } 

    MinMaxCB * cbp;
    while (d_minMaxCB) {
      cbp = d_minMaxCB;
      d_minMaxCB = d_minMaxCB->next;
      delete cbp;
    }
} // ~BCGrid

/**
   Loads a file. If the only plane in the grid is EMPTY_PLANE_NAME,
   fill the grid. If there is data already in the grid, add plane of data 
   only if the grid size matches.
   @param full path and filename to load. 
   @param topoFile topo file information so we can write out in topo format. 
   @return NULL on invalid data, new grid pointer on conflict with existing grid data, point to "this" on success
   @author Aron Helser
   @date modified 6-27-01 Aron Helser
*/
BCGrid *
BCGrid::loadFile(const char* file_name, TopoFile &topoFile)
{
    FILE *infile;

    // Read the file into our grid structure

    // This is a success if no files are specified. 
    if (file_name == NULL) {
	return this;
    }

    // Check to see if our grid has any meaningful data. 
    if ((head() == NULL) ||
        (( strcmp(head()->name()->c_str(), EMPTY_PLANE_NAME) == 0) && 
         ( head()->next() == NULL)) ) {
	// if not, read in the file.
        // "rb" is nessesary on _WIN32 and doesn't hurt elsewhere. 
        infile = fopen(file_name,"rb");
        
        if (infile == NULL) {
            fprintf(stderr,
                    "Error! BCGrid::loadFile: Could not open input "
                    "file \"%s\"!\n", file_name);
            return NULL;
        }
        
	if (readFile(infile,file_name, topoFile) == -1) {
	    fprintf(stderr,
		    "Error! BCGrid::loadFile: Could not read data"
                    " from \"%s\"!\n", file_name);
	    return NULL;
	}
    } else {
        // If we already have valid data, read file into its own grid
        // structure, then compare the size of the new grid with the size of
        // the existing grid.  If they match, copy the plane into this
        // grid, ensuring that the plane has a unique name.
        //
        // Force mode to be READ_FILE, so we actually read the file data. 

        // Create an empty grid.
	BCGrid *grid = new BCGrid(_num_x,_num_y, _min_x,_max_x,
		    _min_y, _max_y, READ_FILE);
        // call this separately so we can detect errors. 
        if(NULL ==grid->loadFile(file_name, topoFile)) {
            // If return is NULL, we had an error - abort. 
            return NULL;
        }
	if (!(grid->empty())) {
            // We allow grids with the same resolution, and with the
            // same size, even if they aren't in the same place. 
            // Helps with saving and immediately reloading Thermo file. 
            if ( (grid->_num_x != _num_x) ||
                 (grid->_num_y != _num_y) ||
                 (grid->_max_x - grid->_min_x != _max_x - _min_x) ||
                 (grid->_max_y - grid->_min_y != _max_y - _min_y) ) {
                // Not an error any more - expected, return this grid.  
//  		fprintf(stderr,"Error! BCGrid::BCGrid: Grid size or region mismatch"
//  			" in file \"%s\", ignoring any remaining files\n",
//  			file_names[i]);
                return grid;
	    } else {
               for (BCPlane *p = grid->head(); p != NULL; p = p->next()) {
                  BCPlane *newplane;
                  string name;
                  findUniquePlaneName(p->_dataset,&name);
                  newplane = addPlaneCopy(p);
                  newplane->rename(name);
               }
            }
        }
    }

    _modified = 1;
    return this;
}

/*
findUniquePlaneName
    Finds a plane name that does not match any existing plane
		name already linked to the Grid.  It does so by appending
		numbers (from 2 on up) to the base_name until it finds a
		name not already in the list.  If the base name is unique
		as it stands, then no number is appended.
        @author Russ Taylor
 @date modified 11-2-95 by Russ Taylor
*/
void
BCGrid::findUniquePlaneName(
	  string base_name, ///< Desired name
	  string *result_name ///< Uniqueified name
)
{
	int	next_number_to_try = 2;
	char	appendix[10];
	*result_name = base_name;

	while (getPlaneByName(*result_name) != NULL) {
		sprintf(appendix,"%d",next_number_to_try);
		next_number_to_try++;
		*result_name = base_name;
		*result_name += appendix;
	}

} // ~findUniquePlaneName

/**
addNewPlane
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
BCPlane*
BCGrid::addNewPlane(string dataset, string units, int timed)
{

    if (timed)
    {
	CTimedPlane* plane = new CTimedPlane(dataset, units, _num_x, _num_y);
	addPlane(plane);
	return plane;
    }
    else
    {
	CPlane* plane = new CPlane(dataset, units, _num_x, _num_y);
        addPlane(plane);
	return plane;
    }

} // addNewPlane


/**
addPlaneCopy
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
BCPlane* 
BCGrid::addPlaneCopy(BCPlane* plane)
{
    if (plane->_timed)
    {
	CTimedPlane* copy = new CTimedPlane((CTimedPlane*) plane);
        addPlane(copy);
	return copy;
    }
    else
    {
	CPlane* copy = new CPlane((CPlane*) plane);
        addPlane(copy);
	return copy;
    }

} // addPlaneCopy



/**
removePlane
Removes the plane of the given name from the Grid.
  @author David Marshburn
  @date 1-7-02
  */
void BCGrid::
removePlane( string name )
{
  BCPlane* plane = getPlaneByName( name );
  if( plane == NULL )
    return;

  // splice the plane out of the list
  if( *(_head->name()) == name )
  {
    _head = _head->_next;
    plane->_next = NULL;
  }
  else
  {
    BCPlane* last = _head;
    BCPlane* current = _head->_next;
    while( current != NULL && *(current->name()) != name )
    {
      last = current;
      current = current->_next;
    }
    if( current != NULL )
    {
      last->_next = current->_next;
      current->_next = NULL;
    }
  }

  // delete the plane
  delete plane;

} // end removePlane



/**
   Changes the grid resolution, including those of all it's planes,
and erases the data in those planes.

   @param x new grid x dimension
   @param y new grid y dimension
   @return 0 if successful, -1 on failure.
 */
int BCGrid::setGridSize(int x, int y)
{
    _num_x = x;
    _num_y = y;

    BCPlane* nextplane;
    for (nextplane = head();
	 nextplane != NULL;
	 nextplane = nextplane->_next) {
	if (nextplane->setGridSize(x,y)) { return -1; }
    }
    return 0;
}

/**
deleteHead
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int 
BCGrid::deleteHead()
{
    if (_head == NULL)
	return -1;

    BCPlane* temp = _head->_next;
    delete(_head);
    _head = temp;

    _num_planes--;

    return 0;

} // deleteHead


/**
empty
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int 
BCGrid::empty()
{
    if (_head == NULL)
	return 1;
    else
	return 0;
} // empty

int BCGrid::empty_list()
{ if ( _next==NULL)
     return 1;
  else
     return 0;
}
/**
getPlaneByName
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
BCPlane* 
BCGrid::getPlaneByName(string name)
{
    BCPlane* current = _head;

    while (current != NULL)
    {
	if (current->_dataset == name)
	    return current;
	
	current = current->_next;
    }
    
    return NULL;

} // getPlaneByName



/**
decimate
   
    usage note: IMPORTANT! This method destroys the list of planes maintained
                by the Grid. Thus any pointers to individual planes in this
		list that the user has obtained by using head() or getPlaneByName
		will no longer be valid!
        @author ?
 @date modified 9-16-95 by Kimberly Passarella Jones
*/
void
BCGrid::decimate(short num_x, short num_y)
{
    double x0 = ((double) _num_x - 1.0) * 0.5 / (double) num_x;
    double y0 = ((double) _num_y - 1.0) * 0.5 / (double) num_y;

    double dx = ((double) _num_x - 1.0) / (double) num_x;
    double dy = ((double) _num_y - 1.0) / (double) num_y;

    short mask_num_x = (int) (STANDARD_DEVIATIONS * dx / 2.0);
    short mask_num_y = (int) (STANDARD_DEVIATIONS * dy / 2.0);
 
    double** mask = makeMask(mask_num_x, mask_num_y);
    
    BCPlane* next = _head;
    BCPlane* current = NULL;
    
    while (next != NULL)
    {
	BCPlane* newPlane;
	
        // As written this allocated arrays every bit as large
        // as the source arrays.  We want to use smaller arrays
        // (in BCRenderGrid, plus for general efficiency),
        // which requires that we add a couple of parameters to
        // the constructor.

	if (next->_timed)
	    newPlane = new CTimedPlane((CTimedPlane*) next, num_x, num_y);
	else
	    newPlane = new CPlane((CPlane*) next, num_x, num_y);

	newPlane->_grid = this;
          // newPlane->numX() will return _num_x, not num_x!

        decimateRegion (0, 0, num_x, num_y,
                        next, newPlane, num_x, num_y,
                        mask_num_x, mask_num_y, mask);
	if (current == NULL)
	    _head = newPlane;
	else
	    current->_next = newPlane;
	newPlane->_next = next->_next;
	current = newPlane;
	delete(next);
	next = current->_next;
    }

    // free the mask
    int mask_x;
    for (mask_x = -mask_num_x; mask_x <= mask_num_x; mask_x++ )
	//free(mask[mask_x] - mask_num_x);
        delete [] (mask[mask_x] - mask_num_x);
    //free(mask - mask_num_x);
    delete [] (mask - mask_num_x);

    // reset various member variables (note that the size of the planes this
    // list maintains has been slightly reduced)
    _max_x -= x0;
    _min_x += x0;
    _max_y -= y0;
    _min_y += y0;
    _num_x = num_x;
    _num_y = num_y;
    _modified = 1;
    
} // decimate




void BCGrid::setMinX (double min_x) {
  _min_x = min_x;
  _modified = 1;
  doMinMaxCallbacks();
}
void BCGrid::setMaxX (double max_x) {
  _max_x = max_x;
  _modified = 1;
  doMinMaxCallbacks();
}
void BCGrid::setMinY (double min_y) {
  _min_y = min_y;
  _modified = 1;
  doMinMaxCallbacks();
}
void BCGrid::setMaxY (double max_y) {
  _max_y = max_y;
  _modified = 1;
  doMinMaxCallbacks();
}

int BCGrid::clear() {
    BCPlane *p;
    int ret = 0;
    for (p = head(); p; p = p->next()) {
        // If any clear fails, return failure. 
        ret |= p->clear();
    }
    return ret;
}

void BCGrid::registerMinMaxCallback (BCGrid_MinMaxCallback cb,
                                     void * userdata) {
  MinMaxCB * st;

  st = new MinMaxCB;
  if (!st) {
    fprintf(stderr, "BCGrid::registerMinMaxCallback():  Out of memory.\n");
    return;
  }

  st->cb = cb;
  st->userdata = userdata;
  st->next = d_minMaxCB;

  d_minMaxCB = st;
}

void BCGrid::doMinMaxCallbacks (void) {
  MinMaxCB * st;

  for (st = d_minMaxCB; st; st = st->next) {
    (*st->cb)(st->userdata, _min_x, _max_x, _min_y, _max_y);
  }
}




/**
writeTextFile
    This method (in conjunction with CPlane::writeTextFile) writes
                files readable by BCGrid::readTextFile.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int	
BCGrid::writeTextFile(FILE* file, BCPlane* plane)
{
    // put the header information in the file
	
    if (fprintf(file,"DSAA\n") == EOF) {
	perror("BCGrid::writeTextFile: Could not write first line!");
	return -1;
    }
    if (fprintf(file,"%d %d\n", _num_x, _num_y) == EOF) {
	perror("BCGrid::writeTextFile: Could not write num_x and num_y!");
	return -1;
    }
    if (fprintf(file,"%f %f\n", _min_x, _max_x) == EOF) {
	perror("BCGrid::writeTextFile: Could not write min/max x!");
	return -1;
    }
    if (fprintf(file,"%f %f\n", _min_y, _max_y) == EOF) {
	perror("BCGrid::writeTextFile: Could not write min/max y!");
	return -1;
    }

    return plane->writeTextFile(file);

} // writeTextFile


/**
writeBinaryFile
    This method (in conjunction with BCPlane::writeBinaryFile) writes
                files readable by BCGrid::readBinaryFile.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int	
BCGrid::writeBinaryFile(FILE* file, BCPlane* plane)
{
    if (fwrite("DSBB", 4, 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write first line!");
	return(-1);
    }
    if (fwrite(&_num_x, sizeof(_num_x), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write num_x!");
	return -1;
    }
    if (fwrite(&_num_y, sizeof(_num_y), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write num_y!");
	return -1;
    }
    if (fwrite(&_min_x, sizeof(_min_x), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write min_x!");
	return -1;
    }
    if (fwrite(&_max_x, sizeof(_max_x), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write max_x!");
	return -1;
    }
    if (fwrite(&_min_y,sizeof(_min_y), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write min_y");
	return -1;
    }
    if (fwrite(&_max_y,sizeof(_max_y), 1, file) != 1) 
    {
	perror("BCGrid::writeBinaryFile: Could not write max_y");
	return -1;
    }

    return plane->writeBinaryFile(file);

} // writeBinaryFile


/**
writeUNCAFile
    This method (in conjunction with BCPlane::writeUNCAFile) writes
                files readable by BCGrid::readUNCAFile.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int  
BCGrid::writeUNCAFile(FILE* file, BCPlane* plane)
{
    // put the header information in the file 

    if (fprintf(file, "UNCA\n") == EOF) 
    {
	perror("BCGrid::writeUNCAFile: Could not write first line");
	return -1;
    }
    if (fprintf(file, "%d %d\n", _num_x, _num_y) == EOF) 
    {
	perror("BCGrid::writeUNCAFile: Could not write num_x and num_y");
	return -1;
    }
    if (fprintf(file,"%f %f\n",_min_x,_max_x) == EOF) 
    {
	perror("BCGrid::writeUNCAFile: Could not write min/max x");
	return -1;
    }
    if (fprintf(file,"%f %f\n",_min_y,_max_y) == EOF) {
	perror("BCGrid::writeUNCAFile: Could not write min/max y");
	return -1;
    }

    return plane->writeUNCAFile(file);

} // writeUNCAFile


int BCGrid::readSPIPFile(FILE* file, const char *name)
{
    // float current,bias,scanspeed;
    int intelmode=0;
    //  char starttime[60];
    // current=bias=scanspeed=0.0;
    int ngot = 1;
    char *token;
    char buffer[80];
    double  scale = 1; 
    
    //rewind(file);  //we read eight bytes for magic number
    // just go ahead and read the rest of the line. 
    fgets(buffer, 70, file);  // first line specifies fileformat 
  
    while( fgets(buffer, 70,file)!= NULL) {
        // If it is comment, ignore this line
        if ('%' == *buffer || '#' == *buffer) continue;
        token = strtok(buffer,"=");
        if(token == NULL ) 
            break;

        if(strcmp(token,"xpixels ")== 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%hd", &_num_x);
        }
        else if(strcmp(token,"ypixels ")==0 ) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%hd", &_num_y);
        }	   
        else if( strcmp(token,"xlength ") == 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%lg", &_max_x);
        } 
        else if( strcmp(token,"ylength ") == 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%lg", &_max_y);
        }
        else if(strcmp(token,"intelmode ")==0 ) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%d", &intelmode);
        }	   
        else if( strcmp(token,"bit2nm ") == 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%lg", &scale);
        }
        else if( strcmp(token,"xoffset ") == 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%lg", &_min_x);
        } 
        else if (strcmp(token,"yoffset ") == 0) {
            token = strtok(NULL,"");
            ngot = sscanf(token, "%lg", &_min_y);
        } 
        if (ngot <=0) {
            fprintf(stderr,"ReadSPIPFile:Error reading numeric parameter.\n");
            return -1;
        }       
    }


    _max_x= _max_x + _min_x;
    _max_y= _max_y + _min_y;
    
    BCPlane* plane = addNewPlane(name, "nm", TIMED);

    return (plane->readSPIPFile(file,scale, intelmode));
    
}


int BCGrid::writeSPIPFile(FILE* file, BCPlane* plane)
{
  //float current=0.0,bias=0.0;
  float scanspeed = 0.0;
#ifdef _WIN32
  int intelmode=1;
#else
  int intelmode=0;
#endif
  //char starttime[]="10 18 96 16:23:22:22";

  if(fprintf(file,"fileformat = bcrstm\n")==EOF) {
    perror("BCGrid::writeSPIPFile: Could not write first line\n");
    return -1;
  }
  if(fprintf(file,"xpixels = %d\nypixels = %d\nxlength = %f\nylength = %f\n",
            _num_x,_num_y, _max_x-_min_x, _max_y-_min_y )==EOF)  {
    perror("BCGrid::writeSPIPFile: Could not write xpixels,ypixels\n");
    return -1;
  }
//    if(fprintf(file,"current = %f\nbias = %f\n",current,bias)==EOF) {
//      perror("BCGrid::writeSPIPFile: Could not write current and bias\n");
//      return -1;
//    }
//    if(fprintf(file,"starttime = %s\nscanspeed = %f\n",starttime,scanspeed)==EOF) {
//      perror("BCGrid::writeSPIPFile: Could not write start time\n");
//      return -1;
//    }	 
  if(fprintf(file,"scanspeed = %f\n",scanspeed)==EOF) {
    perror("BCGrid::writeSPIPFile: Could not write scan speed\n");
    return -1;
  }	 
  if(fprintf(file,"intelmode = %d\n",intelmode)==EOF){ 
    perror("BCGrid::writeSPIPFile: Could not write intelmode\n");
    return -1;
  }
  if(fprintf(file,"bit2nm = %f\n",
             (plane->maxValue()-plane->minValue())/USHRT_MAX)==EOF) {
    perror("BCGrid::writeSPIPFile: Could not write bit2nm\n");
    return -1;
  }
  if(fprintf(file,"xoffset = %f\nyoffset = %f\n", _min_x,_min_y)==EOF) {
    perror("BCGrid::writeSPIPFile: Could not write bit2nm\n");
    return -1;
  }
    return plane->writeSPIPFile(file);
}

// This takes a TopoFile and fills in information needed so that the TopoFile
// can be used to translate the RHK file into the Topometrix format
int BCGrid::readAsciiRHKFile(TopoFile &TGF, FILE* file, const char *name)
{
  // float current,bias,scanspeed;
  //int intelmode=0;
  //  char starttime[60];
  // current=bias=scanspeed=0.0;
  char buffer[128];
  char *bufptr;
  double  z_offset_nm = 0.0, z_scale_pm = 0.0;
  
  rewind(file);  //we read eight bytes for magic number
  
  fgets(buffer, 127, file);  // first line specifies filename and time 
  // e.g: "file D:/PHILIPPE/IP3R/150699/IM01.SM2, 06/18/99 13:13:05" 

  fgets(buffer, 127, file);  // second line indicates channel

  fgets(buffer, 127, file);  // third line indicates resolution

  _min_x = 0;
  _min_y = 0;

  while( fgets(buffer, 70,file)!= NULL) {
        if (strncmp(buffer, "Image data:", 11) == 0)
           break;
	else if (strncmp(buffer, "page size", 9) == 0){
	    sscanf(&(buffer[9]), "%hd", &_num_x);
	    bufptr = strstr(&(buffer[9]), "by");
	    sscanf(&(bufptr[2]), "%hd", &_num_y);
	}
	else if (strncmp(buffer, "page dimensions", 15) == 0){
	    sscanf(&(buffer[15]), "%lf", &_max_x);
	    bufptr = strstr(&(buffer[15]), "by");
	    sscanf(&(bufptr[2]), "%lf", &_max_y);
	}
        else if( strncmp(buffer,"Z offset ", 9) == 0) {
	    sscanf(&(buffer[9]), "%lf", &z_offset_nm);
	    bufptr = strstr(&(buffer[9]), "pixel scale");
	    sscanf(&(bufptr[11]), "%lf", &z_scale_pm);
        }
  }

  printf("read RHK file:\n");
  printf("%d by %d\n", _num_x, _num_y);
  printf("%g nm by %g nm\n", _max_x, _max_y);
  printf("z offset: %g nm, z scale: %g pm\n", z_offset_nm, z_scale_pm);

  // above, _max_x, _max_y were set to the width and height in nm but they need
  // to be absolute so we add in the position of the origin
  _max_x= _max_x + _min_x;
  _max_y= _max_y + _min_y;

  BCPlane* plane = addNewPlane(name, "nm", NOT_TIMED);

  TGF.initForConversionToTopo(z_scale_pm*0.001, z_offset_nm);

  return (plane->readAsciiRHKFile(file, z_offset_nm, z_scale_pm));

}

/**
writePPMFile
    
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int 
BCGrid::writePPMFile(FILE* file, BCPlane* plane)
{
    int file_descriptor;
    if ( (file_descriptor = fileno(file)) == -1) {
      perror("BCGrid::writePPMFile: Could not get descriptor!");
      return -1;
    }
    char header[127];
    time_t t = time(NULL);

    sprintf(header, "P6\n#nM Scale: %g %g %g Create %s%d %d\n255\n",
	    _max_x - _min_x,
	    _max_y - _min_y,
	    plane->maxValue() - plane->minValue(),
	    ctime(&t), _num_x, _num_y);

    if (write(file_descriptor, header, strlen(header)) == -1)
    {
	perror("BCGrid::writePPMFile: Could not write header!");
    	return -1;
    }

    return plane->writePPMFile(file_descriptor);
    
} // writePPMFile

int 
BCGrid::writeImageFile(FILE* file, BCPlane* plane, const char * filename, const char * mgk_filetype)
{
    int file_descriptor = fileno(file);
    if ( file_descriptor == -1 ) {
      perror("BCGrid::writeTIFFile: Could not get descriptor!");
      return -1;
    }
    // We are going to re-open using iostreams below. 
    fclose(file);

    if(nmb_ImgMagick::writeFileMagick(filename, mgk_filetype, plane)) {
        fprintf(stderr, "Failed to write data to '%s'!\n", filename);
        return -1;
    }
    return 0;
    
} // writeTIFFile


/**
writeRawVolFile
    Write a raw volume file from the planes in the grid
                Useful for input to the VolVis program from SUNY Stony Brook
        @author Aron Helser
 @date modified Aug 12 1998 Aron Helser
*/
int 
BCGrid::writeRawVolFile(const char* file_name)
{
    char buffer[127];

    strcpy(buffer, file_name);

#ifdef	__CYGWIN__
    int  file_descriptor = open(file_name, O_WRONLY|O_CREAT|O_EXCL|O_BINARY, 0444);
#else
    int  file_descriptor = open(file_name, O_WRONLY|O_CREAT|O_EXCL, 0444);
#endif

    while (file_descriptor < 0 ) // could not open file called file_name - try to open something else
    {
	static int tries = 0;
	perror("BCGrid::writeRawVolFile: Could not open file!");
	fprintf(stderr, "file: %s\n", buffer);
      
	sprintf(buffer, "tmp_%03d.raw", tries++);

#ifdef	__CYGWIN__
	file_descriptor = open(buffer, O_WRONLY|O_CREAT|O_EXCL|O_BINARY, 0444);   
#else
	file_descriptor = open(buffer, O_WRONLY|O_CREAT|O_EXCL, 0444);   
#endif
	} 
  
    printf("Writing to %s, please wait...\n", buffer);

    // Write data to file. Scale the values from 0 to 255. Write them 
    // in order from the grid. 
    
    int i;
    BCPlane *head = this->head();
    int num_planes = this->numPlanes();
    double min_min, max_max;

    min_min = head->minValue();
    max_max = head ->maxValue();
    head = head->next();
    for ( i = 0; (i < num_planes) && head; i++ ) {
      min_min = min(min_min, head->minValue());
      max_max = max(max_max, head ->maxValue());
      
      head = head->next();
    }


    head = this->head();
    for ( i = 0; (i < num_planes) && head; i++ ) {
      // Write out values scaled to 0 to 255 in order.
      if( head->writeRawByteFile(file_descriptor, min_min, max_max) != 0) return (-1);
      head = head->next();
    }

    close(file_descriptor);
    return 0;

} // writeRawVolFile

/**
writeNCFile
    
        @author Russell Taylor
 @date modified 1-2-98 by Russell Taylor
*/
int 
BCGrid::writeNCFile(FILE* file, BCPlane* plane,
	double sizex, double sizey, double sizez,
	double maxcut, double zoff, int roughskip)
{
    //Put the header
    if (fprintf(file, "(SURFACEMAKING TOOL)\n(TURN OFF DRILLING CYCLE)\nG80\n(CANCEL TOOL LENGTH COMP)\nG49\n(RADIUS OFFSET CANCEL)\nG40\n(ABSOLUTE POSITION MODE)\nG90\n(GO A LITTLE ABOVE THE ORIGIN)\nG00 X 0.0 Y 0.0 Z 0.2\n(GO ABOVE THE ORIGIN AND SET FEED RATE)\nG01 X 0 Y 0 Z 0.1 F 10.0\n(ACTIVATE THE SPINDLE)\nS5000 M03\n") == EOF) {
	perror("BCGrid::writeNCFile: Could not write header!");
    	return -1;
    }
    
    if ( (plane->writeNCFile(file, sizex, sizey, sizez, maxcut, zoff,
                                 roughskip)) != 0) {
	fprintf(stderr,"BCGrid::writeNCFile: Could not write plane\n");
	return -1;
    }
    
    // Put the footer
    if (fprintf(file,"(GO TO THE ORIGIN IN X AND Y)\nG00X0Y0\n(TURN OFF THE SPINDLE)\nM05\n(PROGRAM STOP)\nM00\n") == EOF) {
	perror("BCGrid::writeNCFile: Could not write footer!");
    	return -1;
    }
    
    return 0;
} // writeNCFile


/*-------------

  The following BCGrid methods below are PRIVATE!
  
----------------*/
  
/**
addPlane
    
        @author Kimberly Passarella Jones
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
void
BCGrid::addPlane(BCPlane* plane)
{
    _num_planes++;

    BCPlane* last = NULL;
    BCPlane* current = _head;
    
    while (current!= NULL)
    {
	last = current;
	current = current->_next;
    }
    
    if (last == NULL)
	_head = plane; 
    else 
	last->_next = plane;

    plane->_grid = this;

} // addPlane



/**
makeMask
    This method makes a Gaussian mask.
         input: xExtent and yExtent (one-sided extents, not dimensions!)
        @author ?
 @date modified 9-16-95 by Kimberly Passarella Jones
*/
double**
BCGrid::makeMask (short xExtent, short yExtent)
{
    double  ** mask = new double * [2 * xExtent + 1] + xExtent;    

    double  x_scale = -(xExtent * xExtent)/(2 * STANDARD_DEVIATIONS);
    double  y_scale = -(yExtent * yExtent)/(2 * STANDARD_DEVIATIONS);

    int x, y;
    for (x = -xExtent; x <= xExtent; x++)
    {
	mask[x] = new double [2 * yExtent + 1] + yExtent;
	for (y = -yExtent; y <= yExtent; y++)
	    mask[x][y] = exp(x * x * x_scale + y * y * y_scale);
    }

    return mask;
    
} // makeMask


// static
void BCGrid::decimateRegion (short minx, short miny, short maxx, short maxy,
                             BCPlane * source, BCPlane * dest,
                             int destNumX, int destNumY,
                             int maskNumX, int maskNumY, double ** mask) {

  double x0 = ((double) source->numX() - 1.0) * 0.5 / (double) destNumX;
  double y0 = ((double) source->numY() - 1.0) * 0.5 / (double) destNumY;

  double dx = ((double) source->numX() - 1.0) / (double) destNumX;
  double dy = ((double) source->numY() - 1.0) / (double) destNumY;

  double x, y;
  int ox, oy;
  int ix, iy;
	
  // loop over the image, keeping track of the total weight of
  // the mask pixels that have actually fallen on the image
  // (some may lap over the edges) and normalize to conserve
  // energy 
  for (x = x0 + minx * dx, ox = minx; ox < maxx; x += dx, ox++) {
    ix = (int) (x + 0.5);

    for (y = y0 + miny * dy, oy = miny; oy < maxy; y += dy, oy++) {
      iy = (int) (y + 0.5);

      double value = 0.0;
      double weight = 0.0;
      int iix, iiy;
      int mask_x, mask_y;

      for (iix = ix - maskNumX, mask_x = -maskNumX;
           mask_x <= maskNumX;
           iix++, mask_x++) {
        for (iiy = iy - maskNumY, mask_y = -maskNumY;
             mask_y <= maskNumY; 
             iiy++, mask_y++) {
          if ((((unsigned) iix) < (unsigned) source->numX()) &&
    	       (((unsigned) iiy) < (unsigned)source->numY())) {
            value += source->value(iix, iiy) * mask[mask_x][mask_y];
    	    weight += mask[mask_x][mask_y];
    	  }
        }
      }

      dest->setValue(ox, oy, value / weight);
      if (dest->value(ox, oy) > dest->_max_value) {
        dest->_max_value = dest->value(ox, oy);
      }
      if (dest->value(ox, oy) < dest->_min_value) {
        dest->_min_value = dest->value(ox, oy);
      }
    }
  }
}


/**
readFile
    This method will read any file type. It first determines what 
                is in the file by looking the first four characters, which
		are kind of a "magic number" for the file.  Then it reads the
 		file contents.
        @author ?
 @date modified often
*/
int
BCGrid::readFile(FILE* file, const char *filename, TopoFile &topoFile)
{
    char magic[5];
    char more_magic[5];
// parse the header information in the file
    
    if (fread(magic, 4, 1, file) != 1) 
    {
	perror("BCGrid::readFile: Could not get magic number!");
	return -1;
    }

    //Strip the directory name from the filename
    // Allow for Win or Unix path name, / or \ dividers. 
    const char * name = NULL;
    if (((name = strrchr(filename, '/')) == NULL) &&
        ((name = strrchr(filename, '\\')) == NULL)) {
        // We didn't find any path dividers - use the filename as passed in.
        name = filename;
    } else {
        // We found a divider, advance past it. 
        name +=1;
        // Make sure we still have a string
        if (strlen(name) <1) {
            name = filename;
        }           
    }
    // identify an extension
    const char * extension = NULL;
    if ((extension = strrchr(name, '.')) != NULL) {
       // found a '.', advance past. 
       extension += 1;
        // Make sure we still have a string
        if (strlen(extension) <1) {
           extension = NULL;
        }
    }

    if (strncmp(magic,"DSBB",4) == 0) 
    {
	return readBinaryFile(file, name);
    } 
    else if (strncmp(magic,"DSAA",4) == 0) 
    {
	return readTextFile(file, name);
    } 
    else if (strncmp(magic,"UNCA",4) == 0) 
    {
	return readUNCAFile(file, name);
    } 
    else if (strncmp(magic,"file",4) == 0) 
    {   
	if (fread(more_magic, 4, 1, file) != 1)
	{
	    perror("BCGrid::readFile: Could not get 2nd magic number!");
	    return -1;
	}
	if (strncmp(more_magic, "form", 4) == 0)  // "fileformat..."
	    return readSPIPFile(file, name);
	else // "file ..."
	    return readAsciiRHKFile(topoFile, file, name);
    } 

    else if (strncmp(magic,"UNCB",4) == 0) 
    {
	return readUNCBFile(file, name);
    } 
    else if (strncmp(magic,"Data",4) == 0) 
    {
	return readNanoscopeFileWithoutHeader(file, name);
    } 
    else if (strncmp(magic,"\\*Fi",4) == 0) 
    {
      // This could be either a Hamburg-format file or
      // a Digital Instruments binary file.  The two formats
      // are almost identical.  Try reading it as a Hamburg
      // format and then if that fails read it as a binary
      // Nanoscope file.
      if (readHamburgFile(file, name) == 0) {
	return 0;
      } else {
	// Go back to the start of the file
	fseek(file, 0, SEEK_SET);
        // The last parameter=0 means binary
	return readNanoscopeFile(file, name, 0); 
      }
    } 
    else if (strncmp(magic,"?*Fi",4) == 0) 
    {
        // 1 means ascii
        return readNanoscopeFile(file, name, 1);
    } 
    else if (strncmp(magic,"#R3.0",4) == 0)   // Topo file, v 3.0x
    {
        return readTopometrixFile(topoFile, file, name);
    } 
    else if (strncmp(magic,"#R4.0",4) == 0)   // Topo file, v 4.0x
    {
        return readTopometrixFile(topoFile, file, name);
    } 
    else if (strncmp(magic,"#R5.0",4) == 0)   // Topo file, v 5.0x
    {
        return readTopometrixFile(topoFile, file, name);
    } 
    else if (strncmp(magic,"WSxM",4) == 0) 
    {
        // 0 means new format, text header
       fclose(file);
        return readNanotecFile(filename, name, 0);
    } 
    else if (strncmp(magic,"STM_",4) == 0) 
    {
        // 1 means old format, binary header
       fclose(file);
        return readNanotecFile(filename, name, 1);
    } 
    else if (strncmp(extension,"ibw",3) == 0) { // Igor Asylum binary wave file. 
       // TODO binary 01, 02, 03 05 in first two bytes, but possibly byte-swapped.
       fseek(file, 0, SEEK_SET);
       return readAsylumFile(file, name);
    }
//      else if (strncmp(magic,"P6",2) == 0) 
//      {
//  	return readPPMorPGMFile(file, name);
//      } 
//      else if ((strncmp(magic,"P2",2) == 0) || 
//  	     (strncmp(magic,"P3",2) == 0) ||
//  	     (strncmp(magic,"P5",2) == 0))
//      {
//          rewind(file);
//  	return readPPMorPGMFileNew(file, name);
//      } 
    else 
    {
        fclose(file);
        if(nmb_ImgMagick::readFileMagick(filename, name, this)) {
            magic[4] = '\0';
            fprintf(stderr,"Error! BCGrid::readFile: Unable to load file \n"
                    "    Bad magic number (%s)!\n",
                    magic);
            return -1;
        } 
        return 0;
    }

} // readFile


/**
readTextFile
    This method (in conjunction with BCPlane::readTextFile) read 
                files with the format given below:

		DSAA 		<-- 4 character ascii
		_num_x _num_y	<-- integers
	        _min_x, _max_x	<-- doubles
		_min_y, _max_y	<-- doubles

                min_value max_value      <-- doubles
                value sec usec           <-- double, long, long

		It also creates a plane (an instance of the BCPlane class) and
		adds it to the lists of planes which begins with _head. 
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int
BCGrid::readTextFile(FILE* file, const char *name)
{
    // parse the header information in the file
	
    if (fscanf(file,"%hd %hd", &_num_x, &_num_y) != 2) 
    {
	perror("BCGrid::readTextFile: Could not read num_x and num_y!");
	return -1;
    }
    // We know the file size, set our own grid size.
    setGridSize(_num_x, _num_y);

    if (fscanf(file,"%lf %lf", &_min_x, &_max_x) != 2) 
    {
	perror("BCGrid::readTextFile: Could not read min/max x!");
	return -1;
    }
    if (fscanf(file,"%lf %lf", &_min_y, &_max_y) != 2) 
    {
	perror("BCGrid::readTextFile: Could not read min/max y!");
	return -1;
    }

    BCPlane* plane = addNewPlane(name, "nm", TIMED);

    if (plane->readTextFile(file) == -1)
	return -1;

    float scrap;

    if (fscanf(file,"%f",&scrap) == 1) 
	perror("BCGrid::readTextFile: WARNING: Not at file end upon completion!");

    return 0;

} // readTextFile


/**
readBinaryFile
    This method (in conjunction with BCPlane::readBinaryFile) reads
                files withthe format given below:

		DSBB 		<-- 4 character ascii
		_num_x _num_y	<-- integers
	        _min_x, _max_x	<-- doubles
		_min_y, _max_y	<-- doubles

                min_value max_value      <-- doubles
                value sec usec color     <-- double, long, long, double

		It also creates a plane (an instance of the BCPlane class) and
		adds it to the lists of planes which begins with _head.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int	
BCGrid::readBinaryFile(FILE* file, const char *name)
{
    // parse the header information in the file

    if (fread(&_num_x, sizeof(_num_x), 1, file) != 1) 
    {
	perror("BCGrid::readBinaryFile: Could not read num_x!");
	return -1;
    }
    // We know the file size, set our own grid size.
    setGridSize(_num_x, _num_y);

    if (fread(&_num_y, sizeof(_num_y), 1, file) != 1) 
    {
	perror("BCGrid::readBinaryFile: Could not read num_y!");
	return -1;
    }
    if (fread(&_min_x, sizeof(_min_x), 1, file) != 1) 
    {
	perror("BCGrid::readBinaryFile: Could not read min_x!");
	return -1;
    }
    if (fread(&_max_x, sizeof(_max_x), 1, file) != 1) 
    {
	perror("BCGrid::readBinaryFile: Could not read max_x!");
	return -1;
    }
    if (fread(&_min_y, sizeof(_min_y),1,file) != 1)
    {
	perror("BCGrid::readBinaryFile: Could not read min_y!");
	return -1;
    }
    if (fread(&_max_y, sizeof(_max_y),1,file) != 1) 
    {
	perror("BCGrid::readBinaryFile: Could not read max_y!");
	return -1;
    }

    BCPlane* plane = addNewPlane(name, "nm", TIMED);

    if (plane->readBinaryFile(file) == -1)
	return -1;

    float scrap;

    if (fread(&scrap, 1, 1, file) == 1)
	perror("BCGrid::readBinaryFile: WARNING: Not at file end upon completion!");

    return 0;

} // readBinaryFile


/**
readUNCAFile
    This method (in conjunction with BCPlane::readUNCAFile) read 
                files with the format given below:

		UNCA 		<-- 4 character ascii
		_num_x _num_y	<-- integers
	        _min_x, _max_x	<-- doubles
		_min_y, _max_y	<-- doubles

                min_value max_value      <-- doubles
                value sec usec		 <-- double, long, long

		It also creates a plane (an instance of the BCPlane class) and
		adds it to the lists of planes which begins with _head.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int 
BCGrid::readUNCAFile(FILE* file, const char *name)
{
    // parse the header information in the file 

    if (fscanf(file, "%hd %hd", &_num_x, &_num_y) != 2) 
    {
	perror("BCGrid::readUNCAFile: Could not read num_x and num_y");
	return -1;
    }
    // We know the file size, set our own grid size.
    setGridSize(_num_x, _num_y);

    if (fscanf(file, "%lf %lf", &_min_x, &_max_x) != 2) 
    {
	perror("BCGrid::readUNCAFile: Could not read min/max x");
	return -1;
    }
    if (fscanf(file, "%lf %lf", &_min_y, &_max_y) != 2) 
    {
	perror("BCGrid::readUNCAFile: Could not read min/max y");
	return -1;
    }
    
    BCPlane* plane = addNewPlane(name, "nm", TIMED);

    if (plane->readUNCAFile(file) == -1)
	return -1;

    float scrap;

    if (fscanf(file,"%f", &scrap) == 1) 
	perror("BCGrid::readUNCAFile: WARNING: Not at file end upon completion!");

    return 0;

} // readUNCAFile


/**
readUNCBFile
    This method (in conjunction with BCPlane::readUNCBFile) read 
                files with the format given below:

		UNCB		<-- 4 character ascii
		_num_x _num_y	<-- integers
	        _min_x, _max_x	<-- doubles
		_min_y, _max_y	<-- doubles

                min_value max_value      <-- doubles
                value sec usec color     <-- double, long, long, double

		It also creates a plane (an instance of the BCPlane class) and 
		adds it to the lists of planes which begins with _head.
        @author ?
 @date modified 9-10-95 by Kimberly Passarella Jones
*/
int     
BCGrid::readUNCBFile(FILE* file, const char *name)
{
    // parse the header information in the file

    if (fread(&_num_x,sizeof(_num_x), 1, file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read num_x!");
	return -1;
    }
    if (fread(&_num_y,sizeof(_num_y), 1, file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read num_y!");
	return -1;
    }
    // We know the file size, set our own grid size.
    setGridSize(_num_x, _num_y);

    if (fread(&_min_x, sizeof(_min_x), 1, file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read min_x!");
	return -1;
    }
    if (fread(&_max_x, sizeof(_max_x), 1, file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read max_x!");
	return -1;
    }
    if (fread(&_min_y, sizeof(_min_y), 1, file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read min_y!");
	return -1;
    }
    if (fread(&_max_y, sizeof(_max_y),1,file) != 1) 
    {
	perror("BCGrid::readUNCBFile: Could not read max_y");
	return -1;
    }

    BCPlane* plane = addNewPlane(name, "nm", TIMED);

    if (plane->readUNCBFile(file) == -1)
	return -1;

    float scrap;

    if (fread(&scrap, 1, 1, file) == 1)
	perror("BCGrid::readUNCBFile: WARNING: Not at file end upon completion!");

    return 0;

} // readUNCBfile



ostream& operator << (ostream& os, BCGrid* grid)
{
    os << "***************************************" << endl;

    os << "Contents of this instance of BCGrid:" << endl << endl;

    BCPlane* current = grid->_head;

    cout << grid->_num_planes << " grids: " << endl;

    while (current != NULL)
    {
        os << current->_dataset << endl;

	current  = current->_next;
    }

    os << "***************************************" << endl;
    
    return os;
}

#ifdef _WIN32
#pragma warning( pop )
#endif
