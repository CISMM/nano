/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

// Copied directly from the Cygwin 1.0 CD source, mingw package
// directory /src/winsup/mingw
// Mingw package is in the public domain. 
// Minor edits so it will compile with VC++ directly (change stat to _stat)
/*
 * dirent.c
 *
 * Derived from DIRLIB.C by Matt J. Weinstein 
 * This note appears in the DIRLIB.H
 * DIRLIB.H by M. J. Weinstein   Released to public domain 1-Jan-89
 *
 * Updated by Jeremy Bettis <jeremy@hksys.com>
 * Significantly revised and rewinddir, seekdir and telldir added by Colin
 * Peters <colin@fu.is.saga-u.ac.jp>
 *
 * $Revision$
 * $Author$
 * $Date$
 *
 */

#include <stdlib.h>
/* #include <ctype.h> */
#include <errno.h>
#include <string.h>
#include <io.h>
#include <direct.h>
#include <sys/stat.h>

#include <vc_dirent.h>

#ifdef _WIN32
// turns off warning C4290: C++ Exception Specification ignored
#pragma warning( push )
#pragma warning( disable : 4290 4996 )
#endif

#define SUFFIX	"*"
#define	SLASH	"\\"
#define streq(a,b)	(strcmp(a,b)==0)

/*
 * opendir
 *
 * Returns a pointer to a DIR structure appropriately filled in to begin
 * searching a directory.
 */
DIR*
opendir(const char* szPath)
{
	DIR* nd;
	struct _stat statDir;

	errno = 0;

	if (!szPath)
	{
		errno = EFAULT;
		return (DIR*) 0;
	}

	if (szPath[0] == '\0')
	{
		errno = ENOTDIR;
		return (DIR*) 0;
	}

	/* Attempt to determine if the given path really is a directory. */
	if (_stat (szPath, &statDir))
	{
		/* Error, stat should have set an error value. */
		return (DIR*) 0;
	}

	if (!(_S_IFDIR&&(statDir.st_mode)))
	{
		/* Error, stat reports not a directory. */
		errno = ENOTDIR;
		return (DIR*) 0;
	}

	/* Allocate enough space to store DIR structure and the complete
	 * directory path given. */
	nd = (DIR*) malloc (sizeof(DIR) + strlen(szPath) + strlen(SLASH) +
		strlen(SUFFIX));

	if (!nd)
	{
		/* Error, out of memory. */
		errno = ENOMEM;
		return (DIR*) 0;
	}

	/* Create the search expression. */
	strcpy(nd->dd_name, szPath);

	/* Add on a slash if the path does not end with one. */
	if (nd->dd_name[0] != '\0' &&
	    nd->dd_name[strlen(nd->dd_name)-1] != '/' &&
	    nd->dd_name[strlen(nd->dd_name)-1] != '\\')
	{
		strcat(nd->dd_name, SLASH);
	}

	/* Add on the search pattern */
	strcat(nd->dd_name, SUFFIX);

	/* Initialize handle to -1 so that a premature closedir doesn't try
	 * to call _findclose on it. */
	nd->dd_handle = -1;

	/* Initialize the status. */
	nd->dd_stat = 0;

	/* Initialize the dirent structure. ino and reclen are invalid under
	 * Win32, and name simply points at the appropriate part of the
	 * findfirst_t structure. */
	nd->dd_dir.d_ino = 0;
	nd->dd_dir.d_reclen = 0;
	nd->dd_dir.d_namlen = 0;
	nd->dd_dir.d_name = nd->dd_dta.name;

	return nd;
}


/*
 * readdir
 *
 * Return a pointer to a dirent structure filled with the information on the
 * next entry in the directory.
 */
struct dirent *
readdir( DIR *dirp )
{
	errno = 0;

	/* Check for valid DIR struct. */
	if (!dirp)
	{
		errno = EFAULT;
		return (struct dirent*) 0;
	}

	if (dirp->dd_dir.d_name != dirp->dd_dta.name)
	{
		/* The structure does not seem to be set up correctly. */
		errno = EINVAL;
		return (struct dirent*) 0;
	}

	if (dirp->dd_stat < 0)
	{
		/* We have already returned all files in the directory
		 * (or the structure has an invalid dd_stat). */
		return (struct dirent *) 0;
	}
	else if (dirp->dd_stat == 0)
	{
		/* We haven't started the search yet. */
		/* Start the search */
		dirp->dd_handle = _findfirst(dirp->dd_name, &(dirp->dd_dta));

		if (dirp->dd_handle == -1)
		{
			/* Whoops! Seems there are no files in that
			 * directory. */
			dirp->dd_stat = -1;
		}
		else
		{
			dirp->dd_stat = 1;
		}
	}
	else
	{
		/* Get the next search entry. */
		if (_findnext(dirp->dd_handle, &(dirp->dd_dta)))
		{
			/* We are off the end or otherwise error. */
			_findclose (dirp->dd_handle);
			dirp->dd_handle = -1;
			dirp->dd_stat = -1;
		}
		else
		{
			/* Update the status to indicate the correct
			 * number. */
			dirp->dd_stat++;
		}
	}

	if (dirp->dd_stat > 0)
	{
		/* Successfully got an entry. Everything about the file is
		 * already appropriately filled in except the length of the
		 * file name. */
		dirp->dd_dir.d_namlen = strlen(dirp->dd_dir.d_name);
		return &dirp->dd_dir;
	}

	return (struct dirent*) 0;
}


/*
 * closedir
 *
 * Frees up resources allocated by opendir.
 */
int
closedir (DIR* dirp)
{
	int	rc;

	errno = 0;
	rc = 0;

	if (!dirp)
	{
		errno = EFAULT;
		return -1;
	}

	if (dirp->dd_handle != -1)
	{
		rc = _findclose(dirp->dd_handle);
	}

	/* Delete the dir structure. */
	free (dirp);

	return rc;
}

/*
 * rewinddir
 *
 * Return to the beginning of the directory "stream". We simply call findclose
 * and then reset things like an opendir.
 */
void
rewinddir (DIR* dirp)
{
	errno = 0;

	if (!dirp)
	{
		errno = EFAULT;
		return;
	}

	if (dirp->dd_handle != -1)
	{
		_findclose(dirp->dd_handle);
	}

	dirp->dd_handle = -1;
	dirp->dd_stat = 0;
}

/*
 * telldir
 *
 * Returns the "position" in the "directory stream" which can be used with
 * seekdir to go back to an old entry. We simply return the value in stat.
 */
long
telldir (DIR* dirp)
{
	errno = 0;

	if (!dirp)
	{
		errno = EFAULT;
		return -1;
	}
	return dirp->dd_stat;
}

/*
 * seekdir
 *
 * Seek to an entry previously returned by telldir. We rewind the directory
 * and call readdir repeatedly until either dd_stat is the position number
 * or -1 (off the end). This is not perfect, in that the directory may
 * have changed while we weren't looking. But that is probably the case with
 * any such system.
 */
void
seekdir (DIR* dirp, long lPos)
{
	errno = 0;

	if (!dirp)
	{
		errno = EFAULT;
		return;
	}

	if (lPos < -1)
	{
		/* Seeking to an invalid position. */
		errno = EINVAL;
		return;
	}
	else if (lPos == -1)
	{
		/* Seek past end. */
		if (dirp->dd_handle != -1)
		{
			_findclose (dirp->dd_handle);
		}
		dirp->dd_handle = -1;
		dirp->dd_stat = -1;
	}
	else
	{
		/* Rewind and read forward to the appropriate index. */
		rewinddir (dirp);

		while ((dirp->dd_stat < lPos) && readdir(dirp))
			;
	}
}

#ifdef _WIN32
#pragma warning( pop )
#endif
