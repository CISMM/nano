/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

//*******************************************************************
// VRPN client for a Keithley 2400 meter, which does voltage or current 
// sweeps and measures current or voltage. Used to measure resistance
// at a variety of voltages, typically. 

//*******************************************************************

#ifdef _win32
#include <windows.h>
#else
#include <stdlib.h>
#endif

#include <stdio.h>

#include <vrpn_FileConnection.h>

#include "myUtil.h"
#include "nma_Keithley2400.h"

#define CHECK(a) if ((a) == -1) return -1


nma_Keithley2400::nma_Keithley2400(const char *name, vrpn_Connection *c) :
        nmb_Device_Client(name, c),
	vrpn_GPIBDevice(name, d_connection),
	d_board_index(0),
	d_primary_address(24),
	d_secondary_address(0),
	d_output_on(0),
	d_initialized(0),
	d_repeat_curve_active(0),
	d_display_enable(1), 
		// Set default values for a normal voltage sweep.
	d_source(VOLTAGE), 
	d_compliance(CURRENT),
	d_compliance_val((float)0.1),
	d_num_power_line_cycles((float)1.0),
	d_sweep(LINEAR),
	d_sweep_start((float)-1.0),
	d_sweep_stop((float)1.0),
	d_sweep_numpoints(21),
	d_sweep_delay((float)0.01),
	d_initial_delay( 1 ),
	d_zero_after_meas( true ),
	d_wire_type(2),

	result_change_list(NULL),
	error_change_list(NULL)
{
  if ( !d_connection ) {
    fprintf(stderr, "No live connection to %s.\n", name );
    exit( 0 );
  }

  d_connection->register_handler(d_Result_type,
				handle_Result,
				this);
  d_connection->register_handler(d_ResultData_type,
				handle_ResultData,
				this);
  d_connection->register_handler(d_Error_type,
				handle_Error,
				this);

  d_connection->register_handler(d_Shutdown_type,
				handle_Shutdown,
				this);
}

nma_Keithley2400::~nma_Keithley2400() {
  send_OutputOff();
}

int nma_Keithley2400::mainloop (const struct timeval * timeout ) {
  if (d_connection)
    CHECK(d_connection->mainloop(timeout));

  return 0;
}


bool nma_Keithley2400::isReadingStreamFile( )
{
  if( d_connection == NULL ) return false;
  return ( d_connection->get_File_Connection() != NULL );
}


int nma_Keithley2400::getTimeSinceConnected( void ) 
{
  timeval elapsedTime;

  if( d_connection == NULL ) return -1; // we're not really connected
  if( isReadingStreamFile( ) ) 
  {
    vrpn_File_Connection * logFile;
    logFile = (vrpn_File_Connection *)(d_connection->get_File_Connection());
    logFile->time_since_connection_open(&elapsedTime);
  }
  else
  {
    d_connection->time_since_connection_open(&elapsedTime);
  }
  return elapsedTime.tv_sec;
}


int nma_Keithley2400::send_AllSettings() {
    	if (send_OutputOff()) {
	    printf("send_OutputOff() failed\n");
	    return -1;
	}
	if (send_DisplayEnable())  {
	    printf("send_DisplayEnable() failed\n");
	    return -1;
	}
	if (send_Function()) {
	    printf("send_Function() failed\n");
	    return -1;
	}
	if (send_Source()) {
	    printf("send_Source() failed\n");
	    return -1;
	}
	if (send_Sense()) {
	    printf("send_Sense()  failed\n");
	    return -1;
	}
	if (send_Trigger()) {
	    printf("send_Trigger() failed\n");
	    return -1;
	}
	if (send_DataFormat()) {
	    printf("send_DataFormat() failed\n");
	    return -1;
	}
	if (send_WireType()) {
	    printf("send_WireType() failed\n");
	    return -1;
	}
 	if (send_OutputOn()) {
 	    printf("send_OutputOn() failed\n");
 	    return -1;
 	}
	return 0;
}

int nma_Keithley2400::send_Device() 
{
	vrpn_int32 len;
	char * msgbuf = encode_Device(&len, d_board_index, d_primary_address, d_secondary_address);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Device: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Device_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Device: couldn't send message.\n");
		return -1;
	}
	// Clear the instrument right away.
	msgbuf = encode_DeviceID(&len, d_primary_address, d_secondary_address);
	if(Send(len, d_Clear_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Device: couldn't send message.\n");
		return -1;
	}
	// Remember that we have initialized the device.
	d_initialized = 1;
	return 0;
}

// This may be a more authoritive clear than the one sent in the Device command.
int nma_Keithley2400::send_Clear() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Clear - Keithley not initialized, not sending\n");
		return -1;
	}
	vrpn_int32 len;
	char buf[]  = ":ABOR;*CLS;*RST;";
	//	char buf[]  = "SDC";
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Clear: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Clear: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_DisplayEnable()
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Function - Keithley not initialized, not sending\n");
		return -1;
	}
	vrpn_int32 len;
	char  buf[256];
        if (d_display_enable) {
          sprintf(buf, ":DISPLAY:ENABLE ON");
        } else {
          sprintf(buf, ":DISPLAY:ENABLE OFF");
        } 
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Function: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Function: couldn't send message.\n");
		return -1;
	}

	return 0;

}

int nma_Keithley2400::send_Function() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Function - Keithley not initialized, not sending\n");
		return -1;
	}
	vrpn_int32 len;
	char  buf[256];
	if (d_source == VOLTAGE) {
		sprintf(buf, ":FUNC:CONC OFF;:FUNC 'CURR';");
	} else if (d_source == CURRENT) {
		sprintf(buf, ":FUNC:CONC OFF;:FUNC 'VOLT';");
	} else {
	    fprintf(stderr, "nma_Keithley2400::send_Function: unknown source type.\n");
	    return -1; 
	}
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Function: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Function: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_Source() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Source - Keithley not initialized, not sending\n");
		return -1;
	}

	// XXX This is wrong, doesn't work for log sweeps - need to switch to numpoints.
	vrpn_int32 len;
	char buf[256] ;
	if (d_source == VOLTAGE) {
		sprintf(buf, ":SOUR:FUNC VOLT;"
                             ":SOUR:VOLT:MODE SWE;"
                             ":SOUR:VOLT:RANG:AUTO ON;"
                             ":SOUR:SWE:DIR UP;"
                             ":SOUR:SWE:SPAC %s;"
                             ":SOUR:VOLT:START %g;"
                             ":SOUR:VOLT:STOP %g;"
                             ":SOUR:SWE:POIN %d;"
                             ":SOUR:DEL %g;", 
                             ((d_sweep == LINEAR)? "LIN":"LOG"), 
                             (float)d_sweep_start, 
                             (float)d_sweep_stop, 
                             (int)d_sweep_numpoints,
                             (float) d_sweep_delay );

	} else if (d_source == CURRENT) {
		sprintf(buf, ":SOUR:FUNC CURR;"
                             ":SOUR:CURR:MODE SWE;"
                             ":SOUR:CURR:RANG:AUTO ON;"
                             ":SOUR:SWE:DIR UP;"
                             ":SOUR:SWE:SPAC %s;"
                             ":SOUR:CURR:START %g;"
                             ":SOUR:CURR:STOP %g;"
                             ":SOUR:SWE:POIN %d;"
                             ":SOUR:DEL %g;", 
                             ( (d_sweep == LINEAR) ? "LIN" : "LOG"), 
                             (float) d_sweep_start, 
                             (float) d_sweep_stop, 
                             (int) d_sweep_numpoints,
                             (float) d_sweep_delay );
	} else {
	    fprintf(stderr, "nma_Keithley2400::send_Source: unknown source type.\n");
	    return -1; 
	}
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Source: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Source: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_Sense() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Sense - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	char buf[256] ;
	if (d_compliance == CURRENT) {
		sprintf(buf, ":SENS:CURR:NPLC %g;"
                             ":SENS:CURR:PROT %g;"
                             ":SENS:CURR:RANG:AUTO ON;",
                             (float)d_num_power_line_cycles, 
                             (float)d_compliance_val);

	} else if (d_compliance == VOLTAGE){
		sprintf(buf, ":SENS:VOLT:NPLC %g;"
                             ":SENS:VOLT:PROT %g;"
                             ":SENS:VOLT:RANG:AUTO ON;", 
			(float)d_num_power_line_cycles, (float)d_compliance_val);
	} else {
	    fprintf(stderr, "nma_Keithley2400::send_Sense: unknown compliance type.\n");
	    return -1;
	}
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Sense: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Sense: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_Trigger() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_Trigger - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	char buf[256] ;
	sprintf(buf, ":TRIG:COUN %d;"
                     "SOUR IMM;"
                     "TCON:DIR SOUR;", 
                     (int)(d_sweep_numpoints) );
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_Trigger: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_Trigger: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_DataFormat() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_DataFormat - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	char buf[256] ;
	// XXX This requests binary data, so we had better call send_ReadFloatData later!
	// Always read both voltage and current, so that we 
	// can tell what was measured in the stream file. 
	sprintf(buf, ":FORM:ELEM VOLT,CURR;DATA SREAL;BORD SWAP;");
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_DataFormat: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_DataFormat: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_OutputOn() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_OutputOn - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	char buf[256] ;
	sprintf(buf, ":Outp:Smode NORM;Interlock:State Off;:Outp On");
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_OutputOn: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_OutputOn: couldn't send message.\n");
		return -1;
	}
	// Remember that the output is on.
	d_output_on = 1;
	return 0;
}

int nma_Keithley2400::send_AcquireData() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_StartCurve - Keithley not initialized, not sending\n");
		return -1;
	}
	if (! d_output_on) {
		printf("send_StartCurve: Ouput not on - did you really want to do this?\n");
	}

	vrpn_int32 len;
	char buf[256] ;
	
	// jump the voltage/current to start point and wait 1 second
	if (d_source == VOLTAGE) 
	{		
		sprintf( buf, ":SOUR:VOLT:MODE FIX;"
					  ":SOUR:VOLT %f;"
					  ":TRIG:COUN 1;"
					  ":INIT;",  d_sweep_start );
	}
	else if (d_source == CURRENT )
	{
		sprintf( buf, ":SOUR:CURR:MODE FIX;"
					  ":SOUR:CURR %f;"
					  ":TRIG:COUN 1;"
					  ":INIT;", d_sweep_start );
	}
	else
	{
		sprintf( buf, "" );
	}
	char* msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_AcquireData: out of memory.\n");
		return -1;
	}
	if(SendImmediately(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_AcquireData:"
			" couldn't send message.\n");
		return -1;
	}
	vrpn_SleepMsecs( 1000 * d_initial_delay );
	
	// reset all the values to those we want for measurement
	send_AllSettings();

	// read data, and set the output to 0 afterwards
	if( d_zero_after_meas == true && d_source == VOLTAGE) 
	{		
		sprintf( buf, ":READ?;"
					  ":SOUR:VOLT:MODE FIX;"
					  ":SOUR:VOLT 0;"
					  ":TRIG:COUN 1;"
					  ":INIT;" );
	}
	else if( d_zero_after_meas == true && d_source == CURRENT )
	{
		sprintf( buf, ":READ?;"
					  ":SOUR:CURR:MODE FIX;"
					  ":SOUR:CURR 0;"
					  ":TRIG:COUN 1;"
					  ":INIT;" );
	}
	else
	{
		sprintf( buf, ":READ?;" );
	}
	msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_AcquireData: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_AcquireData:"
			" couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_ReadData() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_GetData - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	
	// I think there are 14 ascii characters per data point, 
	// so overestimate a bit. Both voltage and current measured
	char * msgbuf = encode_Read(&len, d_primary_address, d_secondary_address, d_sweep_numpoints*32);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_GetData: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Read_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_GetData: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_ReadFloatData() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_GetData - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	// Send number of floats
	char * msgbuf = encode_ReadData(&len, d_primary_address, d_secondary_address, 2*d_sweep_numpoints);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_GetData: out of memory.\n");
		return -1;
	}
	if(Send(len, d_ReadData_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_GetData: couldn't send message.\n");
		return -1;
	}

	return 0;
}

int nma_Keithley2400::send_DoCurve() 
{
    if (send_AcquireData()) return -1;
    return(send_ReadFloatData());
}

int nma_Keithley2400::send_OutputOff() 
{
	if (!d_initialized) { 
		fprintf(stderr, "send_OutputOff - Keithley not initialized, not sending\n");
		return -1;
	}

	vrpn_int32 len;
	char buf[256] ;
	sprintf(buf, ":Outp Off");
	char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
	if (msgbuf == NULL) {
		fprintf(stderr, "nma_Keithley2400::send_OutputOff: out of memory.\n");
		return -1;
	}
	if(Send(len, d_Write_type, msgbuf)) {
		fprintf(stderr, "nma_Keithley2400::send_OutputOff: couldn't send message.\n");
		return -1;
	}
	// Remember that we turned output off. 
	d_output_on = 0;

	return 0;
}

int nma_Keithley2400::send_WireType() 
{
    if (!d_initialized) { 
	fprintf(stderr, "send_DataFormat - Keithley not initialized, not sending\n");
	return -1;
    }

    vrpn_int32 len;
    char buf[256] ;

    if ( d_wire_type == 2 ) {
	sprintf(buf, ":SENS:FUNC:CONC ON; :FORM:ELEM VOLT,CURR;DATA SREAL;BORD SWAP; :SYST:RSEN OFF");
    }
    else {
	sprintf(buf, ":SENS:FUNC:CONC ON; :FORM:ELEM VOLT,CURR;DATA SREAL;BORD SWAP; :SYST:RSEN ON");
    }
    char * msgbuf = encode_Write(&len, d_primary_address, d_secondary_address, buf);
    if (msgbuf == NULL) {
	fprintf(stderr, "nma_Keithley2400::send_DataFormat: out of memory.\n");
	return -1;
    }
    if(Send(len, d_Write_type, msgbuf)) {
	fprintf(stderr, "nma_Keithley2400::send_DataFormat: couldn't send message.\n");
	return -1;
    }
    
    return 0;
}

int nma_Keithley2400::register_result_handler(void *userdata,
			    vrpn_VIRESULTDATAHANDLER handler)
{
    vrpn_RESULTDATALIST *new_entry;

    if (handler == NULL) {
        fprintf(stderr, "nma_Keithley2400::reg_handler:NULL handler\n");
        return -1;
    }
    if ((new_entry = new vrpn_RESULTDATALIST) == NULL) {
        fprintf(stderr, "nma_Keithley2400::reg_handler:out of memory\n");
        return -1;
    }
    new_entry->handler = handler;
    new_entry->userdata = userdata;
    
    new_entry->next = result_change_list;
    result_change_list = new_entry;
    return 0;
}

int nma_Keithley2400::unregister_result_handler(void *userdata,
			      vrpn_VIRESULTDATAHANDLER handler)
{
    vrpn_RESULTDATALIST *victim, **snitch;

    snitch = &result_change_list;
    victim = *snitch;
    while ( (victim != NULL) &&
        ( (victim->handler != handler) ||
          (victim->userdata != userdata) )) {
          snitch = &( (*snitch)->next );
          victim = victim->next;
    }   
    
    if (victim == NULL) {
        fprintf(stderr,"nma_Keithley2400::unreg_handler: No such handler\n");
        return -1;
    }
    // Remove the entry from the list
    *snitch = victim->next;
    delete victim;
    victim = NULL;
    
    return 0;

}

int nma_Keithley2400::rcv_Error(char * my_buf)
{
	if(my_buf) {
		printf("Error: %s\n", my_buf);
		delete [] my_buf;
	}
	// An error clears the Keithley, so it's no longer initialized. 
	d_output_on = 0;
	d_initialized = 0;
	d_repeat_curve_active = 0;
	return 0;
}

int nma_Keithley2400::rcv_Shutdown()
{
	return 0;
}

//*********
// Message handlers

// XXX does not perform any callbacks. Request for data assumes
// handle_ResultData will be called.
//static 
int nma_Keithley2400::handle_Result( void *_userdata, vrpn_HANDLERPARAM _p )
{
	nma_Keithley2400 * me = (nma_Keithley2400 *)_userdata;
	char * my_buf;
	
	vrpn_int32 pad, sad;
	me->decode_Result(&_p.buffer, &pad,&sad, &my_buf);
	if ( (pad != me->d_primary_address) || (sad != me->d_secondary_address) )
	    return 0;
	if(my_buf) {
		printf("Result: %s\n", my_buf);
		delete [] my_buf;
	}

	// Do repeated IV curves, if we are set to do so. 
	if (me->d_repeat_curve_active) {
	    me->send_DoCurve();
	}
	return 0;
}

//static 
int nma_Keithley2400::handle_ResultData( void *_userdata, vrpn_HANDLERPARAM _p )
{
	nma_Keithley2400 * me = (nma_Keithley2400 *)_userdata;
	vrpn_int32 len; 
	float * my_data;
	
	vrpn_int32 pad, sad;
	me->decode_ResultData(&_p.buffer, &pad, &sad, &my_data, &len);
	if ( (pad != me->d_primary_address) || (sad != me->d_secondary_address) )
	    return 0;

	// Yank some callbacks. 
	vrpn_VIRESULTDATACB info;
	vrpn_RESULTDATALIST * handler = me->result_change_list;

	info.msg_time = _p.msg_time;
	info.num_values = len;
	info.data = my_data;

    while (handler != NULL) {
	handler->handler(handler->userdata, info);
	handler = handler->next;
    }

	if (my_data)
		delete [] my_data;

	// Do repeated IV curves, if we are set to do so. 
	if (me->d_repeat_curve_active) {
	    me->send_DoCurve();
	}
	return 0 ;
}

// XXX Does not perform any callbacks.
//static 
int nma_Keithley2400::handle_Error( void *_userdata, vrpn_HANDLERPARAM _p )
{
	nma_Keithley2400 * me = (nma_Keithley2400 *)_userdata;
	char * my_buf;
	
	vrpn_int32 pad, sad;
	me->decode_Error(&_p.buffer, &pad, &sad, &my_buf);
	if ( (pad != me->d_primary_address) || (sad != me->d_secondary_address) )
	    return 0;
	return(me->rcv_Error(my_buf));
}

//static 
int nma_Keithley2400::handle_Shutdown( void *_userdata,
                                       vrpn_HANDLERPARAM /*_p*/ )
{
	nma_Keithley2400 * me = (nma_Keithley2400 *)_userdata;

	return(me->rcv_Shutdown());
}

int nma_Keithley2400::Send( vrpn_int32 len, vrpn_int32 msg_type, char * buf )
{
  struct timeval now;
  int retval;

  gettimeofday(&now, NULL);
  // DON'T check for a null buffer - we want to send the message even if
  // it has no contents - it might be important, after all. 
  if ((!d_connection) || (!d_connection->doing_okay())) {
    //fprintf(stderr, "Send(): connection is not ok!!!\n");
    return 0;
  }
    retval = d_connection->pack_message(len, now, msg_type, d_myId,
					buf, vrpn_CONNECTION_RELIABLE);
  if ( buf ) 
    delete [] buf;

  return retval;
}


// Send a message, force the connection to send it immediately, delete [] the message buffer
int nma_Keithley2400::SendImmediately( vrpn_int32 len, vrpn_int32 msg_type, char* buf )
{
	int retval = this->Send( len, msg_type, buf );
	if( retval == 0 ) // okay so far
	{
		retval = retval || d_connection->send_pending_reports();
	}
	return retval;
}
