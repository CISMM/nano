OUTPUT_FILENAME nmm_SimulatedMicroscope_Remote.C
//


#include "nmm_SimulatedMicroscope_Remote.h"

#include <stdlib.h>
#include <stdio.h>
#if !defined(_WIN32)
	#include <sys/time.h> 
	#include <unistd.h>  // for sleep()
#endif
#include <BCPlane.h>
#include <BCGrid.h>
#include <nmb_Dataset.h>
#include <vrpn_Connection.h>

//



USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report

CLASSNAME nmm_SimulatedMicroscope_Remote

//



//constructor
//name is the name of the remote device (I think), connection should be
//initialized already by vrpn_get_connection_by_name

nmm_SimulatedMicroscope_Remote::nmm_SimulatedMicroscope_Remote
  (const char * name, vrpn_Connection * connection, const char * planename, 
  nmb_Dataset * dataset, URender * testobject) : nmm_AFMSIM_Report(connection), nmm_AFMSIMSERVER_Report(connection),
  nmb_SharedDevice_Remote(name,connection), d_dataset(dataset), 
  RealAFMPlaneName(d_dataset->heightPlaneName->string()),
  RealAFMPlane(d_dataset->inputGrid->getPlaneByName(RealAFMPlaneName)), 
  d_connection(connection)
{
	REGISTER nmm_AFMSIM_Report;
	//REGISTER nmm_AFMSIMSERVER_Report;
	d_gotConnection_type =
        d_connection->register_message_type(vrpn_got_connection);
	connection->register_handler(d_gotConnection_type,
                    handle_gotConnection,
                    this);
//
	simulator_id = d_connection->register_sender("AFMSimulator");
	Xdim = d_dataset->inputGrid->numX();
	Ydim = d_dataset->inputGrid->numY();
	DATA_ARRAY_SIZE = Xdim*Ydim;
	DataArray = NULL;
	SimScanPlane = new nma_ShapeIdentifiedPlane(RealAFMPlane, d_dataset, planename,NULL);
	DataArray = new double*[Xdim]; //ANDREA:  check on whether this should be something sent over
								   //or stay as is
	UnitsOK = true;
	myURenderObject = testobject;
}
//
nmm_SimulatedMicroscope_Remote::~nmm_SimulatedMicroscope_Remote() {
	//delete SimScanPlane;
}
//
int nmm_SimulatedMicroscope_Remote::mainloop() {
  return d_connection->mainloop();
}
//
void nmm_SimulatedMicroscope_Remote::
sendCylinders(URender * obj){
	float midpt_x,midpt_y,midpt_z;

	myURenderObject = obj;

	for(int i = 0; i < myURenderObject->num_cylinders; ++i){
	//only sends cylinders if they have been filled in in URender 
    //(i.e. num_cylinders != 0), so safe to keep have this for loop here
	    midpt_x = (myURenderObject->cylinders[i].x2 + myURenderObject->cylinders[i].x1)/2;
		midpt_y = (myURenderObject->cylinders[i].y2 + myURenderObject->cylinders[i].y1)/2;
		midpt_z = (myURenderObject->cylinders[i].z2 + myURenderObject->cylinders[i].z1)/2;
	    encode_and_sendCylinder(
			midpt_x,midpt_y,midpt_z,
			myURenderObject->cylinders[i].alt,
			myURenderObject->cylinders[i].az,
			myURenderObject->cylinders[i].length,
			myURenderObject->cylinders[i].radius);
			cout << "sendCylinders: alt: " << myURenderObject->cylinders[i].alt << "\taz:  " 
				 << myURenderObject->cylinders[i].az << endl;
	}
	encode_and_sendTrans(myURenderObject->GetLocalXform().GetTrans()[0],
						myURenderObject->GetLocalXform().GetTrans()[1],
						myURenderObject->GetLocalXform().GetTrans()[2]);
	encode_and_sendScale(myURenderObject->GetLocalXform().GetScale());
}
//
HANDLERS nmm_AFMSIM_Report ; 
//
int nmm_SimulatedMicroscope_Remote::
handle_gotConnection (void * userdata, vrpn_HANDLERPARAM grpc_p) {
  //int i;
  float midpt_x,midpt_y,midpt_z;
  const char * buffer = grpc_p.buffer;
  nmm_SimulatedMicroscope_Remote* grpc_me = (nmm_SimulatedMicroscope_Remote *) userdata;
  
  //send grid and scan info
  grpc_me->encode_and_sendGridandScanInfo(grpc_me->d_dataset->inputGrid->numX(), grpc_me->d_dataset->inputGrid->numY(),
			grpc_me->d_dataset->inputGrid->minX(),grpc_me->d_dataset->inputGrid->minY(),0,
			grpc_me->d_dataset->inputGrid->maxX(),grpc_me->d_dataset->inputGrid->maxY(),128);
//


//
  if(grpc_me->myURenderObject != NULL){
   
/*		//model-triangles stuff
		int num_vertices = (grpc_me->myURenderObject->num_triangles * 3);
		cout << "num triangles: " << grpc_me->myURenderObject->num_triangles 
		     << "\tnum vertices: " << num_vertices << endl;

		//send triangle scale
		if (num_vertices != 0){
			grpc_me->encode_and_sendScale(grpc_me->myURenderObject->scale_triangles);
		}
//
		//send triangles
		for(i = 0; i < num_vertices;i += 3){//only sends triangles if they have been filled in in URender 
                                          //(i.e. num_triangles != 0), so safe to keep have this for loop here
			grpc_me->encode_and_sendTriangle(
				grpc_me->myURenderObject->triangles[i][0],  
				grpc_me->myURenderObject->triangles[i][1],
				grpc_me->myURenderObject->triangles[i][2],
				grpc_me->myURenderObject->triangles[i + 1][0],
				grpc_me->myURenderObject->triangles[i + 1][1],
				grpc_me->myURenderObject->triangles[i + 1][2],
				grpc_me->myURenderObject->triangles[i + 2][0],
				grpc_me->myURenderObject->triangles[i + 2][1],
				grpc_me->myURenderObject->triangles[i + 2][2]);  
		}
//
		//for debugging puposes
		FILE * file;
		if ( (file = fopen("triangles_sent.txt", "w")) == NULL) {
				fprintf(stderr,"Could not open triangles.txt for write\n");
				return -1;
		}
//
		for(i = 0; i < num_vertices;i++){

			fprintf(file,"%g,%g,%g\n\n",
				grpc_me->myURenderObject->triangles[i][0],
				grpc_me->myURenderObject->triangles[i][1],
				grpc_me->myURenderObject->triangles[i][2]);
		}
		fclose(file);

*/
		
		for(int i = 0; i < grpc_me->myURenderObject->num_cylinders; ++i){
		//only sends cylinders if they have been filled in in URender 
        //(i.e. num_cylinders != 0), so safe to keep have this for loop here
		    midpt_x = (grpc_me->myURenderObject->cylinders[i].x2 + grpc_me->myURenderObject->cylinders[i].x1)/2;
			midpt_y = (grpc_me->myURenderObject->cylinders[i].y2 + grpc_me->myURenderObject->cylinders[i].y1)/2;
			midpt_z = (grpc_me->myURenderObject->cylinders[i].z2 + grpc_me->myURenderObject->cylinders[i].z1)/2;
		    grpc_me->encode_and_sendCylinder(
				midpt_x,midpt_y,midpt_z,
				grpc_me->myURenderObject->cylinders[i].alt,
				grpc_me->myURenderObject->cylinders[i].az,
				grpc_me->myURenderObject->cylinders[i].length,
				grpc_me->myURenderObject->cylinders[i].radius);

				cout << "handle_gotConnection: alt: " << grpc_me->myURenderObject->cylinders[i].alt << "\taz:  " 
					 << grpc_me->myURenderObject->cylinders[i].az << endl;
		}
		
		grpc_me->encode_and_sendTrans(grpc_me->myURenderObject->GetLocalXform().GetTrans()[0],
										grpc_me->myURenderObject->GetLocalXform().GetTrans()[1],
										grpc_me->myURenderObject->GetLocalXform().GetTrans()[2]);
		grpc_me->encode_and_sendScale(grpc_me->myURenderObject->GetLocalXform().GetScale());
		
	}//end if(grpc_me->myURenderObject != NULL)
//
  //code from when we were using triangles, keeping it here in case want to use quaternions (scaling)/triangles
  //any time in the future
  /*if(grpc_me->myURenderObject != NULL){
		q_vec_type p1, p2, p3;

		//send triangle scale
		if (num_vertices != 0){
//			grpc_me->encode_and_sendTriangleScale(grpc_me->myURenderObject->GetLocalXform().GetScale());
			grpc_me->encode_and_sendTriangleScale(1.0);
		}
//
		//send triangles
		for(i = 0; i < num_vertices;i += 3){//only sends triangles if they have been filled in in URender 
                                          //(i.e. num_triangles != 0), so safe to keep have this for loop here
			// rotate and translate points

			q_vec_set(p1, grpc_me->myURenderObject->triangles[i][0],
							grpc_me->myURenderObject->triangles[i][1],
							grpc_me->myURenderObject->triangles[i][2]);

			q_vec_set(p2, grpc_me->myURenderObject->triangles[i + 1][0],
							grpc_me->myURenderObject->triangles[i + 1][1],
							grpc_me->myURenderObject->triangles[i + 1][2]);

			q_vec_set(p3, grpc_me->myURenderObject->triangles[i + 2][0],
							grpc_me->myURenderObject->triangles[i + 2][1],
							grpc_me->myURenderObject->triangles[i + 2][2]);

			// rotate
			q_xform(p1, grpc_me->myURenderObject->GetLocalXform().GetRot(), p1);
			q_xform(p2, grpc_me->myURenderObject->GetLocalXform().GetRot(), p2);
			q_xform(p3, grpc_me->myURenderObject->GetLocalXform().GetRot(), p3);

			// translate
			q_vec_add(p1, grpc_me->myURenderObject->GetLocalXform().GetTrans(), p1);
			q_vec_add(p2, grpc_me->myURenderObject->GetLocalXform().GetTrans(), p2);
			q_vec_add(p3, grpc_me->myURenderObject->GetLocalXform().GetTrans(), p3);

			// scale
//			q_vec_scale(p1, grpc_me->myURenderObject->GetLocalXform().GetScale(), p1);
//			q_vec_scale(p2, grpc_me->myURenderObject->GetLocalXform().GetScale(), p2);
//			q_vec_scale(p3, grpc_me->myURenderObject->GetLocalXform().GetScale(), p3);

			q_vec_scale(p1, 2, p1);
			q_vec_scale(p2, 2, p2);
			q_vec_scale(p3, 2, p3);


			grpc_me->encode_and_sendTriangle(
				p1[0], p1[1], p1[2],
				p2[0], p2[1], p2[2],
				p3[0], p3[1], p3[2]);  
		}
//
		//for debugging puposes
		FILE * file;
		if ( (file = fopen("triangles_sent.txt", "w")) == NULL) {
				fprintf(stderr,"Could not open triangles.txt for write\n");
				return -1;
		}
//
		for(i = 0; i < num_vertices;i++){

			fprintf(file,"%g,%g,%g\n\n",
				grpc_me->myURenderObject->triangles[i][0],
				grpc_me->myURenderObject->triangles[i][1],
				grpc_me->myURenderObject->triangles[i][2]);
		}
		fclose(file);
  }*/

	//grpc_me->encode_and_sendCylinder(60.0f,60.0f,0.0f,30.0f,30.0f,100.0f,10.0f);

	return 0;
}
//
/*
typedef struct {
	double x, y, z;
	double radius;
	double az;
	double alt;
} cylinder;

	cylinder* cylinders;
	long num_cylinders;
*/

//

RECEIVE_MSG WindowLineData {

//
	if(UnitsOK){//check that units match before allowing in data
//
		//check to see that the data the "microscope" wants to send is not greater than the
		//number of samples the input grid contains/can hold
		//check is whether initial (x), which is counted as zero, + (reports - 1), the number
		//of data points following the Oth data point sent, is greater than the number of 
		//points per row; analogous situation for y
		//
		/*int datain_xmax = x+(reports-1)*dx;
		int datain_ymax = y+(reports-1)*dy;
		if (x < 0 || y < 0 || datain_xmax > Xdim || datain_ymax > Ydim) {
			cerr << "Internal: grid size doesn't match reported data size."
				 << "Exiting to avoid loss of data." << endl; 
			return;
		}*///ANDREA:  taking this out for right now because we can interpolate between data points up or down to
		   //fit required size...
//	
  		if (RealAFMPlane == NULL) return;
//
		DataArray[y] = new double[reports];//DataArray[y] is a double*
		//for each new y that is sent, create a new array to be filled in
//
		for (int i = 0; i < reports; i++) {
			int new_x = x + i*dx;
			int new_y = y + i*dy;
//
			DataArray[y][i] = (double)(data[new_x][0]);//fill in
		}
		//
		if(SimScanPlane){
			SimScanPlane->UpdateDataArray(DataArray[y], y, reports);//send line of data
		}
		else{
			return;
		}
		//delete [] DataArray[y];//figure out if should delete here or not...
		//cleanup for next go-round
  		return;
	}
}
//
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_BODY ScanDataset {

//
	//only deal with datasets[0]
	if(strcmp(units, RealAFMPlane->units()->c_str()) != 0){
//
		cerr << "Units do not match:  sim scan and real scan must be in same units" << endl;
		UnitsOK = false;
//
	}
//		
}
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_HEADER ScanDataset {

//
	//only deal with datasets[0]
	
//		
}

//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendGridandScanInfo(vrpn_int32 x, vrpn_int32 y,
	vrpn_float32 xmin,vrpn_float32 ymin,vrpn_float32 zmin,
	vrpn_float32 xmax,vrpn_float32 ymax,vrpn_float32 zmax){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_ScanRange(&len,xmin,ymin,zmin,xmax,ymax,zmax);//encode msgbuf
  int retval = -1;
  retval = Send((long)len, d_ScanRange_type, msgbuf);//send stuff
  
  char * msgbuf2 = encode_ReportGridSize(&len,x,y);//encode msgbuf
  retval = -1;
  retval = Send((long)len, d_ReportGridSize_type, msgbuf2);//send stuff
  
}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendScale(vrpn_float32 scale){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Scale(&len,scale);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Scale_type, msgbuf)) == -1){
	cout << "problem sending Scale" << endl;
  }//send stuff  
}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendTrans(vrpn_float32 x, vrpn_float32 y, vrpn_float32 z){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Trans(&len,x,y,z);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Trans_type, msgbuf)) == -1){
	cout << "problem sending Trans" << endl;
  }//send stuff  

}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendRot(vrpn_float32 z, vrpn_float32 y, vrpn_float32 x){
//variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Rot(&len,z,y,x);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Rot_type, msgbuf)) == -1){
	cout << "problem sending Rotation" << endl;
  }//send stuff  

}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendTriangle(
	vrpn_float32 _1v1, vrpn_float32 _1v2,vrpn_float32 _1v3,
	vrpn_float32 _2v1, vrpn_float32 _2v2,vrpn_float32 _2v3,
	vrpn_float32 _3v1, vrpn_float32 _3v2,vrpn_float32 _3v3){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Triangle(&len,_1v1,_1v2,_1v3,_2v1,_2v2,_2v3,_3v1,_3v2,_3v3);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Triangle_type, msgbuf)) == -1){
	cout << "problem sending Triangle" << endl;
  }//send stuff  
}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendCylinder(
	vrpn_float32 x, vrpn_float32 y,vrpn_float32 z,
	vrpn_float32 altitude, vrpn_float32 azimuth,
	vrpn_float32 length, vrpn_float32 radius){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Cylinder(&len,x,y,z,azimuth,altitude,length,radius);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Cylinder_type, msgbuf)) == -1){
	cout << "problem sending Cylinder" << endl;
  }//send stuff  
}
//
int nmm_SimulatedMicroscope_Remote::
Send(long len, vrpn_int32 msg_type, char * buf){
	int retval = -1;//initial value denotes failure, do not continue if remains -1
	timeval now;	
	gettimeofday(&now, NULL);
	//pack message
	retval = d_connection->pack_message(len, now, msg_type, simulator_id,
				      buf, vrpn_CONNECTION_RELIABLE);
	if(retval != -1){
		d_connection->mainloop();//send message here
	}
	else{
		cout << "Message not sent" << endl;
	}
	//
	if ( buf ) {
		delete buf;
	}
	return retval;
}




