OUTPUT_FILENAME nmm_SimulatedMicroscope_Remote.C
//


#include "nmm_SimulatedMicroscope_Remote.h"

#include <stdlib.h>
#include <stdio.h>
#if !defined(_WIN32)
	#include <sys/time.h> 
	#include <unistd.h>  // for sleep()
#endif
#include <BCPlane.h>
#include <BCGrid.h>
#include <nmb_Dataset.h>
#include <vrpn_Connection.h>

//



USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report

CLASSNAME nmm_SimulatedMicroscope_Remote

//



//constructor
//name is the name of the remote device (I think), connection should be
//initialized already by vrpn_get_connection_by_name

nmm_SimulatedMicroscope_Remote::nmm_SimulatedMicroscope_Remote
  (const char * name, vrpn_Connection * connection, const char * planename, 
  nmb_Dataset * dataset, URender * testobject) : nmm_AFMSIM_Report(connection), nmm_AFMSIMSERVER_Report(connection),
  nmb_SharedDevice_Remote(name,connection), d_dataset(dataset), 
  RealAFMPlaneName(d_dataset->heightPlaneName->string()),
  RealAFMPlane(d_dataset->inputGrid->getPlaneByName(RealAFMPlaneName)), 
  d_connection(connection)
{
	REGISTER nmm_AFMSIM_Report;
	//REGISTER nmm_AFMSIMSERVER_Report;
	d_gotConnection_type =
        d_connection->register_message_type(vrpn_got_connection);
	connection->register_handler(d_gotConnection_type,
                    handle_gotConnection,
                    this);
//
	simulator_id = d_connection->register_sender("AFMSimulator");
	Xdim = d_dataset->inputGrid->numX();
	Ydim = d_dataset->inputGrid->numY();
	DATA_ARRAY_SIZE = Xdim*Ydim;
	DataArray = NULL;
	SimScanPlane = new nma_ShapeIdentifiedPlane(RealAFMPlane, d_dataset, planename,NULL);
	DataArray = new double*[Xdim]; //ANDREA:  check on whether this should be something sent over
								   //or stay as is
	UnitsOK = true;
	myURenderObject = testobject;
}
//
nmm_SimulatedMicroscope_Remote::~nmm_SimulatedMicroscope_Remote() {
	//delete SimScanPlane;
}
//
int nmm_SimulatedMicroscope_Remote::mainloop() {
  return d_connection->mainloop();
}
//

HANDLERS nmm_AFMSIM_Report ; 
//
int nmm_SimulatedMicroscope_Remote::handle_gotConnection (void * userdata, vrpn_HANDLERPARAM grpc_p) {
  const char * buffer = grpc_p.buffer;
  nmm_SimulatedMicroscope_Remote* grpc_me = (nmm_SimulatedMicroscope_Remote *) userdata;
  
  //send grid and scan info
  grpc_me->encode_and_sendGridandScanInfo(grpc_me->d_dataset->inputGrid->numX(), grpc_me->d_dataset->inputGrid->numY(),
			grpc_me->d_dataset->inputGrid->minX(),grpc_me->d_dataset->inputGrid->minY(),0,
			grpc_me->d_dataset->inputGrid->maxX(),grpc_me->d_dataset->inputGrid->maxY(),128);
    
  int num_vertices = (grpc_me->myURenderObject->num_triangles * 3);
  cout << "num triangles: " << grpc_me->myURenderObject->num_triangles << "\tnum vertices: " << num_vertices << endl;
  //send triangles
  if (num_vertices != 0){
	grpc_me->encode_and_sendTriangleScale(grpc_me->myURenderObject->scale_triangles);
  }
  for(int i = 0; i < num_vertices;i++){//only sends triangles if they have been filled in in URender 
                                       //(i.e. num_triangles != 0), so safe to keep have this for loop here
	grpc_me->encode_and_sendTriangle(
		grpc_me->myURenderObject->triangles[i][0],  grpc_me->myURenderObject->triangles[i][1],grpc_me->myURenderObject->triangles[i][2],
		grpc_me->myURenderObject->triangles[++i][0],grpc_me->myURenderObject->triangles[i][1],grpc_me->myURenderObject->triangles[i][2],
		grpc_me->myURenderObject->triangles[++i][0],grpc_me->myURenderObject->triangles[i][1],grpc_me->myURenderObject->triangles[i][2]);
  }
  
  return 0;
}
//
RECEIVE_MSG WindowLineData {

//
	if(UnitsOK){//check that units match before allowing in data
//
		//check to see that the data the "microscope" wants to send is not greater than the
		//number of samples the input grid contains/can hold
		//check is whether initial (x), which is counted as zero, + (reports - 1), the number
		//of data points following the Oth data point sent, is greater than the number of 
		//points per row; analogous situation for y
		//
		/*int datain_xmax = x+(reports-1)*dx;
		int datain_ymax = y+(reports-1)*dy;
		if (x < 0 || y < 0 || datain_xmax > Xdim || datain_ymax > Ydim) {
			cerr << "Internal: grid size doesn't match reported data size."
				 << "Exiting to avoid loss of data." << endl; 
			return;
		}*///ANDREA:  taking this out for right now because we can interpolate between data points up or down to
		   //fit required size...
//	
  		if (RealAFMPlane == NULL) return;
//
		DataArray[y] = new double[reports];//DataArray[y] is a double*
		//for each new y that is sent, create a new array to be filled in
//
		for (int i = 0; i < reports; i++) {
			int new_x = x + i*dx;
			int new_y = y + i*dy;
//
			DataArray[y][i] = (double)(data[new_x][0]);//fill in
		}
		//
		if(SimScanPlane){
			SimScanPlane->UpdateDataArray(DataArray[y], y, reports);//send line of data
		}
		else{
			return;
		}
		//delete [] DataArray[y];//figure out if should delete here or not...
		//cleanup for next go-round
  		return;
	}
}
//
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_BODY ScanDataset {

//
	//only deal with datasets[0]
	if(strcmp(units, RealAFMPlane->units()->Characters()) != 0){
//
		cerr << "Units do not match:  sim scan and real scan must be in same units" << endl;
		UnitsOK = false;
//
	}
//		
}
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_HEADER ScanDataset {

//
	//only deal with datasets[0]
	
//		
}

//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendGridandScanInfo(vrpn_int32 x, vrpn_int32 y,
	vrpn_float32 xmin,vrpn_float32 ymin,vrpn_float32 zmin,
	vrpn_float32 xmax,vrpn_float32 ymax,vrpn_float32 zmax){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_ScanRange(&len,xmin,ymin,zmin,xmax,ymax,zmax);//encode msgbuf
  int retval = -1;
  retval = Send((long)len, d_ScanRange_type, msgbuf);//send stuff
  
  char * msgbuf2 = encode_ReportGridSize(&len,x,y);//encode msgbuf
  retval = -1;
  retval = Send((long)len, d_ReportGridSize_type, msgbuf2);//send stuff
  
}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendTriangleScale(vrpn_float32 scale){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_TriangleScale(&len,scale);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_TriangleScale_type, msgbuf)) == -1){
	cout << "problem sending Triangle Scale" << endl;
  }//send stuff  
}
//
void nmm_SimulatedMicroscope_Remote::
encode_and_sendTriangle(
	vrpn_float32 _1v1, vrpn_float32 _1v2,vrpn_float32 _1v3,
	vrpn_float32 _2v1, vrpn_float32 _2v2,vrpn_float32 _2v3,
	vrpn_float32 _3v1, vrpn_float32 _3v2,vrpn_float32 _3v3){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_Triangle(&len,_1v1,_1v2,_1v3,_2v1,_2v2,_2v3,_3v1,_3v2,_3v3);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_Triangle_type, msgbuf)) == -1){
	cout << "problem sending Triangle" << endl;
  }//send stuff  
}
//
int nmm_SimulatedMicroscope_Remote::
Send(long len, vrpn_int32 msg_type, char * buf){
	int retval = -1;//initial value denotes failure, do not continue if remains -1
	timeval now;	
	gettimeofday(&now, NULL);
	//pack message
	retval = d_connection->pack_message(len, now, msg_type, simulator_id,
				      buf, vrpn_CONNECTION_RELIABLE);
	if(retval != -1){
		d_connection->mainloop();//send message here
	}
	else{
		cout << "Message not sent" << endl;
	}
	//
	if ( buf ) {
		delete buf;
	}
	return retval;
}




