OUTPUT_FILENAME nmm_SimulatedMicroscope_Remote.C
//


#include "nmm_SimulatedMicroscope_Remote.h"

#include <stdlib.h>
#include <stdio.h>
#if !defined(_WIN32)
	#include <sys/time.h> 
	#include <unistd.h>  // for sleep()
#endif
#include <BCPlane.h>
#include <BCGrid.h>
#include <nmb_Dataset.h>
#include <vrpn_Connection.h>

//



USE_MSG_GROUP nmm_AFMSIM_Report

CLASSNAME nmm_SimulatedMicroscope_Remote

//



//constructor
//name is the name of the remote device (I think), connection should be
//initialized already by vrpn_get_connection_by_name

nmm_SimulatedMicroscope_Remote::nmm_SimulatedMicroscope_Remote
  (const char * name, vrpn_Connection * connection, const char * planename, 
  nmb_Dataset * dataset) : nmm_AFMSIM_Report(connection), nmb_SharedDevice_Remote(name,
  connection), d_dataset(dataset), RealAFMPlaneName(d_dataset->heightPlaneName->string()),
  RealAFMPlane(d_dataset->inputGrid->getPlaneByName(RealAFMPlaneName)), 
  d_connection(connection)
{
	REGISTER nmm_AFMSIM_Report;
//
	Xdim = d_dataset->inputGrid->numX();
	Ydim = d_dataset->inputGrid->numY();
	DATA_ARRAY_SIZE = Xdim*Ydim;
	DataArray = NULL;
	SimScanPlane = new nma_ShapeIdentifiedPlane(RealAFMPlane, d_dataset, planename,NULL);
	DataArray = new double*[Xdim]; //ANDREA:  check on whether this should be something sent over
								   //or stay as is
	UnitsOK = true;
}
//
nmm_SimulatedMicroscope_Remote::~nmm_SimulatedMicroscope_Remote() {
	//delete SimScanPlane;
}
//
int nmm_SimulatedMicroscope_Remote::mainloop() {
  return d_connection->mainloop();
}
//
HANDLERS nmm_AFMSIM_Report ; 
//
RECEIVE_MSG WindowLineData {
//    int32 x
//    int32 y
//    int32 dx
//    int32 dy
//    int32 reports
//    int32 fields
//    int32 sec
//    int32 usec
//    float32 data [reports][fields]
//
	if(UnitsOK){//check that units match before allowing in data
//
		//check to see that the data the "microscope" wants to send is not greater than the
		//number of samples the input grid contains/can hold
		//check is whether initial (x), which is counted as zero, + (reports - 1), the number
		//of data points following the Oth data point sent, is greater than the number of 
		//points per row; analogous situation for y
		//
		int datain_xmax = x+(reports-1)*dx;
		int datain_ymax = y+(reports-1)*dy;

		if (x < 0 || y < 0 || datain_xmax > Xdim || datain_ymax > Ydim) {
			cerr << "Internal: grid size doesn't match reported data size."
				 << "Exiting to avoid loss of data." << endl; 
			return;
		}
//	
  		if (RealAFMPlane == NULL) return;
//
		DataArray[y] = new double[reports];//DataArray[y] is a double*
		//for each new y that is sent, create a new array to be filled in
//
		for (int i = 0; i < reports; i++) {
			int new_x = x + i*dx;
			int new_y = y + i*dy;
//
			DataArray[y][i] = (double)(data[new_x][0]);//fill in
		}
		//
		if(SimScanPlane){
			SimScanPlane->UpdateDataArray(DataArray[y], y, reports);//send line of data
		}
		else{
			return;
		}
		//delete [] DataArray[y];//figure out if should delete here or not...
		//cleanup for next go-round
  		return;
	}
}
//
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_BODY ScanDataset {
//  int32 count
//  struct ScanDataset {
//    char name [64] //name of field
//    char units [64] //units in
//    float32 offset 
//    float32 scale
//  } datasets [count]

//
	//only deal with datasets[0]
	if(strcmp(units, RealAFMPlane->units()->Characters()) != 0){
//
		cerr << "Units do not match:  sim scan and real scan must be in same units" << endl;
		UnitsOK = false;
//
	}
//		
}
//message tells what order the fields are in
//in case of simulator, there is only one field, so datasets will only have one element (height)
RECEIVE_MSG_HEADER ScanDataset {
//  int32 count
//  struct ScanDataset {
//    char name [64] //name of field
//    char units [64] //units in
//    float32 offset 
//    float32 scale
//  } datasets [count]

//
	//only deal with datasets[0]
	
//		
}


