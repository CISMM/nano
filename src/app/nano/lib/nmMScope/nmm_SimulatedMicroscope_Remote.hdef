/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

OUTPUT_FILENAME nmm_SimulatedMicroscope_Remote.h
//
#ifndef NMM_SIMULATEDMICROSCOPE_REMOTE_H
#define NMM_SIMULATEDMICROSCOPE_REMOTE_H

//
#include "nmm_AFMSIM_Report.h"
#include "nmm_AFMSIMSERVER_Report.h"
#include <nmb_SharedDevice.h>
#include <nmb_Dataset.h>
#include "nma_ShapeAnalyze.h"
#include "vrpn_Connection.h"
#include "URTubeFile.h"

//
class nmb_SharedDevice_Remote;
class nmb_Dataset;


//
USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report

CLASSNAME nmm_SimulatedMicroscope_Remote
//


class nmm_SimulatedMicroscope_Remote: public nmm_AFMSIM_Report, 
      public nmm_AFMSIMSERVER_Report, public nmb_SharedDevice_Remote {

public:
	nmm_SimulatedMicroscope_Remote(const char * name, vrpn_Connection * connection, 
		const char * planename, nmb_Dataset * dataset, URTubeFile * testobject = NULL);
	virtual ~nmm_SimulatedMicroscope_Remote();
	int mainloop();
	void encode_and_sendGridandScanInfo(//encode grid and scan info (microscope extent) and nano
										//grid size, and pack to send
		vrpn_int32 x, vrpn_int32 y,
		vrpn_float32 xmin,vrpn_float32 ymin,vrpn_float32 zmin,
		vrpn_float32 xmax,vrpn_float32 ymax,vrpn_float32 zmax);
	void encode_and_sendTriangle(//encode triangle vertices (for 1 triangle) and pack to send
		vrpn_float32 _1v1, vrpn_float32 _1v2,vrpn_float32 _1v3,
		vrpn_float32 _2v1, vrpn_float32 _2v2,vrpn_float32 _2v3,
		vrpn_float32 _3v1, vrpn_float32 _3v2,vrpn_float32 _3v3);
	void encode_and_sendScale(vrpn_float32 scale);
	void encode_and_sendTrans(vrpn_float32 x, vrpn_float32 y, vrpn_float32 z);
	void encode_and_sendRot(vrpn_float32 z, vrpn_float32 y, vrpn_float32 x);
	void encode_and_sendCylinder(
		vrpn_float32 x, vrpn_float32 y,vrpn_float32 z,
		vrpn_float32 altitude, vrpn_float32 azimuth,
		vrpn_float32 length, vrpn_float32 radius);
	void encode_and_sendScanData(float * Data, int y, const int num_cols);
	int Send(long len, vrpn_int32 msg_type, char * buf);//send data across connection
	void sendCylinders(URTubeFile * obj);//function to send cylinders if connection 
									  //made before shape analysis done
	bool deviceNameRcv;
	char* get_server_name();
	char server_name[64];
//
private:

    RECEIVERS_DECL nmm_AFMSIM_Report;
	HANDLERS_DECL nmm_AFMSIM_Report;

	//RECEIVERS_DECL nmm_AFMSIMSERVER_Report;
	//HANDLERS_DECL nmm_AFMSIMSERVER_Report;

	static int VRPN_CALLBACK handle_gotConnection(void * userdata, vrpn_HANDLERPARAM grpc_p);

	nmb_Dataset * d_dataset;	//dataset that real di data is in
	string RealAFMPlaneName;	//name of plane with real di data
	BCPlane * RealAFMPlane;		//plane with real di data
	int Xdim;			        //number of elements in the x dimention in the current
					            //grid, and therefore of RealAFMPlane
	int Ydim;			        //same for y
	double ** DataArray;		    //data array passed to nma_ShapeIdentified class	
	int DATA_ARRAY_SIZE;		//size of DataArray when it finally gets filled
	nma_ShapeIdentifiedPlane * DeviceViewPlane;//new plane formed/filled in when
						        //full array of data has been sent
	bool UnitsOK;			    //so only load information if units check out,
					            //match real afm scan plane
	vrpn_Connection * d_connection;
	long simulator_id;				//our sender id
	vrpn_int32 d_gotConnection_type;//id for connection message we need to receive before we send 
									//anything
	URTubeFile * myURTubeFileObject;	
};
//

#endif // NMM_SIMULATEDMICROSCOPE_REMOTE_H





