OUTPUT_FILENAME nmm_SimulatedMicroscope_Remote.h
//
#ifndef NMM_SIMULATEDMICROSCOPE_REMOTE_H
#define NMM_SIMULATEDMICROSCOPE_REMOTE_H

//
#include "nmm_AFMSIM_Report.h"
#include "nmm_AFMSIMSERVER_Report.h"
#include <nmb_SharedDevice.h>
#include <nmb_Dataset.h>
#include "nma_ShapeAnalyze.h"
#include "vrpn_Connection.h"
#include "URender.h"

//
class nmb_SharedDevice_Remote;
class nmb_Dataset;


//
USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report

CLASSNAME nmm_SimulatedMicroscope_Remote
//


class nmm_SimulatedMicroscope_Remote: public nmm_AFMSIM_Report, 
      public nmm_AFMSIMSERVER_Report, public nmb_SharedDevice_Remote {

public:
	nmm_SimulatedMicroscope_Remote(const char * name, vrpn_Connection * connection, 
		const char * planename, nmb_Dataset * dataset, URender * testobject = NULL);
	virtual ~nmm_SimulatedMicroscope_Remote();
	int mainloop();
	void encode_and_sendGridandScanInfo(//encode grid and scan info (microscope extent) and nano
										//grid size, and pack to send
		vrpn_int32 x, vrpn_int32 y,
		vrpn_float32 xmin,vrpn_float32 ymin,vrpn_float32 zmin,
		vrpn_float32 xmax,vrpn_float32 ymax,vrpn_float32 zmax);
	void encode_and_sendTriangle(//encode triangle vertices (for 1 triangle) and pack to send
		vrpn_float32 _1v1, vrpn_float32 _1v2,vrpn_float32 _1v3,
		vrpn_float32 _2v1, vrpn_float32 _2v2,vrpn_float32 _2v3,
		vrpn_float32 _3v1, vrpn_float32 _3v2,vrpn_float32 _3v3);
	void encode_and_sendScale(vrpn_float32 scale);
	void encode_and_sendTrans(vrpn_float32 x, vrpn_float32 y, vrpn_float32 z);
	void encode_and_sendRot(vrpn_float32 z, vrpn_float32 y, vrpn_float32 x);
	void encode_and_sendCylinder(
		vrpn_float32 x, vrpn_float32 y,vrpn_float32 z,
		vrpn_float32 altitude, vrpn_float32 azimuth,
		vrpn_float32 length, vrpn_float32 radius);
	void encode_and_sendScanData(float * Data, int y, const int num_cols);
	int Send(long len, vrpn_int32 msg_type, char * buf);//send data across connection
	void sendCylinders(URender * obj);//function to send cylinders if connection 
									  //made before shape analysis done
	bool deviceNameRcv;
	char* get_server_name();
	char server_name[64];
//
private:

    RECEIVERS_DECL nmm_AFMSIM_Report;
	HANDLERS_DECL nmm_AFMSIM_Report;

	//RECEIVERS_DECL nmm_AFMSIMSERVER_Report;
	//HANDLERS_DECL nmm_AFMSIMSERVER_Report;

	static int handle_gotConnection(void * userdata, vrpn_HANDLERPARAM grpc_p);

	nmb_Dataset * d_dataset;	//dataset that real di data is in
	string RealAFMPlaneName;	//name of plane with real di data
	BCPlane * RealAFMPlane;		//plane with real di data
	int Xdim;			        //number of elements in the x dimention in the current
					            //grid, and therefore of RealAFMPlane
	int Ydim;			        //same for y
	double ** DataArray;		    //data array passed to nma_ShapeIdentified class	
	int DATA_ARRAY_SIZE;		//size of DataArray when it finally gets filled
	nma_ShapeIdentifiedPlane * DeviceViewPlane;//new plane formed/filled in when
						        //full array of data has been sent
	bool UnitsOK;			    //so only load information if units check out,
					            //match real afm scan plane
	vrpn_Connection * d_connection;
	long simulator_id;				//our sender id
	vrpn_int32 d_gotConnection_type;//id for connection message we need to receive before we send 
									//anything
	URender * myURenderObject;	
};
//

#endif // NMM_SIMULATEDMICROSCOPE_REMOTE_H





