/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/* 
This file contains the code for optimize now. Optimize_now takes in the coordinates of 2 points, and
optimizes the box between the 2 points or the line defined by the 2 points, depending on the mode.
*/
#include <BCPlane.h>
#include <BCGrid.h>
#include <nmm_Types.h>
#include <nmm_Globals.h>


#include <nmb_Globals.h>
#include <nmm_MicroscopeRemote.h>
#include "optimize_now.h"



static int optimizing_now = 0;
static int recieved_points;
static double end_x, end_y;
static double _max_value,_max_value_x_coord,_max_value_y_coord;

void computeOptimizeMinMax( int /*type*/, int x0, int y0, int x1, int y1,
			    double *x_max_coord, double *y_max_coord) {
  float y;
  _max_value = -1.0e33; //the maximum value over the currently optimized points
  int temp; //variables where the the cooridinates of the maximum value will be stored, and a temp var. 
  microscope->ImageMode();
  
  //const int MAX_LOOP_COUNT = 1500;
  optimizing_now = 1; //set flag to say that we are optimizing now
  
  BCPlane * plane = dataset->inputGrid->getPlaneByName
    (dataset->heightPlaneName->string());
  
  //put microscope at point to start optimizing and wait for microscope to get there
  if (microscope->state.modify.optimize_now_param == OPTIMIZE_NOW_AREA) {
    //code for optimizing the area
    
    //sort so that x0 = xmin, x1 = xmax, y0 = ymin and y1 = ymax;
    if (y0 > y1) { temp = y0; y0 = y1; y1 = temp; }
    if (x0 > x1) { temp = x0; x0 = x1; x1 = temp; }
    
    
    //get max coordinates in world, to keep microscope in bounds
    //make sure box is in bounds, if not, set boundry to grid boundry
    if(x0 < 0) {x0 = 0;}
    if(y0 < 0) {y0 = 0;}
    if(x1 > plane->xInWorld (plane->numX())) {x1 = plane->xInWorld(plane->numX()-1);}
    if(y1 > plane->yInWorld (plane->numY())) {y1 = plane->yInWorld(plane->numY()-1);}
    
    //get the step size to take for Optimize Area
    double step_y;
    double old_step_size = microscope->state.modify.step_size;
    microscope->state.modify.step_size = 4;
    step_y = 4;
    
    //these are all the points in the region defined by the box
    for (y = y0; ; y+= step_y ) {
      if(y > y1) { y = y1; }
      
      //send microscope over area.
      microscope->DrawLine(x0,y,x1,y);
      microscope->TakeFeelStep(x1,y); //set the last point that we should expect
      end_x = x1; //the last point that should be coming in
      end_y = y;
      
      recieved_points = 0;
      //go through microscope mainloop and optimize over incoming points
      //keep going through loop until we recieve last point
      while(recieved_points == 0) {
	// a loop to give a little delay so that points can be recieved
	for(int o = 0; o <100000;o++){} 
	microscope->mainloop();
      }
      
      if (y == y1) {break;}
    }		
    microscope->state.modify.step_size = old_step_size;
  } else if (microscope->state.modify.optimize_now_param == OPTIMIZE_NOW_LINE) {
    // 45-45-90 triangle, longest side is hypotnuse
    // so anything shorter falls within this range
    
    microscope ->DrawLine(x0,y0,x1,y1);
    microscope->TakeFeelStep(x1, y1); //set the last point we should expect back
    end_x = x1; 
    end_y = y1;
    recieved_points = 0;
    while(recieved_points == 0) {
      // a loop to give a little delay so that points can be recieved
      for(int o = 0; o <100000;o++){} 
      microscope->mainloop();
    }
  } else {  // bad tool param spec, shouldn't be here
    return;
  }
  
  // following returns type double
  *x_max_coord = _max_value_x_coord;
  *y_max_coord = _max_value_y_coord;
  
  optimizing_now = 0; // turn off flag, no longer collect points to optimize over
}

//this updates the Dataset if we are in optimize_now mode, so the display
//is updated and we are optimizing over current data.
int optimize_now_ReceiveNewPoint (void * /*_mptr*/, const Point_results * p)
{
  if(microscope->state.modify.tool == OPTIMIZE_NOW){
    BCPlane* plane = dataset->inputGrid->getPlaneByName(dataset->heightPlaneName->string());
    
    if(optimizing_now == 1) {
      double value;
      
      if( (p->x() == end_x) && (p->y() == end_y) ) {
	recieved_points = 1;
      }
      //optimize over incoming points
      value = (p->getValueByPlaneName(dataset->heightPlaneName->string()))->value();
      if (value > _max_value) { 
	_max_value = value; 
	_max_value_x_coord = p->x();
	_max_value_y_coord = p->y();
      }
      
      if(microscope->state.modify.optimize_now_param == OPTIMIZE_NOW_AREA) {
	//update the display, but only if we are optimizing over an area
	double grid_x,grid_y;
	
	dataset->inputGrid->worldToGrid((double)(p->x()), (double)(p->y()), grid_x, grid_y);
	plane -> setValue(grid_x,grid_y,
			  (p->getValueByPlaneName(dataset->heightPlaneName->string()))->value());
	
	dataset->range_of_change.AddPoint(grid_x,grid_y); //marks the portion of the grid to be redrawn
      }
    }
  }
  return 0;
}
