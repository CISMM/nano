/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef NMM_QUEUE_MONITOR_H
#define NMM_QUEUE_MONITOR_H

#include <vrpn_Shared.h>
#include <vrpn_Connection.h>

class vrpn_RedundantReceiver;  // from vrpn_RedundantTransmission.h
class nmm_Microscope_Remote;  // from nmm_Microscope.h

/// @class nmm_QueueMonitor
/// A cute little object meant to sit between a vrpn_RedundantReceiver
/// and the nmm_Microscope_Remote.  If activated, it tries to smooth
/// out point result data coming back from topo so that playout doesn't
/// see any jitter.  Uses Don Stone's Queue Monitoring.  This will probably
/// have to be generalized to be time-sensitive when we hook it up to a
/// real microscope, but that requires more complex algorithmic design.

// Original design depended on nmm_Microscope, not _Remote, but since
// the Connection pointer got moved to nmb_Device, which isn't a base
// class of the Microscope, we have to use a circular dependency.  Yuck.
// (Moving the Connection pointer would be more reasonable IF _Remote
// instantiated Microscope instead of inheriting from it.)

#define QM_MAX_QUEUE 10

class nmm_QueueMonitor {

  public:

    nmm_QueueMonitor (nmm_Microscope_Remote *, vrpn_RedundantReceiver *);

    ~nmm_QueueMonitor (void);

    void mainloop (void);

    void enable (vrpn_bool);

    void registerResultDataHandler (vrpn_MESSAGEHANDLER handler,
                                    void * userdata);

    void setThreshold (vrpn_int32 base2value, vrpn_float64 decay);
      ///< Sets the threshold for a queue length of 2 and the
      ///< ratio threshold[n] / threshold[n+1];  defaults to 150 and 2.

    void write (char * filename);
    void clear (void);

  protected:

    nmm_Microscope_Remote * d_microscope;
      ///< Uses microscope to decode PointResultData messages enough
      ///< to extract the timestamp.

    vrpn_RedundantReceiver * d_redReceiver;
      ///< If the microscope is using FEC, the RedundantReceiver
      ///< will screen out duplicates for us.

    vrpn_bool d_isEnabled;
      ///< If false, all received messages are propagated to registered
      ///< handlers no later than the next call to mainloop();
      ///< if true, runs queue monitoring algorithm.
      ///< Defaults to false.

    int d_queueLength;
    vrpn_int32 d_queueCounter [QM_MAX_QUEUE];
    vrpn_int32 d_queueThreshold [QM_MAX_QUEUE];

    vrpnMsgCallbackEntry * d_callbacks;
    vrpn_LOGLIST * d_queueHead;
    vrpn_LOGLIST * d_queueTail;

    void enqueue (vrpn_HANDLERPARAM);
      ///< Adds the given message to the head of the queue.

    int dispatchQueueHead (void);
      ///< Returns -1 if a handler fails.

    void deleteQueueHead (void);

    void deleteQueue (void);

    static int VRPN_CALLBACK handle_resultData (void *, vrpn_HANDLERPARAM);

    vrpn_int32 d_numPolls;
      ///< Number of times mainloop was called.
    vrpn_int32 d_numDispatches;
      ///< Number of messages dispatched.  Under QM, equal to numPolls
      ///< minus numGaps.
    vrpn_int32 d_numDrops;
      ///< Number of messages dropped because of queue monitoring buffer
      ///< maintenance.
    vrpn_int32 d_numGaps;
      ///< Number of times mainloop was called without any message to
      ///< dispatch.
};


#endif  // NMM_QUEUE_MONITOR_H


