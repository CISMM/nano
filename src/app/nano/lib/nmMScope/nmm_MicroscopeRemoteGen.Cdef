OUTPUT_FILENAME nmm_MicroscopeRemoteGen.C
/*===3rdtech===
  Copyright (c) 2000 by 3rdTech, Inc.
  All Rights Reserved.

  This file may not be distributed without the permission of 
  3rdTech, Inc. 
  ===3rdtech===*/
#include "nmm_MicroscopeRemote.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#if !defined(_WIN32)
#include <sys/time.h> 
#include <unistd.h>  // for sleep()
#endif

#include <vrpn_FileConnection.h>	// for vrpn_File_Connection class
#include <vrpn_RedundantTransmission.h>

#include <Topo.h>
#include <Point.h>
#include <BCPlane.h>
#include <BCGrid.h>
#include <nmb_Dataset.h>
#include <nmb_Decoration.h>  // for addScrapeMark()
#include <Tcl_Linkvar.h>
#include <nmb_Time.h>
#include <nmb_Debug.h>
#include <nmb_Types.h>
#include <nmb_Line.h>

#include "stm_cmd.h"  // for SPM_POINT_RESULT_DATA and other types
#include "drift.h"
#include "splat.h"
#include "nmm_RelaxComp.h"
#include "nmm_Sample.h"

#include <vrpn_Connection.h>
#include <vrpn_FileConnection.h>	// for vrpn_File_Connection class

#include "error_display.h"

#if defined(_WIN32) && !defined(__CYGWIN__)
// bogus double to float conversion warning.
#pragma warning(disable:4244)
#endif

#define CHECK(a) if ((a) == -1) return -1

#ifdef MAX
  #undef MAX
#endif
#define MAX(a,b) ((a > b) ? (a) : (b))
#ifdef MIN
  #undef MIN
#endif
#define MIN(a,b) ((a < b) ? (a) : (b))
#define      NMB_NEAR(x0,x1)     (fabs(x0-x1) < 0.001)

#if (!defined(X) || !defined(Y) || !defined(Z1))
#define	X	(0)
#define	Y	(1)
#define	Z	(2)
#endif

#ifndef M_PI
#define M_PI 3.141592653589793238
#define M_PI_2		1.57079632679489661923
#endif

#define FC_MAX_HALFCYCLES (100)

USE_MSG_GROUP nmm_Monitor
USE_MSG_GROUP nmm_SPM_Report
USE_MSG_GROUP nmm_AFM_Report

CLASSNAME nmm_Microscope_Remote

// Microscope_Remote
//
// Communicate with a ThermoMicroscopes SPM, sending control messages
// and getting reponses. 
// Tom Hudson, September 1997
// Code mostly from microscape.c and animate.c

nmm_Microscope_Remote::nmm_Microscope_Remote
  (const AFMInitializationState & i,
   vrpn_Connection * connection) :
    nmb_SharedDevice_Remote (i.deviceName, connection),
    nmm_AFM_Report(connection), nmm_SPM_Report(connection),
    nmm_AFM_Control(connection), nmm_SPM_Control(connection),
    state(i),
    d_relax_comp(),
    d_dataset (NULL),
    d_decoration (NULL),
    d_tcl_script_dir (NULL),
    d_mod_window_initialized (vrpn_FALSE),
    d_mod_window_min_x (0),
    d_mod_window_min_y (0),
    d_mod_window_max_x (0),
    d_mod_window_max_y (0),
    d_mod_window_pad (10),
    lastResistanceReceived(-1),
    d_res_channel_added(vrpn_FALSE),
    d_pointDataHandlers (NULL),
    d_modifyModeHandlers (NULL),
    d_imageModeHandlers (NULL),
    d_scanlineModeHandlers (NULL),
    d_scanlineDataHandlers (NULL),
    d_feeltoHandlers (NULL),
    d_sampleAlgorithm (NULL),
    d_accumulatePointResults (vrpn_FALSE),
    d_incr_save(i.incr_save),
    d_first_PID_message_received(0),
    d_redundancy (new vrpn_RedundantTransmission (connection)),
    d_redReceiver (new vrpn_RedundantReceiver (connection)),
    d_monitor (NULL),
    d_tsList (new nmm_TimestampList ()),
    graphmod (new GraphMod())
{
  gettimeofday(&d_nowtime, &d_nowzone);
  d_next_time.tv_sec = 0L;
  d_next_time.tv_usec = 0L;

  // Turn on relaxation compensation, with k/t decay model. 
/*
  This is done when in RcvGotConnection2 so we shouldn't do it here
  if (state.doRelaxComp) {
      d_relax_comp.enable(nmm_RelaxComp::DECAY);
  }

  d_relax_comp.set_ignore_time_ms(state.stmRxTmin);
  d_relax_comp.set_separation_time_ms(state.stmRxTsep);
*/
  if (!d_connection) {
    return;
  }

  markTypeAsSafe(d_QueryScanRange_type);

  REGISTER nmm_SPM_Report;
  REGISTER nmm_AFM_Report;

  MSG_TYPE nmm_Monitor;
  // Must come after monitor message types are declared. 
  // XXX Disabled 11/01
//    d_monitor = new nmm_QueueMonitor (this, d_redReceiver);
  // TCH network adaptations Nov 2000
  // If we're doing queue monitoring, d_monitor catches it.
  // Underneath that, if we're doing redudnant transmission,
  // d_redReceiver catches it.

  // XXX Disabled 11/01 - when Topo had redundant sends disable, this code was
  // dropping point results; it only saw one in 3-7 results.
//    d_monitor->registerResultDataHandler
//                          (handle_PointResultData,
//                           this);
  // Normal handling of point results. 
  REGISTER nmm_Monitor;

  d_connection->register_handler(d_DroppedConnection_type,
                                 handle_DroppedConnection2,
                                   this);
  registerSynchHandler(handle_barrierSynch, this);
  registerGotMutexCallback(this, handle_GotMicroscopeControl);

  // TCH network adaptations Nov 2000
  // Set up the redundant transmission at the lowest level.
  nmb_Device::d_redundancy = d_redundancy;
}



ENDECODERS nmm_Monitor;


//static
int nmm_Microscope_Remote::handle_GotConnection2 (void * userdata,
                                      vrpn_HANDLERPARAM ) {
  nmm_Microscope_Remote * ms = (nmm_Microscope_Remote *) userdata;
  return (ms->RcvGotConnection2());
}

//static
int nmm_Microscope_Remote::handle_DroppedConnection2 (void * userdata,
                                      vrpn_HANDLERPARAM ) {
    nmm_Microscope_Remote * ms = (nmm_Microscope_Remote *) userdata;
    // Only display warning if we aren't quitting the program, and
    // if we are connected to a live AFM - no streamfiles!
    if ((!ms->d_dataset->done) && (ms->d_dataset->readMode() == READ_DEVICE)) {
      display_warning_dialog("Communication with ThermoMicroscopes AFM has stopped.\n"
                             "No more data will be collected until ThermoMicroscopes\n"
                             "software is re-started and communication is re-established.");
    }
    return 0;
}


 
HANDLERS nmm_Monitor;
HANDLERS nmm_SPM_Report;
HANDLERS nmm_AFM_Report;

/////////////////////////////////////////////////////////////////////////

/** 
    Called when we first get a connection to the AFM. Send all initialization
    messages needed.  
*/
int nmm_Microscope_Remote::RcvGotConnection2 (void) {

/*
  //printf("nmm_Microscope_Remote::RcvGotConnection2()\n");

  Can't do this until we have the mutex
  // Send off the relaxation parameters (if any)
  if (d_relax_comp.is_enabled()) {
      CHECK(SetRelax(state.stmRxTmin, state.stmRxTsep));
  } else {
      CHECK(SetRelax(0, 0));
  }

  Can't do this until we have the mutex
  // Start scanning the surface
  if (state.autoscan) {CHECK(ResumeFullScan())}

  Can't do this until we have the mutex
  // Tell AFM to scan forward and backward, or just forward.
  CHECK(SetScanStyle());
*/

  EnableUpdatableQueue(VRPN_TRUE);
  // Ask it for the scan range in x, y, and z.
  // When this is read back, Z will be used to set min_z and max_z.
  CHECK(QueryScanRange());

  return 0;
}

// Obsolete, only occurs in old stream files, because it doesn't
// include phase information.
RECEIVE_MSG InTappingMode {
    // Call newer rcv function, with default values for the parameters 
    // not covered by this message. 
    printf("WARNING: Old Tapping Mode message received, treating as Oscillating\n");
    RcvInOscillatingMode ( P, I, D, setpoint, amplitude, 100, 1, 1, 1, 0.0);
}

RECEIVE_MSG InOscillatingMode {
//    float32 P
//    float32 I
//    float32 D
//    float32 setpoint
//    float32 amplitude
//    float32 frequency
//    int32 input_gain 
//    int32 drive_attenuation
//    float32 phase
//    bool ampl_or_phase

  if (state.acquisitionMode == MODIFY) {
    printf("Matching AFM modify parameters (Oscillating).\n");
    printf("   S=%g  P=%g, I=%g, D=%g, A=%g, F=%g, G=%d, P/A %d, Atten=%d, Ph=%g\n",
           setpoint,P, I, D, amplitude, frequency, input_gain,
           ampl_or_phase, drive_attenuation, phase);
    if (state.modify.mode != TAPPING) state.modify.mode = TAPPING;
    state.modify.p_gain = P;
    state.modify.i_gain = I;
    state.modify.d_gain = D;
    state.modify.setpoint = setpoint;
    d_decoration->modSetpoint = setpoint;
    state.modify.amplitude = amplitude;
    state.modify.frequency = frequency;
    state.modify.input_gain = input_gain;
    state.modify.ampl_or_phase = ampl_or_phase;
    state.modify.drive_attenuation = drive_attenuation;
    state.modify.phase = phase;
  } else if (state.acquisitionMode == IMAGE){
    printf("Matching AFM image parameters (Oscillating).\n");
    printf("   S=%g  P=%g, I=%g, D=%g, A=%g, F=%g, G=%d, P/A %d, Atten=%d, Ph=%g\n",
           setpoint,P, I, D, amplitude, frequency, input_gain,
           ampl_or_phase, drive_attenuation, phase);
    if (state.image.mode != TAPPING) state.image.mode = TAPPING;
    state.image.p_gain = P;
    state.image.i_gain = I;
    state.image.d_gain = D;
    state.image.setpoint = setpoint;
    d_decoration->imageSetpoint = setpoint;
    state.image.amplitude = amplitude;
    state.image.frequency = frequency;
    state.image.input_gain = input_gain;
    state.image.ampl_or_phase = ampl_or_phase;
    state.image.drive_attenuation = drive_attenuation;
    state.image.phase = phase;
  } else if (state.acquisitionMode == SCANLINE){
    printf("Matching AFM scanline parameters (Oscillating).\n");
    printf("   S=%g  P=%g, I=%g, D=%g, A=%g, F=%g, G=%d, P/A %d, Atten=%d, Ph=%g\n",
           setpoint,P, I, D, amplitude, frequency, input_gain,
           ampl_or_phase, drive_attenuation, phase);
    if (state.scanline.mode != TAPPING) state.scanline.mode = TAPPING;
    state.scanline.p_gain = P;
    state.scanline.i_gain = I;
    state.scanline.d_gain = D;
    state.scanline.setpoint = setpoint;
    d_decoration->scanlineSetpoint = setpoint;
    state.scanline.amplitude = amplitude;
    state.scanline.frequency = frequency;
    state.scanline.input_gain = input_gain;
    state.scanline.ampl_or_phase = ampl_or_phase;
    state.scanline.drive_attenuation = drive_attenuation;
    state.scanline.phase = phase;
  }
  else {
   fprintf(stderr, "RcvInOscillatingMode: Error, in unknown mode\n");
  }
}

RECEIVE_MSG InContactMode {
//    float32 P
//    float32 I
//    float32 D
//    float32 setpoint
  if (state.acquisitionMode == MODIFY) {
    printf("Matching AFM modify parameters (Contact).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint,P, I, D);
    if (state.modify.mode != CONTACT)
      state.modify.mode = CONTACT;
    state.modify.p_gain = P;
    state.modify.i_gain = I;
    state.modify.d_gain = D;
    state.modify.setpoint = setpoint;
    d_decoration->modSetpoint = setpoint;
  } else if (state.acquisitionMode == IMAGE) {
    printf("Matching AFM image parameters (Contact).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint,P, I, D);
    if (state.image.mode != CONTACT)
      state.image.mode = CONTACT;
    state.image.p_gain = P;
    state.image.i_gain = I;
    state.image.d_gain = D;
    state.image.setpoint = setpoint;
    d_decoration->imageSetpoint = setpoint;
  } else if (state.acquisitionMode == SCANLINE){
    printf("Matching AFM scanline parameters (Contact).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint,P, I, D);
    if (state.scanline.mode != CONTACT)
      state.scanline.mode = CONTACT;
    state.scanline.p_gain = P;
    state.scanline.i_gain = I;
    state.scanline.d_gain = D;
    state.scanline.setpoint = setpoint;
    d_decoration->scanlineSetpoint = setpoint;
  }
  else {
    fprintf(stderr, "RcvInContactMode: Error, in unknown mode\n");
  }
}

RECEIVE_MSG InGuardedScanMode {
//    float32 P
//    float32 I
//    float32 D
//    float32 setpoint
//    float32 fNormalX
//    float32 fNormalY
//    float32 fNormalZ
//    float32 fPlaneD
//    float32 fGuardDepth
//    int32 nChannel
//    int32 bDirection

  // Update the guardedscan parameters (common to all modes)...
  state.guardedscan.fNormalX = fNormalX;
  state.guardedscan.fNormalY = fNormalY;
  state.guardedscan.fNormalZ = fNormalZ;
  state.guardedscan.fPlaneD = fPlaneD;
  state.guardedscan.fGuardDepth = fGuardDepth;
  state.guardedscan.nChannel = nChannel;
  state.guardedscan.bDirection = bDirection;

  if(state.acquisitionMode == MODIFY) {
    printf("Matching modify parameters (GuardedScan).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint, P, I, D);
    
	if(state.modify.mode != GUARDED_SCAN) {
      state.modify.mode = GUARDED_SCAN;
	}

    state.modify.p_gain = P;
    state.modify.i_gain = I;
    state.modify.d_gain = D;
    state.modify.setpoint = setpoint;
    d_decoration->modSetpoint = setpoint;

  } else if(state.acquisitionMode == IMAGE) {
    printf("Matching image parameters (GuardedScan).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint, P, I, D);

    if(state.image.mode != GUARDED_SCAN)
      state.image.mode = GUARDED_SCAN;

    state.image.p_gain = P;
    state.image.i_gain = I;
    state.image.d_gain = D;
    state.image.setpoint = setpoint;
    d_decoration->imageSetpoint = setpoint;

  } else if (state.acquisitionMode == SCANLINE){
    printf("Matching scanline parameters (GuardedScan).\n");
    printf("   S=%g  P=%g, I=%g, D=%g\n", setpoint, P, I, D);
    
	if(state.scanline.mode != GUARDED_SCAN)
      state.scanline.mode = GUARDED_SCAN;

    state.scanline.p_gain = P;
    state.scanline.i_gain = I;
    state.scanline.d_gain = D;
    state.scanline.setpoint = setpoint;

    d_decoration->scanlineSetpoint = setpoint;
  }
  else {
    fprintf(stderr, "RcvInGuardedScanMode: Error, in unknown mode\n");
  }
}

RECEIVE_MSG InDirectZControl {
//    float32 max_z_step
//    float32 max_xy_step
//    float32 min_setpoint
//    float32 max_setpoint
//    float32 max_lateral_force
//    float32 freespace_normal_force
//    float32 freespace_lat_force

  if (state.acquisitionMode == MODIFY) {
    printf("Matching AFM Direct Z Control parameters.\n");
    printf("   max_xy=%g  max_z=%g, min_setpoint=%g, max_setpoint=%g, max_lat_force %g\n", 
	   max_z_step, max_xy_step, min_setpoint, 
	   max_setpoint, max_lateral_force);
    printf("   free space normal force %g, free space lateral force %g\n",
	   freespace_normal_force, freespace_lat_force);
    if (state.modify.control != DIRECTZ)
       state.modify.control = DIRECTZ;
    state.modify.max_z_step = max_z_step;
    state.modify.max_xy_step = max_xy_step;
    state.modify.min_z_setpoint = min_setpoint;
    state.modify.max_z_setpoint = max_setpoint;
    state.modify.max_lat_setpoint = max_lateral_force;
    state.modify.freespace_normal_force = freespace_normal_force;
    state.modify.freespace_lat_force = freespace_lat_force;
  } else {
    fprintf(stderr, "Can't do Image/DirectZ control!!\n");
  }
}

RECEIVE_MSG InSewingStyle {
//    float32 setpoint
//    float32 bottomDelay
//    float32 topDelay
//    float32 pullBackDistance
//    float32 moveDistance
//    float32 moveRate
//    float32 maxDistanceToApproach
  if (state.acquisitionMode == MODIFY) {
    printf("Matching AFM modify parameters (Sewing).\n");
    if ((state.modify.mode != CONTACT) ||
        (state.modify.style != SEWING)) {
      state.modify.mode = CONTACT;
      state.modify.style = SEWING;
    }
    state.modify.setpoint = setpoint;
    d_decoration->modSetpoint = setpoint;
    // transmit in sec, store in ms
    state.modify.bot_delay = 1000.0 * bottomDelay;
    state.modify.top_delay = 1000.0 * topDelay;
    state.modify.z_pull = pullBackDistance;
    state.modify.punch_dist = moveDistance;
    // convert oppositely
    state.modify.speed = 0.001 * moveRate;
    state.modify.watchdog = maxDistanceToApproach;
  } else {
    fprintf(stderr, "Can't do Image/Sewing mode!\n");
  }
}

RECEIVE_MSG InSpectroscopyMode {
//    float32 setpoint
//    float32 startDelay
//    float32 zStart
//    float32 zEnd
//    float32 zPullback
//    float32 forceLimit
//    float32 distBetweenFC
//    int32 numPoints
//    int32 numHalfcycles
//    float32 sampleSpeed
//    float32 pullbackSpeed
//    float32 startSpeed
//    float32 feedbackSpeed
//    int32 averageNum
//    float32 sampleDelay
//    float32 pullbackDelay
//    float32 feedbackDelay

  if (state.acquisitionMode == MODIFY) {
    printf("Matching AFM modify parameters (Spectroscopy).\n");
    printf("stdel=%g, z_st=%g, z_end=%g, z_pull=%g, forcelim=%g, dist=%g\n",
           startDelay, zStart, zEnd, 
           zPullback, forceLimit, distBetweenFC);
    printf("numpoints=%d, numhalfcycles=%d, samp_spd=%g, "
           "pull_spd=%g, start_spd=%g\n",
           numPoints, numHalfcycles, sampleSpeed, 
           pullbackSpeed, startSpeed);
    printf("fdback_spd=%g, avg_num=%d, samp_del=%g, "
           "pull_del=%g, fdback_del=%g\n",
           feedbackSpeed, averageNum, sampleDelay, 
           pullbackDelay, feedbackDelay);
    if (state.modify.style != FORCECURVE) {
      state.modify.style = FORCECURVE;
    }
    state.modify.setpoint = setpoint;
    d_decoration->modSetpoint = setpoint;
    state.modify.fc_start_delay = startDelay;
    state.modify.fc_z_start = zStart;
    state.modify.fc_z_end = zEnd;
    state.modify.fc_z_pullback = zPullback;
    state.modify.fc_force_limit = forceLimit;
    state.modify.fc_movedist = distBetweenFC;
    state.modify.fc_num_points = numPoints;
    state.modify.fc_num_halfcycles = numHalfcycles;
    state.modify.fc_sample_speed = sampleSpeed;
    state.modify.fc_pullback_speed = pullbackSpeed;
    state.modify.fc_start_speed = startSpeed;
    state.modify.fc_feedback_speed = feedbackSpeed;
    state.modify.fc_avg_num = averageNum;
    state.modify.fc_sample_delay = sampleDelay;
    state.modify.fc_pullback_delay = pullbackDelay;
    state.modify.fc_feedback_delay = feedbackDelay;

    // This mod is a force curve - flag so we don't do callbacks with regular
    // point results.
    state.modify.this_mod_fc = VRPN_TRUE;
  } else {
    fprintf(stderr, "Can't do Image/SpectroscopyMode!\n");
  }
}

RECEIVE_MSG InModMode {
  state.acquisitionMode = MODIFY;
  //printf("In modify mode\n");

  d_mod_window_initialized = vrpn_FALSE;

  // I think this should only be done if we get the startingToRelax message.
  // Do relaxation compensation ( if it is enabled)
  //d_relax_comp.start_fix(_sec, _usec, state.lastZ);
  //printf("Compensating mod force %g\n", (float) state.modify.setpoint);

  if (state.doDriftComp)
    driftZDirty();

  doModifyModeCallbacks();
}

RECEIVE_MSG InImgMode {
  int previousAcquisitionMode = state.acquisitionMode;
  state.acquisitionMode = IMAGE;
  //printf("In image mode\n");

  if (state.doDriftComp)
    driftZDirty();

  // If we're only relaxing down, turn off the relaxation code
  d_relax_comp.stop_fix();
  // XXX Took out the ability to compensate for transition
  // into image mode from modify mode. 
  //if (!state.doRelaxUp) { ... }

  // We are no longer doing any modification, include a FC mod. 
  state.modify.this_mod_fc = VRPN_FALSE;
  
  doImageModeCallbacks();

  d_mod_window_pad = state.numLinesToJumpBack;

  // did we just come out of modifying and did we receive at least one 
  // point result?
  if ((previousAcquisitionMode == MODIFY) && d_mod_window_initialized) {
    // add padding to the region
    d_mod_window_min_x -= d_mod_window_pad;
    d_mod_window_min_y -= d_mod_window_pad;
    d_mod_window_max_x += d_mod_window_pad;
    d_mod_window_max_y += d_mod_window_pad;
    // check to make sure we don't exceed the image boundaries
    if (d_mod_window_min_x < 0) d_mod_window_min_x = 0;
    if (d_mod_window_min_y < 0) d_mod_window_min_y = 0;
    if (d_mod_window_max_x > d_dataset->inputGrid->numX() - 1)
        d_mod_window_max_x = d_dataset->inputGrid->numX() - 1;
    if (d_mod_window_max_y > d_dataset->inputGrid->numY() - 1)
        d_mod_window_max_y = d_dataset->inputGrid->numY() - 1;

    // this function would be nice but isn't implemented and probably
    // would require someone to write new Topometrix dsp code
    //SetScanWindow(d_mod_window_min_x, d_mod_window_min_y,
    //              d_mod_window_max_x, d_mod_window_max_y);

    // instead we do this:
    // XXX - this should depend on the direction of the scanning
    // (whether its up or down in the Y direction)
    // this is hard-coded for what works with typical Thermomicroscope setup

    // only jump if we want to resume scanning after modifications
    if( state.autoscan )
    {
      int lineNumber = d_dataset->inputGrid->numY()-1 - d_mod_window_max_y;
      //printf("jumping to line %d after modify\n", lineNumber);
      JumpToScanLine(lineNumber);
    }
  }
}

/* Helps with Thermo Image Analysis mode. When in this mode, most of 
 the widgets/dialogs that Nano needs to control the SPM aren't available
 So we avoid issuing any commands to Thermo, by disabling all device 
 controls. 
*/
RECEIVE_MSG SuspendCommands nmm_SPM_Report {
    if (d_dataset->readMode() != READ_DEVICE) return;
    state.commands_suspended = 1;
}

RECEIVE_MSG ResumeCommands {
    if (d_dataset->readMode() != READ_DEVICE) return;
    state.commands_suspended = 0;
}

RECEIVE_MSG StartingToRelax {
//    int32 sec
//    int32 usec
  if (state.doRelaxComp) {
    d_relax_comp.start_fix(sec, usec, state.lastZ);
    //printf("Beginning relaxation compensation at %ld:%ld\n", sec, usec);
  }

  if (state.doDriftComp)
    driftZDirty();
}

RECEIVE_MSG RelaxSet {
//    int32 minTime
//    int32 sepTime
  
  state.stmRxTmin = minTime;
  state.stmRxTsep = sepTime;

  if (minTime == 0 && sepTime == 0) {
      d_relax_comp.disable();
  } else {
      d_relax_comp.set_ignore_time_ms(minTime);
      d_relax_comp.set_separation_time_ms(sepTime);
      d_relax_comp.enable(nmm_RelaxComp::DECAY);
  }

//  printf("Relax ignore time set at %ld\n", minTime);
//  printf("Relax separation time set at %ld\n", sepTime);
}

RECEIVE_MSG WindowLineData {
//    int32 x
//    int32 y
//    int32 dx
//    int32 dy
//    int32 reports
//    int32 fields
//    int32 sec
//    int32 usec
//    float32 data [reports][fields]

  // Handle guarded scan differently...
  if(state.image.mode == GUARDED_SCAN) {
     BCPlane* pPlane = d_dataset->inputGrid->getPlaneByName(d_dataset->heightPlaneName->string());
  
     // Set the value...
     pPlane->setValue(x, y, data[0][0]);
     d_dataset->range_of_change.AddPoint(x, y);

     return;
  }

  if ((x < 0 || y < 0 || 
     (x+(reports-1)*dx) > (d_dataset->inputGrid->numX()-1) ||
     (y+(reports-1)*dy) > (d_dataset->inputGrid->numY()-1))) {
     display_fatal_error_dialog( "Internal: grid size (%d,%d) doesn't match"
           " reported data size (%dx%d). Exiting to avoid loss of data.", 
           d_dataset->inputGrid->numX(),
           d_dataset->inputGrid->numY(),
           reports, reports);
     return;
  }
  int i;
  // Store the data in the BCGrid/BCPlanes structure using
  // the scan_channel selector to put it in the right place. 
  for (i = 0; i < reports; i++) {
      if (state.data.scan_channels->Handle_report(x+ i*dx, y+ i*dy, sec, usec,
                                         data[i], fields)) {
          fprintf(stderr, "Error handling window line data\n");
          d_dataset->done = VRPN_TRUE;
          return;
      }
  }
  // Debug
  //printf("Handled window line data @row %d\n", y);

  // Change the background, since we are not touching or modifying
  d_decoration->mode = nmb_Decoration::IMAGE;

  // Incremental save of stream file
  // when user is not touching or modifying the sample.
  // XXX May cause slowdown on network drives. 
  if (d_incr_save) {
      d_connection->save_log_so_far();
  }

  double curr_x, curr_y, xf, yf;
  nmb_Image *image;
  
  // need to convert from a nmb_string to a string
  string o = string( (d_dataset->heightPlaneName->string()) );
  image = d_dataset->dataImages->getImageByName( o );

  // Draw the green "Scanline"
  // we want to stick the x,y and z values of every pixel along the
  // last received line to an array into the nmb_Decoration class so
  // that we can grab it later and draw the microscope's "scanline"

  // if the decoration's lineCount isn't the same as the current linecount
  // the microscope's surface size changed, so update the decoration's
  // linecount field
  if (d_decoration->scanLineCount != reports) {
      d_decoration->initScanline(reports);
  }

  BCPlane *plane = d_dataset->inputGrid->getPlaneByName(d_dataset->heightPlaneName->string() );
  if (plane == NULL) return;
  for (i = 0; i < reports; i++) {
    curr_x = x + i * dx;
    curr_y = y + i * dy;
    image->pixelToWorld( (double)curr_x, (double)curr_y, xf, yf);
    d_decoration->scan_line[i][0] = xf;
    d_decoration->scan_line[i][1] = yf;
    d_decoration->scan_line[i][2] = plane->scaledValue( curr_x, curr_y );
  }

  BCPlane *cp = d_dataset->inputGrid->getPlaneByName(d_dataset->colorPlaneName->string() );
  // Color map drift compensation. Keep track of the average data value of the
  // first scan line
  if (cp && (x == 0) && (y == cp->numY() -1)) {
      d_decoration->first_line_avg = d_dataset->getFirstLineAvg(cp);
  }
  return;
}

// point results for sharp, sweep, sewing (bottom and top) styles
RECEIVE_MSG PointResultData nmm_Monitor {
//    float32 x
//    float32 y
//    int32 sec
//    int32 usec
//    int32 reports
//    float32 data [reports]

  Point_value * z_value;
  float height;
  long i;

  if (spm_verbosity >= 1) {
    printf("nmm_Microscope_Remote::RcvResultData: Point result,"
	   " at (%g, %g), time %ld:%ld\n",
           x, y, sec, usec);
    printf("  Raw values:");
    for (i = 0; i < reports; i++) {
      printf(" %g", data[i]);
    }
    printf("\n");
  }

  timeval now, then, diff;
  if (d_tsList) {

    // TCH network adaptations Nov 2000
    // Add this to the application-level round-trip-timing record.

    // Timestamp in <sec, usec> should be the same timestamp we sent it with.
    gettimeofday(&now, NULL);
    then.tv_sec = sec;
    then.tv_usec = usec;
    diff = vrpn_TimevalDiff(now, then);
    d_tsList->add(now, diff);
  }

  // If scan is rotated, these points were taken at a different
  // spot than reported by Thermo software. Rotate to correct pos. 
  double xr,yr;
  rotateScanCoords(x, y, -(double)(state.image.scan_angle), &xr, &yr);

  // Make the report.  This has the side effect of updating
  // the inputPoint values and, if d_accumulatePointResults,
  // the incomingPointList.
  // HACK HACK HACK
  if (state.data.point_channels->Handle_report(xr, yr, sec, usec,
                                          (float *) data, reports,
                                          d_accumulatePointResults)) {
    fprintf(stderr, "Error handling SPM point result data\n");
    d_dataset->done = VRPN_TRUE;
    return;
  }

  if (spm_verbosity >= 1) {
    state.data.inputPoint->print("  Result:");
  }

  // Look up the value that corresponds to what is
  // mapped to the heightGrid, if we are getting that
  // data set.  This will make what we feel match what
  // we are looking at.
  z_value = state.data.inputPoint->getValueByPlaneName
                   (d_dataset->heightPlaneName->string());

  // Do relaxation compensation using the data set that is mapped to
  // height.
  if (z_value) {
    height = z_value->value();

    // If the height needs adjusting, do the adjustment, maybe using
    // a stored value. 
    // Otherwise fix_height will leave the height alone. 
    height = d_relax_comp.fix_height(sec, usec, height);
    z_value->setValue(height);

    //Store this height 
    state.lastZ = height;
  }

  //XXX Drift compensation taken out

  // splat this point onto the grid
  if (state.doSplat && !d_relax_comp.is_ignoring_points()) {
    ptSplat(&state.lost_changes, d_dataset->inputGrid, state.data.inputPoint);
  }

  // set the background color
  if (state.acquisitionMode == MODIFY) {
    // red if modifying
    d_decoration->mode = nmb_Decoration::MODIFY;
  } else {
    // yellow if just touching or moving to start position or relaxing
    d_decoration->mode = nmb_Decoration::FEEL;
  }

  if (state.readingStreamFile && !state.cannedLineVisible) {
    state.cannedLineVisible = VRPN_TRUE;
  }

  // if it's a modification result, display it
  if ((state.acquisitionMode == MODIFY || state.cannedLineVisible) &&
      (!d_relax_comp.is_ignoring_points())) {

    // if we haven't committed then we don't know that
    // state.modify.slow_line_prevPt and
    // state.modify.slow_line_currPt have been initialized at this point
    // (see code that gives us this assertion at interaction.c:drawLine(), 
    //  line 495)
    if (state.modify.tool == SLOW_LINE_3D &&
        state.modify.slow_line_committed) {

      if (state.modify.slow_line_prevPt != NULL &&
          state.modify.slow_line_currPt != NULL) {
          float z1 =  state.modify.slow_line_prevPt->z();
          float z2 =  state.modify.slow_line_currPt->z();
          if (z_value) {
            z_value->setValue( z2*(state.modify.slow_line_position_param) +
                z1*(1.0-state.modify.slow_line_position_param));
          }
      } else {
          fprintf(stderr, "RcvResultData: expected init_slow_line to be done (programmer error)\n");
      }
    }
// Causes the white tick marks/modify markers to show up.      
    DisplayModResult(state.data.inputPoint->x(),
                     state.data.inputPoint->y(),
                     0.0f, z_value, VRPN_TRUE);
  }
  if (state.modify.this_mod_fc == VRPN_FALSE)	{
//      if (ohmmeter !=NULL) {
        if (lastResistanceReceived >= 0) {
          // HACK - to get ohmmeter data in point results
          char *res_channel_name = "Resistance";
          char *res_channel_unit = "Ohms";
          if (!d_res_channel_added) {
              state.data.inputPoint->addNewValue(res_channel_name, res_channel_unit);
              d_res_channel_added = vrpn_TRUE;
          }

          Point_value *pv = state.data.inputPoint->getValueByName(res_channel_name);
          if (!pv) {
              fprintf(stderr, "nmm_Microscope_Remote::RcvResultData: "
                      "Unable to get ohmmeter channel\n");
          } else {
              pv->setValue(lastResistanceReceived);
          }
          // END HACK
        }
     
        // We need point results to feel what we are doing but we
        // don't want to store them in a modfile because its being used to
        // store the force curve, in separate ForceCurveResults function. 
        doPointDataCallbacks(state.data.inputPoint); 
     
  }

  if (z_value) {
    // Latency compensation
    // !z_value iff we're replaying a stream file and using a derived
    // plane for height.
    d_decoration->trueTipLocation[0] = xr;
    d_decoration->trueTipLocation[1] = yr;
    d_decoration->trueTipLocation[2] = z_value->value();
    d_decoration->trueTipLocation_changed = 1;
  }

  if (state.acquisitionMode == MODIFY) {
     double grid_x, grid_y;
     d_dataset->inputGrid->worldToGrid((double)xr, (double)yr, grid_x, grid_y);
     if (!d_mod_window_initialized) {
        d_mod_window_min_x = (vrpn_int32)grid_x;
        d_mod_window_min_y = (vrpn_int32)grid_y;
        d_mod_window_max_x = (vrpn_int32)grid_x;
        d_mod_window_max_y = (vrpn_int32)grid_y;
        d_mod_window_initialized = vrpn_TRUE;
     } else {
        if (grid_x < d_mod_window_min_x) 
            d_mod_window_min_x = (vrpn_int32)grid_x;
        else if (grid_x > d_mod_window_max_x) 
            d_mod_window_max_x = (vrpn_int32)grid_x;
        if (grid_y < d_mod_window_min_y) 
            d_mod_window_min_y = (vrpn_int32)grid_y;
        else if (grid_y > d_mod_window_max_y) 
            d_mod_window_max_y = (vrpn_int32)grid_y;
     }
  }
}

// Is the microscope scanning (1), or is the scan paused (0)? 
RECEIVE_MSG Scanning nmm_SPM_Report {
//    int32 on_off
    //printf("Scanning is %s\n", (on_off ? "on": "off"));
  // hack to avoid infinite loops
  if (state.scanning != on_off) {
      state.scanning.d_ignoreChange = VRPN_TRUE;
      state.scanning = on_off;
      state.scanning.d_ignoreChange = VRPN_FALSE;
  }
}

// XXX
// "Think about what this means when the data sets can be changed"
RECEIVE_MSG ScanRange {
//    float32 xmin
//    float32 ymin
//    float32 zmin
//    float32 xmax
//    float32 ymax
//    float32 zmax
  BCPlane * heightPlane;

  heightPlane = d_dataset->inputGrid->getPlaneByName
                   (d_dataset->heightPlaneName->string());

  printf("Max scan range (%g, %g) to (%g, %g)\n",
         xmin, ymin, xmax, ymax);
  printf("  Instrument Z range is %g to %g\n", zmin, zmax);

  if (xmin < xmax) {
      state.xMin = xmin;
      state.xMax = xmax;
  } else {
      state.xMin = xmax;
      state.xMax = xmin;
  }
  if (ymin < ymax) {
      state.yMin = ymin;
      state.yMax = ymax;
  } else {
      state.yMin = ymax;
      state.yMax = ymin;
  }
  if (zmin < zmax) {
      state.zMin = zmin;
      state.zMax = zmax;
      heightPlane->setMinAttainableValue(zmin);
      heightPlane->setMaxAttainableValue(zmax);
  } else {
      state.zMin = zmax;
      state.zMax = zmin;
      heightPlane->setMinAttainableValue(zmax);
      heightPlane->setMaxAttainableValue(zmin);
  }
  if (state.doDriftComp)
    driftZDirty();
}

RECEIVE_MSG ReportScanAngle {
//    float32 angle
  float newangle;

  // HACK to break loops
  newangle = Q_RAD_TO_DEG(angle);
  // Check within 0.01 degrees. 
  if (fabs(newangle - (float)(state.image.scan_angle)) > 0.01) {
    state.image.scan_angle = newangle;
    printf( "New scan angle = %g\n", (float)(state.image.scan_angle) );
  }

    //state.image.scan_angle = Q_RAD_TO_DEG(angle);
}


RECEIVE_MSG SetRegionClipped {
//    float32 xmin
//    float32 ymin
//    float32 xmax
//    float32 ymax

  BCPlane * heightPlane;

  heightPlane = d_dataset->inputGrid->getPlaneByName
                   (d_dataset->heightPlaneName->string());



  d_dataset->inputGrid->setMinX(xmin);
  d_dataset->inputGrid->setMinY(ymin);
  d_dataset->inputGrid->setMaxX(xmax);
  d_dataset->inputGrid->setMaxY(ymax);

  // fill in the grid with flat values
  d_dataset->inputGrid->clear();

//this seems obsolete..comment out test for now
 // if (state.regionFlag) {

    d_decoration->selectedRegionMinX = d_dataset->inputGrid->minX();
    d_decoration->selectedRegionMinY = d_dataset->inputGrid->minY();
    d_decoration->selectedRegionMaxX = d_dataset->inputGrid->maxX();
    d_decoration->selectedRegionMaxY = d_dataset->inputGrid->maxY();

//same here
//  } else { 
    state.regionFlag = VRPN_TRUE;
//  }

//    printf( "            nmm_Microscope_Remote::RcvSetRegionC minX %g minY %g maxX %g maxY %g\n", 
//            minX, minY, maxX, maxY );

  state.modify.region_diag =
     sqrt((d_dataset->inputGrid->maxX() - d_dataset->inputGrid->minX()) *
          (d_dataset->inputGrid->maxX() - d_dataset->inputGrid->minX()) +
          (d_dataset->inputGrid->maxY() - d_dataset->inputGrid->minY()) *
          (d_dataset->inputGrid->maxY() - d_dataset->inputGrid->minY()));

  // Initialize select widget values, so we can change
  // the region with Select mode.
  state.select_region_rad = 0.5 * (d_dataset->inputGrid->maxX() - d_dataset->inputGrid->minX());
  state.select_center_x = d_dataset->inputGrid->minX() + state.select_region_rad;
  state.select_center_y = d_dataset->inputGrid->minY() + state.select_region_rad;

  // initialize splatting filter
  mkSplat(d_dataset->inputGrid);
  if (state.doDriftComp)
    driftZDirty();

  state.current_epoch++;

  d_decoration->selectedRegion_changed = 1;

  if (heightPlane) {
      fprintf(stderr, "New region (%g, %g) to (%g, %g)\n",
         heightPlane->minX(), heightPlane->minY(),
         heightPlane->maxX(), heightPlane->maxY());

      d_decoration->red.doCallbacks(heightPlane->minX(), heightPlane->minY(),
                            heightPlane);
      d_decoration->green.doCallbacks(heightPlane->maxX(), heightPlane->minY(),
                            heightPlane);
      d_decoration->blue.doCallbacks(heightPlane->maxX(), heightPlane->maxY(),
                            heightPlane);
      d_decoration->aimLine.moveTo(heightPlane->minX(), heightPlane->maxY(),
                            heightPlane);
  }
  state.SetDefaultScanlineForRegion(d_dataset);

//fprintf(stderr, "region set complete\n");
}

RECEIVE_MSG ReportSlowScan {
//    int32 enabled
  if (state.slowScanEnabled != enabled) {
     state.slowScanEnabled = enabled;
  }
}

RECEIVE_MSG HelloMessage {
//    char nm [4]
//    char scopeName [SPM_NAME_LENGTH]
//    int32 majorVersion
//    int32 minorVersion
  if (strcmp(nm, "nM!")) {
    fprintf(stderr, "Bad magic in microscope hello\n");
    fprintf(stderr, "  (expected \"nM!\", got \"%s\"\n", nm);
    d_dataset->done = VRPN_TRUE;
    return;
  }
  printf("Hello from microscope %s, version %ld.%ld\n", scopeName, 
         majorVersion, minorVersion);
}

/*
void nmm_Microscope_Remote::RcvClientHello (const char * _magic, const char * _name,
                                 long _majorVersion,
                                 long _minorVersion) {
  if (strcmp(_magic, "nM!")) {
    fprintf(stderr, "Bad magic in client hello\n");
    fprintf(stderr, "  (expected \"nM!\", got \"%s\"\n", _magic);
    d_dataset->done = VRPN_TRUE;
    return;
  }
  printf("Streamfile written by %s, version %ld.%ld\n", _name, _majorVersion,
         _minorVersion);

}
*/

void nmm_Microscope_Remote::ClearScanChannels (void) {
  // we use the same messages for 2D and 1D scanning but there is the
  // possibility that in SCANLINE mode we cannot provide all the requested
  // channels so these are temporarily reduced
  if (state.acquisitionMode == SCANLINE) {
      ClearScanlineChannels();
  } else {
      if (state.data.scan_channels->Clear_channels()) {
          fprintf(stderr, "nmm_Microscope_Remote::RcvClearScanChannels:"
             " Can't clear scan datasets\n");
          d_dataset->done = VRPN_TRUE;
      }
  }
}

RECEIVE_MSG_HEADER ScanDataset {
//    int32 count
    count = count;
    ClearScanChannels();
}

RECEIVE_MSG_BODY ScanDataset {
//      char name [64]
//      char units [64]
//      float32 offset
//      float32 scale

  // we use the same messages for 2D and 1D scanning but there is the
  // possibility that in SCANLINE mode we cannot provide all the requested
  // channels so these are temporarily reduced
  if (state.acquisitionMode == SCANLINE) {
      RcvScanlineDataset(name, units, offset, scale);
  } else {
      fprintf(stderr, "  %s (%s), offset:  %g, scale:  %g\n",
              name, units, offset, scale);
      // HACK HACK HACK
      if (state.data.scan_channels->Add_channel( &(name[0]),
                                 &(units[0]), offset, scale)) {
          fprintf(stderr, "Can't add scan dataset\n");
          d_dataset->done = VRPN_TRUE;
      }
      nmb_Image *new_image = d_dataset->dataImages->getImageByName(name);
      new_image->setTopoFileInfo(*d_dataset->d_topoFile);

if(d_dataset->doInitHeight == true){
	d_dataset->heightPlaneName -> Set(d_dataset->initHeight);
	if(!strcmp(d_dataset->initHeight,d_dataset->heightPlaneName->string())){
		d_dataset->doInitHeight = false;
		}
	}
if(d_dataset->doInitColorPlane == true){
		d_dataset->colorPlaneName -> Set(d_dataset->initColorPlane);
		if(!strcmp(d_dataset->initColorPlane,d_dataset->colorPlaneName->string())){
			d_dataset->doInitColorPlane = false;
		}
	}
  }
}

void nmm_Microscope_Remote::ClearPointChannels (void) {
  if (state.data.point_channels->Clear_channels()) {
    fprintf(stderr, "nmm_Microscope_Remote::ClearPointChannels: Can't clear point datasets\n");
    d_dataset->done = VRPN_TRUE;
  } else {
      printf("New Point Datasets:\n");
  } 
}

RECEIVE_MSG_HEADER PointDataset {
//    int32 count
    count = count;
    ClearPointChannels();
}

RECEIVE_MSG_BODY PointDataset {
//      char name [64]
//      char units [64]
//      int32 numSamples
//      float32 offset
//      float32 scale

  printf("  %s (%s), count:  %ld, offset:  %g, scale:  %g\n",
         name, units, numSamples, offset, scale);

  if (state.data.point_channels->Add_channel(&(name[0]), &(units[0]), 
                                        offset, scale, numSamples)) {
    fprintf(stderr, "Can't add point dataset\n");
    d_dataset->done = VRPN_TRUE;
  }
}

RECEIVE_MSG PidParameters {
//    float32 P
//    float32 I
//    float32 D
  printf("Feedback:  P=%g, I=%g, D=%g\n", P, I, D);
  // We want the modify PID defaults to match the PID of image mode.
  // This is the initialization message sent by the AFM to tell us
  // what the PID are. So if this is the first time we get this
  // message, we will set the modify PID as well.
  if (state.acquisitionMode == MODIFY) {
    state.modify.p_gain = P;
    state.modify.i_gain = I;
    state.modify.d_gain = D;
    d_first_PID_message_received = 1;
  } else {
    state.image.p_gain = P;
    state.image.i_gain = I;
    state.image.d_gain = D;
    if (!d_first_PID_message_received ){
	d_first_PID_message_received = 1;
	// Set defaults for modify mode...
	state.modify.p_gain = P;
	state.modify.i_gain = I;
	state.modify.d_gain = D;
    }
  }
}

RECEIVE_MSG ScanrateParameter {
//    float32 rate
  if (state.acquisitionMode == MODIFY) {
	printf("Warning! Rate changed on topo in modify mode (ignoring)\n");
  } else {
	state.image.scan_rate_microns = rate / 1000.0;
	printf("New scan rate:  %g (nM/s)\n", rate);
  }
}

RECEIVE_MSG ReportGridSize {
//    int32 x
//    int32 y
  printf("Grid size from scanner:  %ldx%ld\n", x, y);
  if ((x != d_dataset->inputGrid->numX()) ||
      (y != d_dataset->inputGrid->numY())) {
//      fprintf(stderr, "Reset grid size from %d %d!\n",
//  	    d_dataset->inputGrid->numX(),
//  	    d_dataset->inputGrid->numY());
    if (d_dataset->setGridSize(x, y)) {
	// Non-zero indicates error!
	fprintf(stderr, "ERROR: unable to reset grid size\n");
	// If we don't set exit flag here, we just get a bus error later.
	d_dataset->done = VRPN_TRUE;
	// New strategy, so don't abruptly exit...
	//exit(-1); // we get a bus error before the next iteration, so exit now.
    }
    // update the user interface. 
    state.image.grid_resolution = x;
  }
  return ;
}

RECEIVE_MSG TopoFileHeader {
//    int32 length
//    char header [length]
    //printf("********** RCV'D TOPO FILE HEADER **********\n");
  if(length < 1536){
	printf("Unexpected Header length %ld need at least 1536\n", length);
  }else{
	d_dataset->d_topoFile->parseHeader(header, length);
  	//printf("********** Got Topometrix file header, length %ld\n", length);

        nmb_ImageList *images = d_dataset->dataImages;
        int i;
        for (i = 0; i < images->numImages(); i++) {
             images->getImage(i)->setTopoFileInfo(*d_dataset->d_topoFile);
        }

/*	handle=fopen("temp.tfr","w");
	if(handle == NULL){printf("ERROR WRITING TEMP.TFR");}
	fHdl=fileno(handle);
	write(fHdl,header,_length*sizeof(char));	
	fclose(handle);
*/
  }
}


RECEIVE_MSG_HEADER ForceCurveData {
//    float32 x
//    float32 y
//    int32 numSamples
//    int32 numHalfcycles
//    int32 sec
//    int32 usec

  Point_results pnt;

  // If scan is rotated, these points were taken at a different
  // spot than reported by Thermo software. Rotate to correct pos. 
  double xr,yr;
  rotateScanCoords(x, y, -(double)(state.image.scan_angle), &xr, &yr);

  if (spm_verbosity >= 1) {
    printf("Force Curve result, at (%g, %g), time %ld:%ld\n", xr, yr, sec, usec);
    //printf("  values:");
  }

  // Save fc data as we receive it. See Note for RECEIVE_MSG_BODY ForceCurveData below.
  if (state.fc_data == NULL) {
      state.fc_data = new vrpn_float32[numSamples*numHalfcycles];
  } else if (state.fc_numSamples != numSamples ||
             state.fc_numHalfcycles != numHalfcycles) {
      delete [] state.fc_data;
      state.fc_data = new vrpn_float32[numSamples*numHalfcycles];
  }
  if (state.fc_zValues == NULL) {
      state.fc_zValues = new vrpn_float32[numSamples];
  } else if (state.fc_numSamples != numSamples ) {
      delete [] state.fc_zValues;
      state.fc_zValues = new vrpn_float32[numSamples];
  }
  state.fc_x = xr;
  state.fc_y = yr;
  state.fc_numSamples = numSamples ;
  state.fc_samplesSoFar = 0;
  state.fc_numHalfcycles = numHalfcycles;
  state.fc_sec = sec;
  state.fc_usec = usec;
}

/** 
Receive data from a force-curve modification.

@Note Unfortunately we handle the data in an awkward way. We receive the
first point from each half cycle first, then the second point from each
half-cycle, but we want to process _all_ the points from the first half-cycle
first, so we must save all the data and process it at the end. We are forced
to do this to maintain compatibility with older stream files. XXX Fix if 
we change to new stream file version.
 */
RECEIVE_MSG_BODY ForceCurveData {
//      float32 z
//      float32 *d 
//      int32 numHalfcycles

  int i,j;
  // Put the data in the order we need it - all points for
  // first half-cycle first, then second half-cycle...
  for (i = 0; i < numHalfcycles; i++){
      state.fc_data[i*state.fc_numSamples + state.fc_samplesSoFar] = d[i];
  }
  state.fc_zValues[state.fc_samplesSoFar] = z;

  state.fc_samplesSoFar++;

  // This is the signal we've received all the data for this force curve,
  // so let's go ahead and process it. 
  if (state.fc_samplesSoFar == state.fc_numSamples) {
      // We want to reverse the order of "up" half cycles,
      // to match the order the data was actually collected, and
      // so the stripchart looks pretty (no connecting line between ends):
      // set a flag and reverse j
      bool up_cycle = false;
      for (i = 0; i < numHalfcycles; i++){
          for (j = (up_cycle ? state.fc_numSamples-1 : 0); 
               up_cycle ? (j>=0) : (j < state.fc_numSamples); 
               up_cycle ? j-- : j++) {

              // Make the report. This has the side effect of updating
              // the fc_inputPoint values. Hack.
              // Some weirdness here - we hard-code number of channels to 1
              // that means we are only collecting one kind of data, but
              // in a cycle. 
              if (state.data.forcecurve_channels->Handle_report(state.fc_x, 
                        state.fc_y, state.fc_zValues[j],
                        state.fc_sec, state.fc_usec, 
                        (float *)&(state.fc_data[i*state.fc_numSamples + j]), 1))
                  fprintf(stderr, "Error handling SPM force curve result data\n");
              doPointDataCallbacks(state.data.fc_inputPoint);
          }
          // draw tick mark in surface view/3D window.
          DisplayModResult(state.data.fc_inputPoint->x(),
                           state.data.fc_inputPoint->y(),
                           0.0f, NULL, VRPN_FALSE);
          
          up_cycle = !up_cycle;
      }
  }
}
// updates user interface
RECEIVE_MSG InScanlineMode {
//    int32 enabled   

  if (enabled){
    printf("In scanline mode\n");
    state.acquisitionMode = SCANLINE;
    doScanlineModeCallbacks();
    d_decoration->mode = nmb_Decoration::SCANLINE;
  }
  else {
    printf("exited scanline mode (proper scan region should be restored)\n");
    ImageMode();
  }
}

// updates user interface and data object
void nmm_Microscope_Remote::ClearScanlineChannels (void) {
  // update user interface:
  // update data storage
  if (state.data.currentScanlineData.clearChannels()){
    fprintf(stderr, "Can't clear scanline datasets\n");
    d_dataset->done = VRPN_TRUE;
  }
}

// updates user interface and data object
// Not received directly, but called from receive ScanDataset
void nmm_Microscope_Remote::RcvScanlineDataset(const char * _name, 
	const char * _units, float /*_offset*/, float /*_scale*/) {
//  printf("RcvScanlineDataset:  %s (%s), offset:  %g, scale:  %g\n",
//         _name, _units, _offset, _scale);

  if (state.data.currentScanlineData.addChannel(_name, _units)) {
    fprintf(stderr, "Can't add scanline dataset\n");
    d_dataset->done = VRPN_TRUE;
  }
}

// updates data object
RECEIVE_MSG ScanlineData {
//    float32 x
//    float32 y
//    float32 z
//    float32 angle
//    float32 slope
//    float32 width
//    int32 resolution
//    int32 feedback_enabled
//    int32 checking_forcelimit
//    float32 max_force_setting
//    float32 max_z_step
//    float32 max_xy_step
//    int32 sec
//    int32 usec
//    int32 num_channels
//    float32 data[resolution][num_channels]


 //XXX Rotate x,y with scan angle if this ever gets used.  
    if (state.scanline.continuous_rescan)
        AcquireScanline();
    else
        ExitScanlineMode();

    printf("got scanline data header\n");
    state.scanline.num_scanlines_to_receive--;

    if (state.scanline.num_scanlines_to_receive < 0) {
        fprintf(stderr, "Warning: received more scanlines than expected\n");
        state.scanline.num_scanlines_to_receive = 0;
    }

    if (state.data.currentScanlineData.num_values() != num_channels) {
        fprintf(stderr, "Error: scanline header has wrong number of channels:");
        fprintf(stderr, "  got %ld, expected %d\n",
                num_channels, state.data.currentScanlineData.num_values());
        return;
    }
    state.data.currentScanlineData.setLength(resolution);
    state.data.currentScanlineData.setTime(sec, usec);
    state.data.currentScanlineData.setEndpoints(x, y, z,
        x + sin(angle)*width, y + cos(angle)*width, z);


    if (state.scanline.feedback_enabled != feedback_enabled){
        fprintf(stderr, "Warning:");
        if (state.scanline.feedback_enabled) {
            fprintf(stderr, "Scanline: Feedback enabled in user interface"
                  "but disabled in currently received data\n");
        }
        else {
            fprintf(stderr, "Scanline: Feedback disabled in user interface"
                  "but enabled in currently received data\n");
        }
    }
	//state.scanline.feedback_enabled = _enable_feedback;
	state.scanline.forcelimit_enabled = checking_forcelimit;
	state.scanline.forcelimit = max_force_setting;
	state.scanline.max_z_step = max_z_step;
	state.scanline.max_xy_step = max_xy_step;

      // converts from DAC units to the appropriate units for each channel and
    float value;
    for (int i = 0; i < resolution; i++){
      for (int j = 0; j < num_channels; j++){
        value = state.data.scan_channels->DAC_to_units(j, data[i][j]);
        state.data.currentScanlineData.setValue(i, j, value);
      }
    }
      // calls callbacks to handle the new data
    doScanlineDataCallbacks(&(state.data.currentScanlineData));
    d_decoration->mode = nmb_Decoration::SCANLINE;
}


RECEIVE_MSG MaxSetpointExceeded {
   //TODO: When max setpoint is exceeded, add a plane force
   // so the user can feel, without looking for this printout:
   fprintf(stderr, "### Max Setpoint Exceeded in Direct Z Control ###\n");
}

RECEIVE_MSG BeginFeelTo {
//    float32 x
//    float32 y
  accumulatePointResults(VRPN_TRUE);
}

RECEIVE_MSG EndFeelTo {
//    float32 x
//    float32 y
//    int32 numx
//    int32 numy
//    float32 dx
//    float32 dy
//    float32 orientation
fprintf(stderr, "Completed feel to %.2f, %.2f.\n", x, y);
//XXX Rotate x,y with scan angle if they get used.  

  state.data.receivedAlgorithm.numx = numx;
  state.data.receivedAlgorithm.numy = numy;
  state.data.receivedAlgorithm.dx = dx;
  state.data.receivedAlgorithm.dy = dy;
  state.data.receivedAlgorithm.orientation = orientation;

  accumulatePointResults(VRPN_FALSE);
  swapPointList();
  doFeeltoCallbacks();
}


// static 
int nmm_Microscope_Remote::handle_barrierSynch (void *ud, 
                                  const nmb_SynchMessage *msg)
{
   nmm_Microscope_Remote *me = (nmm_Microscope_Remote *)ud;
//   printf("got barrier synch message for slow line(?)\n");

   if (me->d_dataset->readMode() != READ_DEVICE) {
       // we have nothing to do in this case (this message is only for
       // control over a live microscope)
       return 0;
   }
   if (strcmp(msg->comment, RELAX_MSG) == 0) {
      if ((me->state.modify.tool != SLOW_LINE)&&
	  (me->state.modify.tool != SLOW_LINE_3D)) {
         fprintf(stderr, "nmm_Microscope::handle_barrierSynch: Error, not in"
                         " slow line mode\n");
         return 0;
      }
      float x1 =  me->state.modify.slow_line_prevPt->x();
      float y1 =  me->state.modify.slow_line_prevPt->y();
      float x2 =  me->state.modify.slow_line_currPt->x();
      float y2 =  me->state.modify.slow_line_currPt->y();
      float z1;
      float z2;

      float x = x2*(me->state.modify.slow_line_position_param) +
              x1*(1.0-me->state.modify.slow_line_position_param);
      float y = y2*(me->state.modify.slow_line_position_param) +
              y1*(1.0-me->state.modify.slow_line_position_param);
      float z = 0;
      if (me->state.modify.tool == SLOW_LINE_3D) {
	z1 =  me->state.modify.slow_line_prevPt->z();
	z2 =  me->state.modify.slow_line_currPt->z();
	z = z2*(me->state.modify.slow_line_position_param) +
              z1*(1.0-me->state.modify.slow_line_position_param);	
      }

      // Set yaw so if we sweep it will be perpendicular to the slow-line path. 
      me->state.modify.yaw = atan2((y2 - y1), (x2 - x1)) - M_PI_2;

//      printf("sending first point request of slow line mode\n");
      me->state.modify.slow_line_relax_done = VRPN_TRUE;
      if (me->state.modify.tool == SLOW_LINE_3D) {
	me->TakeDirectZStep(x,y,z);
      }
      else {
	me->TakeModStep(x,y);
      }
   }
   return 0;
}

// static
void nmm_Microscope_Remote::handle_GotMicroscopeControl(void *ud,
    nmb_SharedDevice_Remote * /*dev*/)
{
  nmm_Microscope_Remote *me = (nmm_Microscope_Remote *)ud;
  
  //printf("nmm_Microscope_Remote::Got control, sending initialization\n");
  // Send off the relaxation parameters (if any)
  if (me->state.doRelaxComp) {
      me->SetRelax(me->state.stmRxTmin, me->state.stmRxTsep);
  } else {
      me->SetRelax(0, 0);
  }

  me->QueryScanRange();

  // Tell AFM to scan forward and backward, or just forward.
  me->SetScanStyle();

  // Start scanning the surface
  me->ResumeFullScan();

  return;
}


