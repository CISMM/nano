OUTPUT_FILENAME nmm_SimulatedMicroscope.C
//
#include "nmm_SimulatedMicroscope.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
//#include <unistd.h>
#include <sys/types.h>
#include <vrpn_Connection.h>
//
#if !defined(_WIN32) || defined(__CYGWIN__)
#include <sys/time.h>
#else
#include <vrpn_Shared.h>  // get timeval some other way
#endif
//
//
USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report
//
CLASSNAME nmm_SimulatedMicroscope
//
//
//name is the name of this device
nmm_SimulatedMicroscope::
nmm_SimulatedMicroscope(char *name, vrpn_Connection *connection, int scanResolution) : 
						nmb_SharedDevice_Server(name,connection), nmm_AFMSIM_Report(connection), 
						nmm_AFMSIMSERVER_Report(connection), d_connection(connection),
						d_scanResolution(scanResolution) {
	REGISTER nmm_AFMSIMSERVER_Report;
	d_name = new char[100];
	strcpy(d_name,name);  
	simulator_id = d_connection->register_sender("AFMSimulator");
	Remote_toSim_x = 1;
	Remote_toSim_y = 1;
	grid_size_rcv = false;

}
//
nmm_SimulatedMicroscope::
~nmm_SimulatedMicroscope(){
//
}
//
void nmm_SimulatedMicroscope::
change_machineName(char * newName){
	delete d_name;
	d_name = new char[100];
	strcpy(d_name,newName);
}
//
void nmm_SimulatedMicroscope::
encode_and_sendData(double ** Data, const int num_cols){
 int num_rows = num_cols;
 for(vrpn_int32 y = 0; y < num_rows; y++){
 //process each line separately
//
  vrpn_float32 ** line = new vrpn_float32*[num_cols];
//
  int i;
  for(i = 0; i < num_cols; ++i){
   line[i] = new vrpn_float32[1];
   line[i][0] = (vrpn_float32)(Data[y][i]);
  }
//
  //variables for encoding in msgbuf
  timeval time;
  gettimeofday(&time,NULL);
  int len;
  vrpn_int32 x,dx,dy,reports,fields;
  x = 0;
  dx = 1;//step across a row
  dy = 0;//but don't move in y
  reports = num_cols;
  fields = 1;//only height
//
  //encode msgbuf
  char * msgbuf = encode_WindowLineData(&len, x, y, dx, dy, reports, 
	  fields, time.tv_sec, time.tv_usec, line);
//  
  //send stuff
  int retval = -1;
  retval = Send((long)len, d_WindowLineData_type, msgbuf);
//
  //clean up before next iteration
  for(i = 0; i < num_cols; ++i){
   delete line[i];
  }
  delete line;
 }
}
//
int nmm_SimulatedMicroscope::
Send(long len, vrpn_int32 msg_type, char * buf){
	int retval = -1;//initial value denotes failure, do not continue if remains -1
	timeval now;	
	gettimeofday(&now, NULL);
	//pack message
	retval = d_connection->pack_message(len, now, msg_type, simulator_id,
				      buf, vrpn_CONNECTION_RELIABLE);
	if(retval != -1){
		d_connection->mainloop();//send message here
	}
	else{
		cout << "Message not sent" << endl;
	}
	//
	if ( buf ) {
		delete buf;
	}
	return retval;
}

double nmm_SimulatedMicroscope::
return_Simpixels_to_realworld_ratio_x(){
	double to_return = (double)(d_scanResolution/(d_xmax - d_xmin));
	if(to_return > 0)	return to_return;
	else				return -to_return;
}

double nmm_SimulatedMicroscope::
return_Simpixels_to_realworld_ratio_y(){
	double to_return = (double)(d_scanResolution/(d_ymax - d_ymin));
	if(to_return > 0)	return to_return;
	else				return -to_return;
}

HANDLERS nmm_AFMSIMSERVER_Report ; 

//get the grid size of the file in nano
RECEIVE_MSG ReportGridSize {
//  int32 x
//  int32 y
	if(x != d_scanResolution){
		Remote_toSim_x = double(x)/double(d_scanResolution);
	}
	if(y != d_scanResolution){
		Remote_toSim_y = double(y)/double(d_scanResolution);
	}
	cout << endl << "Ratio remote to simulator grid sizes:\t" << Remote_toSim_x << ", " << Remote_toSim_y << endl;
	Sim_to_World_x = return_Simpixels_to_realworld_ratio_x();
	Sim_to_World_y = return_Simpixels_to_realworld_ratio_y();
	cout << "Ratio simulator pixels to real world distance:\t" << Sim_to_World_x << ", " << Sim_to_World_y << endl;
	grid_size_rcv = true;

}

//get the real world coords from the file in nano
RECEIVE_MSG ScanRange {
//  float32 xmin
//  float32 ymin
//  float32 zmin
//  float32 xmax
//  float32 ymax
//  float32 zmax

	d_xmin = xmin;
	d_xmax = xmax;
	d_ymin = ymin;
	d_ymax = ymax;
	d_zmin = zmin;
	d_zmax = zmax;
	cout << endl << "ScanRange:\t" << xmin << "," << xmax << "\t" << ymin << "," << ymax << endl;
}

RECEIVE_MSG TriangleScale {
//  float32 scale

    tri_scale = (float)scale;

}

RECEIVE_MSG Triangle {
//  float32 _1v1
//  float32 _1v2
//  float32 _1v3
//  float32 _2v1
//  float32 _2v2
//  float32 _2v3
//  float32 _3v1
//  float32 _3v2
//  float32 _3v3

	triangleRcv = true;
	Node * temp = new Node();//can fill in Node object now
	temp->v1_1 = (float)_1v1;
	temp->v1_2 = (float)_1v2;
	temp->v1_3 = (float)_1v3;
	temp->v2_1 = (float)_2v1;
	temp->v2_2 = (float)_2v2;
	temp->v2_3 = (float)_2v3;
	temp->v3_1 = (float)_3v1;
	temp->v3_2 = (float)_3v2;
	temp->v3_3 = (float)_3v3;//fill in
	temp->next = head;//put in front of list
	head = temp;//call temp by head

}
