OUTPUT_FILENAME nmm_SimulatedMicroscope.C
//
#include "nmm_SimulatedMicroscope.h"
#include <stdlib.h>
#include <stdio.h>
#include <iostream.h>
#include <string.h>
//#include <unistd.h>
#include <sys/types.h>
#include <vrpn_Connection.h>
//
#if !defined(_WIN32) || defined(__CYGWIN__)
#include <sys/time.h>
#else
#include <vrpn_Shared.h>  // get timeval some other way
#endif
//
//
USE_MSG_GROUP nmm_AFMSIM_Report
USE_MSG_GROUP nmm_AFMSIMSERVER_Report
//
CLASSNAME nmm_SimulatedMicroscope
//
//
//name is the name of this device
nmm_SimulatedMicroscope::
nmm_SimulatedMicroscope(char *name, vrpn_Connection *connection, int xResolution,int yResolution) : 
						nmb_SharedDevice_Server(name,connection), nmm_AFMSIM_Report(connection), 
						nmm_AFMSIMSERVER_Report(connection), d_connection(connection),
						d_xscanResolution(xResolution){
	REGISTER nmm_AFMSIMSERVER_Report;	
	d_name = new char[64];
	strcpy(d_name,name);  
	simulator_id = d_connection->register_sender(d_name);
	Remote_toSim_x = 1;
	Remote_toSim_y = 1;
	grid_size_rcv = false;
	scaleRcv = false;
	rotRcv = false;
	transRcv = false;
	scanRcv = false;
	if(yResolution != 0)	d_yscanResolution = yResolution;
	else					d_yscanResolution = xResolution;
	last_filled_y = -1;		//initialize to -1 so that in FillDataArray, last_filled_y + 1 = 0
}
//
nmm_SimulatedMicroscope::
~nmm_SimulatedMicroscope(){
//
}
//
void nmm_SimulatedMicroscope::
change_machineName(char * newName){
	delete d_name;
	d_name = new char[64];
	strcpy(d_name,newName);
}
//
void nmm_SimulatedMicroscope::
encode_and_sendData(double ** Data, const int num_cols){
 int num_rows = num_cols;
 for(vrpn_int32 y = 0; y < num_rows; y++){
 //process each line separately
//
  vrpn_float32 ** line = new vrpn_float32*[num_cols];
//
  int i;
  for(i = 0; i < num_cols; ++i){
   line[i] = new vrpn_float32[1];
   line[i][0] = (vrpn_float32)(Data[y][i]);
  }
//
  //variables for encoding in msgbuf
  timeval time;
  gettimeofday(&time,NULL);
  int len;
  vrpn_int32 x,dx,dy,reports,fields;
  x = 0;
  dx = 1;//step across a row
  dy = 0;//but don't move in y
  reports = num_cols;
  fields = 1;//only height
//
  //encode msgbuf
  char * msgbuf = encode_WindowLineData(&len, x, y, dx, dy, reports, 
	  fields, time.tv_sec, time.tv_usec, line);
//  
  //send stuff
  int retval = -1;
  //cout << "sending line " << y << endl;
  retval = Send((long)len, d_WindowLineData_type, msgbuf);
//
  //clean up before next iteration
  for(i = 0; i < num_cols; ++i){
   delete line[i];
  }
  delete line;
 }
}
//
void nmm_SimulatedMicroscope::
encode_and_sendDeviceName(){
  //variables for encoding in msgbuf
  int len = 0;
  //
  char * msgbuf = encode_DeviceName(&len,d_name);//encode msgbuf
  int retval = -1;
  if((retval = Send((long)len, d_DeviceName_type, msgbuf)) == -1){
	cout << "problem sending DeviceName" << endl;
  }//send stuff  
}
//
int nmm_SimulatedMicroscope::
Send(long len, vrpn_int32 msg_type, char * buf){
	int retval = -1;//initial value denotes failure, do not continue if remains -1
	timeval now;	
	gettimeofday(&now, NULL);
	//pack message
	retval = d_connection->pack_message(len, now, msg_type, simulator_id,
				      buf, vrpn_CONNECTION_RELIABLE);
	if(retval != -1){
		d_connection->mainloop();//send message here
	}
	else{
		cout << "Message not sent" << endl;
	}
	//
	if ( buf ) {
		delete buf;
	}
	return retval;
}

double nmm_SimulatedMicroscope::
return_Simpixels_to_realworld_ratio_x(){
	double to_return = (double)(d_xscanResolution/(d_xmax - d_xmin));
	if(to_return > 0)	return to_return;
	else				return -to_return;
}

double nmm_SimulatedMicroscope::
return_Simpixels_to_realworld_ratio_y(){
	double to_return = (double)(d_yscanResolution/(d_ymax - d_ymin));
	if(to_return > 0)	return to_return;
	else				return -to_return;
}

float nmm_SimulatedMicroscope::
get_xrange(){
	return (d_xmax - d_xmin);
}

float nmm_SimulatedMicroscope::
get_yrange(){
	return (d_xmax - d_xmin);
}

float nmm_SimulatedMicroscope::
get_zrange(){
    //cout << "range is: " << (d_zmax - d_zmin) << endl;
	return (d_zmax - d_zmin);
}

float nmm_SimulatedMicroscope::
get_xsize(){
	return xsize;
}

float nmm_SimulatedMicroscope::
get_ysize(){
	return ysize;
}

float nmm_SimulatedMicroscope::
get_zoffset(){
	return d_zmin;
}

bool nmm_SimulatedMicroscope::
FillDataArray(double*** ArrayToFill,int &xResolution,int &yResolution, float zscale){
	xResolution = xsize;
	yResolution = ysize;
	//create new rows only if they have not yet been created
	if((*ArrayToFill) == NULL){
	  (*ArrayToFill) = new double*[ysize];
	  for(int y=0; y < ysize; y++ ){
		  (*ArrayToFill)[y] = new double[xsize];
		  //initialize to NULL so can check and see if we have to create the row array later
		  //(only want to do this once too...)
	  }
	}

	for(int y = last_filled_y + 1; y <= last_rcv_y; ++y){
		for(int x=0; x < xsize; x++ ){
			(*ArrayToFill)[y][x] = ( DataArray[y][x] - get_zoffset() )* zscale;
			//scale values so within the range used by ArrayToFill
		}
		delete [] DataArray[y];
		DataArray[y] = NULL;
		//cleanup for next go-round
	}

	last_filled_y = last_rcv_y;//highest number row filled now

	if((*ArrayToFill) != NULL)		return true;//true that array filled
	else						return false;//array not filled

}

HANDLERS nmm_AFMSIMSERVER_Report ; 

//
RECEIVE_MSG OrigScanLineData{
//  int32 x 
//  int32 y 
//  int32 dx 
//  int32 dy 
//  int32 reports
//  int32 fields
//  int32 sec 
//  int32 usec 
//  float32 data [reports][fields]

	cout << "receiving window line data for line " << y << endl;
	//check to see that the data is not greater than the number of samples the input grid contains/can hold
	//check is whether initial (x), which is counted as zero, + (reports - 1), the number
	//of data points following the Oth data point sent, is greater than the number of 
	//points per row; analogous situation for y
	int datain_xmax = x+(reports-1)*dx;
	int datain_ymax = y+(reports-1)*dy;
	if (x < 0 || y < 0 || datain_xmax > xsize || datain_ymax > ysize) {
		cerr << "Internal: grid size doesn't match reported data size."
			 << "Exiting to avoid loss of data." << endl; 
		return;
	}

	if(DataArray[y] == NULL || reports != d_xscanResolution){
		DataArray[y] = new double[reports];//DataArray[y] is a double*
		//for each new y that is sent, create a new array to be filled in
	}

	for (int i = 0; i < reports; i++) {
		int new_x = x + i*dx;
		int new_y = y + i*dy;

		DataArray[y][i] = (double)(data[new_x][0]);//fill in
	}


	last_rcv_y = y;
	gettimeofday(&lastfilltime,NULL);//current time
	scanRcv = true;

  	return;
}


//get the grid size of the file in nano
RECEIVE_MSG ReportGridSize {
//  int32 x
//  int32 y
	xsize = x;
	ysize = y;

	if(strcmp(d_name,"Eroder")==0){
		if(x != d_xscanResolution){
			d_xscanResolution = x;
		}
		if(y != d_yscanResolution){
			d_yscanResolution = y;
		}
	}

	Sim_to_World_x = return_Simpixels_to_realworld_ratio_x();
	Sim_to_World_y = return_Simpixels_to_realworld_ratio_y();
	cout << "Ratio simulator pixels to real world distance:\t" << Sim_to_World_x << ", " << Sim_to_World_y << endl;
	grid_size_rcv = true;

	DataArray = new double*[xsize];
	for(int i = 0;i<d_yscanResolution;++i){
		DataArray[i] = NULL;//initialize to NULL
	}

}

//get the real world coords from the file in nano
RECEIVE_MSG ScanRange {
//  float32 xmin
//  float32 ymin
//  float32 zmin
//  float32 xmax
//  float32 ymax
//  float32 zmax

	d_xmin = xmin;
	d_xmax = xmax;
	d_ymin = ymin;
	d_ymax = ymax;
	d_zmin = zmin;
	d_zmax = zmax;
	cout << endl << "ScanRange:\t" << xmin << "," << xmax << "\t" << ymin << "," << ymax << endl << flush;

	encode_and_sendDeviceName();//when connection established, ScanRange sent by remote side, and
								//safe to send device name
}

RECEIVE_MSG Scale {
//  float32 scale

    _scale = (float)scale;
	
	scaleRcv = true;

}

RECEIVE_MSG Trans {
//  float32 x,y,z

    trans_x = (float)x;
	trans_y = (float)y;
	trans_z = (float)z;
	
	transRcv = true;

}

RECEIVE_MSG Rot {
//  float32 z
//  float32 y
//  float32 x

	rot_x = (float)x;
	rot_y = (float)y;
	rot_z = (float)z;

	rotRcv = true;

}

RECEIVE_MSG Triangle {
//  float32 _1v1
//  float32 _1v2
//  float32 _1v3
//  float32 _2v1
//  float32 _2v2
//  float32 _2v3
//  float32 _3v1
//  float32 _3v2
//  float32 _3v3

	triangleRcv = true;
	Node * temp = new Node();//can fill in Node object now
	temp->v1_1 = (float)_1v1;
	temp->v1_2 = (float)_1v2;
	temp->v1_3 = (float)_1v3;
	temp->v2_1 = (float)_2v1;
	temp->v2_2 = (float)_2v2;
	temp->v2_3 = (float)_2v3;
	temp->v3_1 = (float)_3v1;
	temp->v3_2 = (float)_3v2;
	temp->v3_3 = (float)_3v3;//fill in
	temp->next = head;//put in front of list
	head = temp;//call temp by head

}


RECEIVE_MSG Cylinder {
//	vrpn_float32 x
//	vrpn_float32 y
//	vrpn_float32 z
//	vrpn_float32 altitude
//	vrpn_float32 azimuth
//	vrpn_float32 length
//	vrpn_float32 radius

	cylRcv = true;
	CylNode * temp = new CylNode();

	temp->x = x;
	temp->y = y;
	temp->z = z;
	temp->altitude = altitude;
	temp->azimuth = azimuth;
	temp->length = length;
	temp->radius = radius;

	temp->next = cylHead;//put in front of list
	cylHead = temp;//call temp by head
}


