/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef NMUI_SURFACE_FEATURES_H
#define NMUI_SURFACE_FEATURES_H

#include <vrpn_Types.h>  // for vrpn_bool

class nmb_Dataset;  // from <nmb_Dataset.h>
class nmm_Microscope_Remote;  // from <nmm_MicroscopeRemote.h>
class nmui_HSCanned;  // from "nmui_HapticSurface.h"

// Second pass design:
//   Put Point, Grid onto strategy classes & run them behind the scenes.
//   Make nmui_SurfaceFeatures concrete and instantiate it.
// * Still need a better way to instantiate & select strategy classes.
// * We need buzzingEnabled(), bumpsEnabled() because the "magic numbers"
//   that get thrown at them may include an offset as well as a scale,
//   so passing 0 back from scaledPointBuzzAmplitude() *doesn't* guarantee
//   that buzzing will be off if magicBuzzAmplitude() is obnoxious enough.


class nmui_SurfaceFeatureStrategy {

  public:

    nmui_SurfaceFeatureStrategy (void);
    virtual ~nmui_SurfaceFeatureStrategy (void) = 0;

    // ACCESSORS

    virtual vrpn_bool buzzingEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;
      ///< Default implementation returns vrpn_false;
    virtual vrpn_bool bumpsEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;
      ///< Default implementation returns vrpn_false;

    // MANIPULATORS
    // These could be declared const, but I don't want to constrain
    // future implementations.

    virtual double pointAdhesionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns 0.
    virtual double scaledPointBuzzAmplitude (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns 0.
    virtual double scaledPointBumpSizeValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns 0.
    virtual double pointComplianceValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns the conventional default/error value:
      ///< max(0.0, Arm_knobs[FORCE_KNOB]).
    virtual double pointFrictionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns the conventional default/error value:
      ///< max(0.0, Arm_knobs[FRICTION_KNOB]).

    virtual double magicBuzzAmplitude (double) = 0;
      ///< Scale bump wavelength by context-dependent magic numbers.
    virtual double magicBumpSize (double) = 0;
      ///< Scale bump wavelength by context-dependent magic numbers.

    virtual double dynamicFrictionKspring (double staticFrictionKspring, nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Default implementation returns 0.5 * kSpring.



};


class nmui_SurfaceFeatures {

  public:

    nmui_SurfaceFeatures (void);
    virtual ~nmui_SurfaceFeatures (void);

    // ACCESSORS




    // MANIPULATORS

    void update (nmb_Dataset *, nmm_Microscope_Remote * scope);

    void setSurfaceFeatureStrategy (nmui_SurfaceFeatureStrategy *);

    void useLinearBuzzing (vrpn_bool);
    void useLinearBumps (vrpn_bool);
    void useLinearFriction (vrpn_bool);


    void setBuzzFrequency (double = 115.0);
      ///< Defaults to 115.0 Hz.
    void setComplianceGain (double = 1.3);
      ///< Compensate for nonunity gain in the Phantom server -
      ///< defaults to 1.3.
    void setAdhesionConstant (double = 12000.0);
      ///< Defaults to 12,000.

  protected:

    void specifyAdhesion (nmb_Dataset *, nmm_Microscope_Remote * scope);
    void specifyBuzzAmplitude (nmb_Dataset *, nmm_Microscope_Remote * scope);
    void specifyBumpSize (nmb_Dataset *, nmm_Microscope_Remote * scope);
    void specifyCompliance (nmb_Dataset *, nmm_Microscope_Remote * scope);
    void specifyFriction (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Takes the local value of friction, scales it with respect
      ///< to friction_slider, linearizes it if necessary, and passes
      ///< the result to setStaticFriction() and setDynamicFriction().

    virtual void setFriction (double kS, double dynamic_kS);
      ///< Default implementation calls forceDevice->setSurfaceFstatic(kS)
      ///< and setSurfaceFdynamic(dynamic_kS).
    void setSurfaceTexture (double wavelength);
      ///< Calls forceDevice->setSurfaceTextureWavelength(wavelength)
      ///< and setSurfaceTextureAmplitude(0.1 * wavelength).
    void setBuzzing (double amp);
      ///< Calls forceDevice->setSurfaceBuzzFrequency(d_buzzFrequency)
      ///< and setSurfaceBuzzAmplitude(amp).
    void setCompliance (double kS);
      ///< Calls forceDevice->setSurfaceKspring(kS).


    vrpn_bool d_firstExecution;
    vrpn_bool d_useLinearBuzzing;
    vrpn_bool d_useLinearBumps;
    vrpn_bool d_useLinearFriction;

    double d_adhesionConstant;
    double d_buzzFrequency;
    double d_complianceGain;

    nmui_SurfaceFeatureStrategy * d_strategy;

};

/// @class nmui_PointFeatures
/// Used by touch_live_to_plane_fit_to_line and anything else that wants
/// to make the surface feel like it does at a point returned by
/// the microscope.

class nmui_PointFeatures : public nmui_SurfaceFeatureStrategy {

  public:

    nmui_PointFeatures ();
    virtual ~nmui_PointFeatures (void);

    // ACCESSORS

    virtual vrpn_bool buzzingEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;
    virtual vrpn_bool bumpsEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;

    // MANIPULATORS

    virtual double pointAdhesionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up the adhesion in microscope->state.data.inputPoint.
    virtual double scaledPointBuzzAmplitude (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up the buzz size in microscope->state.data.inputPoint
      ///< and scales by (buzz_slider_max - buzz_slider_min).
    virtual double scaledPointBumpSizeValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up the bump size in microscope->state.data.inputPoint
      ///< and scales by (bump_slider_max - bump_slider_min).
    virtual double pointFrictionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up the friction value in microscope->state.data.inputPoint.



    virtual double magicBuzzAmplitude (double amp);
      ///< Returns 0.002 * amp.
    virtual double magicBumpSize (double wavelength);
      ///< Returns 0.01 * wavelength to scale from centimeters to meters.


    virtual double dynamicFrictionKspring (double kS, nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Dynamic friction at points on the grid is fixed to the value of
      ///< max(0.0, Arm_knobs[FRICTION_KNOB]), so we ignore kS and use
      ///< nmui_SurfaceFeatureStrategy::pointFrictionValue() instead.

};



/// @class nmui_GridFeatures
/// Used by touch_canned_from_plane and anything else that wants
/// to make the surface feel like data in the grid.

class nmui_GridFeatures : public nmui_SurfaceFeatureStrategy {

  public:

    nmui_GridFeatures (nmui_HSCanned * surface );
    virtual ~nmui_GridFeatures (void);

    // ACCESSORS

    virtual vrpn_bool buzzingEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;
    virtual vrpn_bool bumpsEnabled (nmb_Dataset *, nmm_Microscope_Remote *) const;

    // MANIPULATORS

    virtual double pointAdhesionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up plane->value(x, y).
    virtual double scaledPointBumpSizeValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up plane->value(x, y) and scales by
      ///< (plane->maxValue() - plane->minValue()).
    virtual double scaledPointBuzzAmplitude (nmb_Dataset *, nmm_Microscope_Remote * scope);
    virtual double pointComplianceValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up plane->value(x, y).
    virtual double pointFrictionValue (nmb_Dataset *, nmm_Microscope_Remote * scope);
      ///< Looks up plane->value(x, y).


    virtual double magicBuzzAmplitude (double amp);
      ///< Returns 0.0001 + .0009 * amp.
    virtual double magicBumpSize (double wavelength);
      ///< Returns 0.0004 + 0.004 * wavelength - old magic numbers.


    nmui_HSCanned * d_hapticSurface;

};


#endif  // NMUI_SURFACE_FEATURES_H






