/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "nmui_Component.h"

#include <string.h>  // for strncpy(), strcat(), strlen()
#include <stdio.h>  // for sprintf()

#include <vrpn_Connection.h>

#include <Tcl_Linkvar.h>
#include <Tcl_Netvar.h>


/* static */
const char* nmui_Component::
d_syncRequest_type_string = "nmui Component request sync";


/* static */
const char* nmui_Component::
d_syncComplete_type_string = "nmui Component sync complete";

// sync:  all sync traffic is SENT over d_connection
// (collaboratingPeerServerConnection in microscape.c) and received over
// d_peer (collaboratingPeerRemoteConnection in microscape.c).


nmui_Component::nmui_Component (char name [30]) :
                    //TclNet_int ** ilist, int numI,
                    //TclNet_float ** flist, int numF,
                    //TclNet_string ** stringlist, int numstring) :
    d_maintain (VRPN_FALSE),
    //d_numInts (numI),
    //d_numFloats (numF),
    //d_numStrings (numstring),
    d_numVars (0),
    d_numComponents (0),
    d_synchronizedTo (0),
    d_numPeers (0),
    d_isLockedRemotely (VRPN_FALSE),
    d_holdsRemoteLocks (VRPN_FALSE),
    d_connection (NULL),
    d_myId (-1),
    d_syncRequest_type (-1),
    d_syncComplete_type (-1),
    d_lock_type (-1),
    d_unlock_type (-1),
    d_reqHandlers (NULL),
    d_completeHandlers (NULL),
    d_lockHandlers (NULL),
    d_peer (NULL)
{
  //  int i;

  strncpy(d_name, name, 30);

}

nmui_Component::~nmui_Component (void) {

  if (d_peer) {
    d_peer->unregister_handler(d_syncRequest_type, handle_syncRequest,
                                     this, d_myId);
    d_peer->unregister_handler(d_syncComplete_type, handle_syncComplete,
                                     this, d_myId);
  }
}

const char * nmui_Component::name (void) const {
  return d_name;
}

int nmui_Component::numPeers (void) const {
  return d_numPeers;
}

int nmui_Component::synchronizedTo (void) const {
  return d_synchronizedTo;
}

vrpn_bool nmui_Component::isLockedRemotely (void) const {
  return d_isLockedRemotely;
}

vrpn_bool nmui_Component::holdsRemoteLocks (void) const {
  return d_holdsRemoteLocks;
}




void nmui_Component::add (Tcl_Netvar * newLinkvar) {
  if (d_numVars >= 3 * NMUI_COMPONENT_MAX_SIZE) {
    fprintf(stderr, "nmui_Component::add:  "
                    "Too many linkvars in component.\n");
    return;
  }

  d_vars[d_numVars] = newLinkvar;
  newLinkvar->bindConnection( d_connection );
  d_numVars++;
}

void nmui_Component::remove (Tcl_Netvar * link_var) {
  for (int i=0; i < d_numVars; i++) {
    if (d_vars[i] == link_var) {
      // delete d_vars[i];
      for (int j = i; j < d_numVars; j++) {
	d_vars[j] = d_vars[j+1];
      }
      d_numVars--;
      return;
    }
  }
}

void nmui_Component::add (nmui_Component * newComponent) {
  if (d_numComponents >= NMUI_COMPONENT_MAX_SIZE) {
    fprintf(stderr, "nmui_Component::add:  "
                    "Too many (sub-)components in component.\n");
    return;
  }

  d_components[d_numComponents] = newComponent;
  newComponent->bindConnection( d_connection );
  d_numComponents++;
}

nmui_Component * nmui_Component::find (char c_name[30]) {
  for (int i=0; i < d_numComponents; i++) {
    nmui_Component * t = d_components[i];
    if (strcmp(t->name(), c_name) == 0) {
      return d_components[i];
    }
  }
  return NULL;
}
 
void nmui_Component::bindConnection (vrpn_Connection * c) {
  char namebuf [60];
  int i;

  d_connection = c;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->bindConnection(c);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->bindConnection(c);
  }

  sprintf(namebuf, "nmui Component %s", d_name);
  if( d_connection != NULL )
  {
    d_myId = d_connection->register_sender(namebuf);
    d_syncRequest_type =
      d_connection->register_message_type(d_syncRequest_type_string);
    d_syncComplete_type =
      d_connection->register_message_type(d_syncComplete_type_string);
  }
//fprintf(stderr, "## Bound connection %ld for nmuiComponent %s.\n",
//c, d_name);
}

void nmui_Component::bindLogConnection (vrpn_Connection * c) {
  int i;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->bindLogConnection(c);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->bindLogConnection(c);
  }

}

void nmui_Component::addPeer (vrpn_Connection * c, vrpn_bool serialize) {
  int i;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->addPeer(c, serialize);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->addPeer(c, serialize);
  }

  d_peer = c;
  d_numPeers++;

//fprintf(stderr, "## Finished with addPeer() for nmui Component %s, \n"
//"peer connection %ld.\n", d_name, d_peer);
}

void nmui_Component::copyReplica (int whichReplica) {
  int i;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->copyReplica(whichReplica);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->copyReplica(whichReplica);
  }
}

void nmui_Component::copyFromToReplica (int sourceReplica, int destReplica) {
/* */
  int i;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->copyFromToReplica(sourceReplica, destReplica);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->copyFromToReplica(sourceReplica, destReplica);
  }
/* */
}

void nmui_Component::syncReplica (int whichReplica) {
  int i;

  for (i = 0; i < d_numVars; i++) {
    d_vars[i]->syncReplica(whichReplica);
  }
  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->syncReplica(whichReplica);
  }

  d_synchronizedTo = whichReplica;
}


void nmui_Component::requestSync (void) {
  timeval now;

  gettimeofday(&now, NULL);
  if( d_connection != NULL )
    d_connection->pack_message(0, now, d_syncRequest_type, d_myId, NULL,
                               vrpn_CONNECTION_RELIABLE);

//fprintf(stderr, "++ nmui_Component::requestSync sent.\n");
}

void nmui_Component::registerSyncRequestHandler
                                (nmui_SyncRequestHandler h,
                                 void * userdata) {
  reqHandlerEntry * he;

  he = new reqHandlerEntry;
  if (!he) {
    fprintf(stderr, "nmui_Component::registerSyncRequestHandler:  "
                    "Out of memory.\n");
    return;
  }

  he->handler = h;
  he->userdata = userdata;
  he->next = d_reqHandlers;
  d_reqHandlers = he;
}

void nmui_Component::registerSyncCompleteHandler
                                (nmui_SyncCompleteHandler h,
                                 void * userdata) {
  completeHandlerEntry * he;

  he = new completeHandlerEntry;
  if (!he) {
    fprintf(stderr, "nmui_Component::registerSyncCompleteHandler:  "
                    "Out of memory.\n");
    return;
  }

  he->handler = h;
  he->userdata = userdata;
  he->next = d_completeHandlers;
  d_completeHandlers = he;
}


// static
int nmui_Component::handle_reconnect (void * /*userdata*/, vrpn_HANDLERPARAM) {
    //nmui_Component * c;
    //c = (nmui_Component *) userdata;
  // XXX  Which connection is that, again?  HACK
  //c->initializeConnection(c->d_peer);
  return 0;
}

void nmui_Component::initializeConnection (vrpn_Connection * c) {
  char namebuf [60];
  vrpn_int32 myId;
  vrpn_int32 syncRequest_type;
  vrpn_int32 syncComplete_type;
  //vrpn_int32 lock_type;
  //vrpn_int32 unlock_type;

  if (!c) {
    fprintf(stderr, "nmui_Component::initializeConnection:  is NULL!\n");
    return;
  }

//fprintf(stderr, "## In nmui_Component::initializeConnection (%ld).\n", c);

  sprintf(namebuf, "nmui Component %s", d_name);
  myId = c->register_sender(namebuf);
  syncRequest_type =
      c->register_message_type(d_syncRequest_type_string);
  syncComplete_type =
      c->register_message_type(d_syncComplete_type_string);

  // MAKE SURE THERE'S ONLY ONE COPY OF THE HANDLER - HACK
  c->unregister_handler(syncRequest_type, handle_syncRequest,
                      this, myId);
  c->unregister_handler(syncComplete_type, handle_syncComplete,
                      this, myId);
  c->register_handler(syncRequest_type, handle_syncRequest,
                      this, myId);
  c->register_handler(syncComplete_type, handle_syncComplete,
                      this, myId);
}


// need to break this off of handle_syncRequest so that only one syncComplete
// message is sent

void nmui_Component::do_handle_syncRequest (void) {
    //nmui_Component * c;
  reqHandlerEntry * he;
  int i;

  for (he = d_reqHandlers; he; he = he->next) {
    (*he->handler)(he->userdata);
  }

  for (i = 0; i < d_numComponents; i++) {
    d_components[i]->do_handle_syncRequest();
  }
}

// static
int nmui_Component::handle_syncRequest (
    void * userdata,
    vrpn_HANDLERPARAM /*p*/)
{
  nmui_Component * c;
  timeval now;

  c = (nmui_Component *) userdata;

//fprintf(stderr, "++ In component %s handle_syncRequest\n", c->name());

  // HACK
  // Call handlers iff we are synchronized to a remote (non-0) replica.
  // This keeps state consistent between replicas using centralized
  // serialization and shared replicas.
  if (c->synchronizedTo()) {
    c->do_handle_syncRequest();
  }

  gettimeofday(&now, NULL);
  if( c->d_connection != NULL )
    c->d_connection->pack_message(0, now, c->d_syncComplete_type,
                                  c->d_myId, NULL,
                                  vrpn_CONNECTION_RELIABLE);
  return 0;
}


// static
int nmui_Component::handle_syncComplete (void * userdata, vrpn_HANDLERPARAM p) {
  nmui_Component * c;
  //nmui_Component * cc;
  completeHandlerEntry * he;
  int i;

  c = (nmui_Component *) userdata;

//fprintf(stderr, "++ In component %s handle_syncComplete\n", c->name());

  for (he = c->d_completeHandlers; he; he = he->next) {
    (*he->handler)(he->userdata);
  }

  // traverse children
  for (i = 0; i < c->d_numComponents; i++) {
    handle_syncComplete(c->d_components[i], p);
  }

  return 0;
}

