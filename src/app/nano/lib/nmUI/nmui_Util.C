/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "nmui_Util.h"

#include <v.h>  // for v_xform_type, v_get_world_from_hand()
#include <stdio.h>  // for stderr

#include <BCPlane.h>

#include <nmb_Globals.h>  // for dataset
#include <nmb_Dataset.h>
#include <nmb_String.h>
#include <nmg_Globals.h>  // for graphics
#include <nmg_Graphics.h>
#include <nmm_Types.h>   // for CONSTR_FREEHAND_XYZ and related params enums

// static
int nmui_Util::getHandInWorld (int user, q_vec_type & position) {
  v_xform_type worldFromHand;
  v_get_world_from_hand(user, &worldFromHand);
  q_vec_copy(position, worldFromHand.xlate);
  return 0;
}

// static
vrpn_bool nmui_Util::convertPositionToNM (BCPlane * plane,
                                          q_vec_type & position) {

  // We want the position we return to be in real-world units (nanometers),
  // not the world coords of vlib, so we must take into account
  // the arbitrary scale applied to the Z coord by the plane.

  if (plane->scale() > 1e-10) {
    position[2] = position[2] / plane->scale();
    return vrpn_true;
  } else {
    // signal error
    return vrpn_false;
  }
}

/** Takes a position in world space, and makes sure it is inside
 the edges of the plane passed in. This works because the boundaries
of the plane are defined in world space. */

// static
int nmui_Util::clipPosition (BCPlane * plane, q_vec_type & position) {

  if (!plane) {
    fprintf(stderr, "Error in nmui_Util::clipPosition:  "
                    "No input plane.\n");
    return -1;
  }

  if (position[0] < plane->minX()) position[0] = plane->minX();
  if (position[0] > plane->maxX()) position[0] = plane->maxX();
  if (position[1] < plane->minY()) position[1] = plane->minY();
  if (position[1] > plane->maxY()) position[1] = plane->maxY();

  return 0;
}

/** Constrain movement to a line, represented by the first two points in the
    position_list. */

// static
int nmui_Util::clipPositionLineConstraint (BCPlane * plane, 
					   q_vec_type & position, 
					   Position_list & p,
					   int mode,
					   int xyz_param) {
  if (!plane) {
    fprintf(stderr, "Error in nmui_Util::clipPositionLineConstraint:  "
                    "No input plane.\n");
    return -1;
  }

  if (position[0] < plane->minX()) position[0] = plane->minX();
  if (position[0] > plane->maxX()) position[0] = plane->maxX();
  if (position[1] < plane->minY()) position[1] = plane->minY();
  if (position[1] > plane->maxY()) position[1] = plane->maxY();

  //We want the position we return to be in real-world units (nanometers),
  // not the world coords of vlib. So we must take into account
  // the arbitrary scale applied to the Z coord by the plane.
  position[2] = position[2]/plane->scale();

  // position now holds the user's real hand position. We want to
  // constrain it to a line defined by the two points stored in the
  // position_list p. We need to find the point on the line closest to
  // the hand position. So we take a vector from p0 to hand, and
  // project it onto the vector from p0 to p1. Adding this vector to
  // p0 gives us our point. See Folley and vanDam p. 1100 exercise for
  // more.
  
  // vector v from p0 to p1
  float v0, v1, v2;
  p.goToHead();
  v0 = (p.peekNext())->x() - p.currX();
  v1 = (p.peekNext())->y() - p.currY();
  if (mode == CONSTR_FREEHAND_XYZ) {
    v2 = (p.peekNext())->z() - p.currZ();
  }

  // if v is zero this won't work - return hand position unchanged.  
  if (mode != CONSTR_FREEHAND_XYZ) {
    if ((v0 == 0) && (v1 == 0)) return 0;
  } else {
    if ((v0 == 0) && (v1 == 0) && (v2 == 0)) return 0;
  }

  // vector w from p0 to hand position.
  float w0, w1, w2;
  w0 = position[0] - p.currX();
  w1 = position[1] - p.currY();

  if (mode == CONSTR_FREEHAND_XYZ) {
    w2 = position[2] - p.currZ();
  }

  // parameter t of line from p0 to p1. Solve eqn for t: (w.v)/(v.v)
  float t;

  if (mode != CONSTR_FREEHAND_XYZ) {
    t = (w0*v0 + w1*v1)/(v0*v0 + v1*v1);
  } else {
    t = (w0*v0 + w1*v1 + w2*v2)/(v0*v0 + v1*v1 + v2*v2);    
  }

  // Our new point is p0 + t*v
  position[0] = p.currX() + t * v0;
  position[1] = p.currY() + t * v1;
  
  if ( (mode == CONSTR_FREEHAND_XYZ) && (xyz_param == CONSTR_XYZ_LINE) ) {
    position[2] = p.currZ() + t * v2;
  } // else we're in CONSTR_XYZ_PLANE mode, so use the z that's already in position

  return 0;
}

// static
int nmui_Util::moveAimLine (BCPlane * plane, q_vec_type position, 
			    nmg_Graphics * graphics) {
  PointType Top, Bot;

  Top[0] = Bot[0] = position[0];
  Top[1] = Bot[1] = position[1];
  Top[2] = plane->maxAttainableValue() * plane->scale();
  Bot[2] = plane->minAttainableValue() * plane->scale();

  graphics->positionAimLine(Top, Bot);

  return 0;
}

// static
int nmui_Util::moveSphere (q_vec_type position, nmg_Graphics * graphics) {

  graphics->positionSphere(position[0], position[1], position[2]);

  return 0;
}
