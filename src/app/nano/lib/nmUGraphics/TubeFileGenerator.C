/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include <string.h>

#include <vector>

#ifdef sgi
using std::vector;
#endif

#include <nmb_Dataset.h>

#include "URender.h"
#include "URTubeFile.h"
#include "TubeFileGenerator.h"

#include "quat.h"

// Created by Borland 02/21/02
// Handles the creation of objects from Shape Analysis output files


#ifdef sgi
// isspace and isalnum are found in ctype.h on the sgi's
#include <ctype.h>
#endif

#ifdef __CYGWIN__
// taken from WaveFrontFileGenerator.C
// XXX juliano 9/19/99
//       this was implicitly declared.  Needed to add decl.
//       getpid comes from unistd.h
#include <sys/types.h>  // for pid_t
extern "C" {
pid_t getpid();
}
#endif

#define MAXLENGTH	512		// buffer size

const double PI = 3.1415926535;


extern nmb_Dataset * dataset;



TubeFileGenerator::TubeFileGenerator(const char* fname) 
	: FileGenerator(fname, "txt")
{
}


int TubeFileGenerator::ReLoad(URender *Pobject, GLuint *&Dlist_array) {
	return Load(Pobject, Dlist_array);
}


typedef vector<float> vertex;
typedef vector<vertex> verts;
//typedef vector<verts> tubes;

typedef vector<cylinder> cylinders;


void BuildListTube(URTubeFile *Pobject, GLuint dl, verts vs, int & count);




// This function reads Shape Analysis output file
// it will create an openGL display list for each logical object
int TubeFileGenerator::Load(URender *Pobject, GLuint *&Dlist_array)
{
	char buffer[MAXLENGTH];
	char* token;
	ifstream readfile;

	int i, j;
	double radius, x, y, z, az, alt;
	double theta;
	double minX, maxX, minY, maxY, z_value;
	double xmid, ymid, zmid;
	int imageX, imageY;
	int cur_step = 0;
	double scale_factor;
	bool skip_first;		// skips first point--sometimes the azimuth is incorrect...

	// pointer to the current plane
	BCPlane *height = dataset->inputGrid->getPlaneByName(dataset->heightPlaneName->string());

//	tubes t;				// gives a bunch of warnings because the name is too big...
	verts t[10];			// go with static number for now...  10 tubes allowed per file
	verts vs;
	vertex v;

	cylinder c;
	cylinders cs;

	q_vec_type p1;
	q_vec_type p2;
	q_type q;

	q_type coord_fix;
	q_vec_type trans;

	URTubeFile* tube = (URTubeFile*)Pobject;		// cast the URender as a URTubeFile

	int tess = tube->GetTess();
	long num_triangles = 0;

	int numtubes = 0;

	bool newtube;

	GLuint dl;


	q_from_euler(coord_fix, -PI / 2, 0, 0);		// coordinate systems are different
												// this fixes it

	// set up min and max values for the current plane
	minX = height->minX();
	maxX = height->maxX();
	minY = height->minY();
	maxY = height->maxY();

	// set up z offset
//	z_value = height->scale() * 0.5 * (height->maxNonZeroValue() + height->minNonZeroValue());
	z_value = height->minNonZeroValue();
//	z_value = height->maxNonZeroValue();

/*
printf("minX = %f\n", minX);
printf("maxX = %f\n", maxX);
printf("minY = %f\n", minY);
printf("maxY = %f\n", maxY);
printf("z_value = %f\n", z_value);
printf("scale = %f\n", height->scale());
printf("minnzv = %f\n", height->minNonZeroValue());
printf("maxnzv = %f\n", height->maxNonZeroValue());
printf("maxav = %f\n", height->maxAttainableValue());
printf("%f\n", height->maxNonZeroValueComputedLast());
printf("%f\n", height->maxValue());
printf("%f\n", height->scaledMaxValue());
*/


	// set up translation to correct place in height plane
	q_vec_set(trans, 0, maxY - minY, 0);

	readfile.open(filename);
    assert(readfile);

    if(readfile.bad()) {
		cerr << "Unable to open input file" << endl;
        return 0;
    }
	while(!readfile.eof()) {
		readfile.getline(buffer, MAXLENGTH);

		token = strtok(buffer, " \t\n");
		if (token != NULL) {
			if (*token == 'X') { 
				// do nothing
			}
			else if (strcmp(token, "image") == 0) {
				// get image dimensions
				token = strtok(NULL, ":");

				token = strtok(NULL, " \t\n");
				imageX = atoi(token);

				token = strtok(NULL, " \t\n");

				token = strtok(NULL, " \t\n");
				imageY = atoi(token);

				scale_factor = (maxX - minX) / imageX;
			}
			else if (strcmp(token, "radius") == 0) {
				// if not first tube, add to tubes
				if (vs.size() != 0) {
					t[numtubes++] = vs;
					vs.clear();
				}

				// get rid of last cylinder--it is bogus
				if (cs.size() != 0 ) {
					// get rid of last cylinder--it is bogus
					cs.pop_back();
				}
				newtube = true;
	
				// get the radius of the new tube
				token = strtok(NULL, " =\t\n");
				radius = atof(token);

				// sometimes shape analysis gives a radius of zero--quick hack to fix this
				if (radius == 0.0) radius = 5.0;

				// scale to correct size
				radius *= scale_factor;

				// set skip_first
				skip_first = true;

			}
			else {			// should contain numerical data
				if (skip_first) {	// skip the first point--sometimes gives bogus azimuth
					skip_first = false;
				}
				else {
					if (cur_step++ % tube->GetAxisStep() == 0) {
						cur_step = 1;

						/* 
						// THIS CODE IS FOR USING X3D, Y3D, Z3d

						token = strtok(NULL, " \t\n");		// skip X and Y

						token = strtok(NULL, " \t\n");
						x = atof(token);
						token = strtok(NULL, " \t\n");
						y = atof(token);
						token = strtok(NULL, " \t\n");
						z = atof(token);
						token = strtok(NULL, " \t\n");
						az = atof(token);
						token = strtok(NULL, " \t\n");
						alt = atof(token);

						*/

						// THIS CODE IS FOR USING X and Y (constant Z)


						x = atof(token);
						// scale to correct size
						x *= scale_factor;

						token = strtok(NULL, " \t\n");
						y = atof(token);
						// scale to correct size
						y *= scale_factor;

						z = radius;
//						z = 0.0;


						// skip X3D, Y3D, Z3D
						token = strtok(NULL, " \t\n");
						token = strtok(NULL, " \t\n");
						token = strtok(NULL, " \t\n");


						token = strtok(NULL, " \t\n");
						az = atof(token);
						token = strtok(NULL, " \t\n");
						// buggy alt output from shape analysis...just set to zero for now
	//					alt = atof(token);
						alt = 0.0;

						// set up medial axis point
						q_vec_set(p1, x, y, z);

						// coordinate systems are different
						// this fixes it
						q_xform(p1, coord_fix, p1);
						q_vec_add(p1, p1, trans);

						// set up rotation quat
						q_from_euler(q, az, 0, alt);

						// get vertices
						theta = 0.0;
						for (i = 0; i < tess; i++) {
							v.clear();

							// set point
							q_vec_set(p2,	p1[0] + radius * cos(theta),
											p1[1],
											p1[2] + radius * sin(theta));

							// translate point to origin
							q_vec_subtract(p2, p2, p1);
						
							// rotate
							q_xform(p2, q, p2);

							// translate back
							q_vec_add(p2, p2, p1);

							v.push_back(p2[0]);
							v.push_back(p2[1]);
							v.push_back(p2[2]);

							vs.push_back(v);
							theta += 2 * PI / tess;

							num_triangles += 2;	// two triangles per vertex
						}
						// do cylinder stuff
						c.x1 = p1[0];
						c.y1 = p1[1];
						c.z1 = p1[2];

						if (!newtube) {	
							// fill in previous guy's second point
							cs.back().x2 = c.x1;
							cs.back().y2 = c.y1;
							cs.back().z2 = c.z1;
							// fill in length
							cs.back().length = sqrt((cs.back().x2 - cs.back().x1) * (cs.back().x2 - cs.back().x1) +
													(cs.back().y2 - cs.back().y1) * (cs.back().y2 - cs.back().y1) +
													(cs.back().z2 - cs.back().z1) * (cs.back().z2 - cs.back().z1));
						}
						c.radius = radius;
						c.az = az + PI / 2;
						c.alt = alt;
						cs.push_back(c);
						newtube = false;
					}
				}
			}
		}
	}
	// add last tube
	t[numtubes++] = vs;

	// get rid of last cylinder--it is bogus
	cs.pop_back();

	// set up tubes so that it's origin is around the center--helps for doing scaling and rotation
	
	//commented out by Andrea--trying to match up method of finding center of tube between afm 
	//simulator and nano--switching from approximation using only endpts to avg. of all cylinders
	/*
	xmid = cs.front().x1 + (cs.back().x2 - cs.front().x1) / 2;
	ymid = cs.front().y1 + (cs.back().y2 - cs.front().y1) / 2;
	zmid = cs.front().z1 + (cs.back().z2 - cs.front().z1) / 2;
	*/

	xmid = 0;//initialize to zero
	ymid = 0;
	zmid = 0;
	for (i = 0; i < cs.size(); i++) {
		xmid +=(cs[i].x1 +cs[i].x2)/2;//get x midpt. of each tube and add to running total
		ymid +=(cs[i].y1 +cs[i].y2)/2;
		zmid +=(cs[i].z1 +cs[i].z2)/2;
	}
	xmid = xmid/cs.size();
	ymid = ymid/cs.size();
	zmid = zmid/cs.size();

	//divide by size to get avg. x,y,z position of the entire tube
	

	for (i = 0; i < numtubes; i++){
		for (j = 0; j < t[i].size(); j++) {
			t[i][j][0] -= xmid;
			t[i][j][1] -= ymid;
			t[i][j][2] -= zmid;
		}
	}

	// copy cylinders to tube's cylinder list
	tube->num_cylinders = cs.size();
	tube->cylinders = new cylinder[tube->num_cylinders];
	for (i = 0; i < tube->num_cylinders; i++) {
		memcpy(&tube->cylinders[i], &cs[i], sizeof(c));
	}
	// set up tubes so that it's origin is around the center--helps for doing scaling and rotation
	for (i = 0; i < tube->num_cylinders; i++) {
		tube->cylinders[i].x1 -= xmid;
		tube->cylinders[i].y1 -= ymid;
		tube->cylinders[i].z1 -= zmid;
		tube->cylinders[i].x2 -= xmid;
		tube->cylinders[i].y2 -= ymid;
		tube->cylinders[i].z2 -= zmid;
	}

	// create geometry from list of vertices

	//	set up display list id's
	Dlist_array = new GLuint[numtubes];
    dl = glGenLists(numtubes);
    if (dl == 0 || Dlist_array == NULL) { 
		cerr << "Bad Display List generation\n"; 
        //kill(getpid(),SIGINT); 
        return 0;
	}

	int count = 0;
	for (i = 0; i < numtubes; i++){
		//BuildListTube actually builds the geometry from
		//the data structures previously built
        BuildListTube(tube, dl + i, t[i], count);
		Dlist_array[i] = dl + i;
	}

	readfile.close();

	// add minimum extents of the height plane
	tube->GetLocalXform().SetXOffset(minX);
	tube->GetLocalXform().SetYOffset(minY);
	tube->GetLocalXform().SetZOffset(z_value);

	// translate back from object center at origin
//	tube->GetLocalXform().SetTranslate(xmid * scale_factor, ymid * scale_factor, zmid * scale_factor);
	tube->GetLocalXform().SetTranslate(xmid, ymid, zmid);
	// coordinate systems are different
	// this fixes it
//	tube->GetLocalXform().SetTranslate(trans[0] + xmid, trans[1] + ymid, trans[2] + zmid);
//	tube->GetLocalXform().SetTranslate(0,0,0);

	// scale 
//	tube->GetLocalXform().SetScale(scale_factor);


/*
	for (i = 0; i < tube->num_cylinders; i++) {
		printf("x = %f\n", tube->cylinders[i].x1);
		printf("y = %f\n", tube->cylinders[i].y1);
		printf("z = %f\n", tube->cylinders[i].z1);
		printf("altitude = %f\n", tube->cylinders[i].alt);
		printf("azimuth = %f\n", tube->cylinders[i].az);
		printf("length = %f\n", tube->cylinders[i].length);
		printf("radius = %f\n\n", tube->cylinders[i].radius);
	}
*/
	return numtubes;  // should be number of display lists
}



void BuildListTube(URTubeFile *Pobject, GLuint dl, verts vs, int & count) {
	float v1[4];
	float v2[4];
	float v3[4];
	float v4[4];

	int i, k;

	q_vec_type n1;
	q_vec_type n2;

	int tess = Pobject->GetTess();

	glNewList(dl, GL_COMPILE);	// init display list

	for (i = 0; i < vs.size() - tess; i++) {
		glBegin(GL_TRIANGLES);
		for (k = 0; k < 3; k++) {
			// special case for last two triangles per segment
			if ((i + 1) >= tess && (i + 1) % tess == 0) {
				v1[k] = vs[i][k];
				v2[k] = vs[i + tess][k];
				v3[k] = vs[i + 1][k];
				v4[k] = vs[i - tess + 1][k];
			}
			else {
				v1[k] = vs[i][k];
				v2[k] = vs[i + tess][k];
				v3[k] = vs[i + tess + 1][k];
				v4[k] = vs[i + 1][k];
			}
		}
		v1[k] = v2[k] = v3[k] = v4[k] = 1.0;


		// Compute the normal...only flat shading for now...should be good enough???
		q_vec_set(n1, v4[0] - v2[0],
						v4[1] - v2[1],
						v4[2] - v2[2]);

		q_vec_set(n2, v1[0] - v4[0],
						v1[1] - v4[1],
						v1[2] - v4[2]);
		

		q_vec_cross_product(n1, n2, n1);

		q_vec_normalize(n1, n1);
	
		glNormal3f(n1[0], n1[1], n1[2]);
		glVertex4fv(v1);
		glVertex4fv(v2);
		glVertex4fv(v4);

		// Compute the normal...only flat shading for now...should be good enough???
		q_vec_set(n1, v4[0] - v3[0],
						v4[1] - v3[1],
						v4[2] - v3[2]);

		q_vec_set(n2, v2[0] - v4[0],
						v2[1] - v4[1],
						v2[2] - v4[2]);
		

		q_vec_cross_product(n1, n2, n1);

		q_vec_normalize(n1, n1);
	
		glNormal3f(n1[0], n1[1], n1[2]);
		glVertex4fv(v2);
		glVertex4fv(v3);
		glVertex4fv(v4);

		Pobject->UpdateBoundsWithPoint(v1[0], v1[1], v1[2]);  // should do for all points
		glEnd();
	}
	glEndList();
}
