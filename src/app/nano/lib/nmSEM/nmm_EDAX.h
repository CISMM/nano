/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef NMM_EDAX_H
#define NMM_EDAX_H

#include <vrpn_Types.h>

const int EDAX_ERROR = -1;
const int EDAX_OK = 0;

const int EDAX_TRUE = 1;
const int EDAX_FALSE = 0;

const int EDAX_READ = 1;
const int EDAX_WRITE = 2;

const int EDAX_BLANK_ON = 1;
const int EDAX_BLANK_OFF = 0;

const int EDAX_NORMAL_SCAN = 0;
const int EDAX_FAST_SCAN = 1;

const int EDAX_DATA_TRANSFER_NONE = 0;
const int EDAX_DATA_TRANSFER_BYTE = 1;
const int EDAX_DATA_TRANSFER_WORD = 2;

// for SgSetScanParams:
const int EDAX_DEFAULT_SCAN_TYPE = EDAX_FAST_SCAN;
const int EDAX_DEFAULT_DATA_TRANSFER = EDAX_DATA_TRANSFER_BYTE;

// for SgSetRetrace:
const int EDAX_DEFAULT_HORZ_RETRACE = 0;
const int EDAX_DEFAULT_VERT_RETRACE = 0;

// for SgSetScanDir:
const int EDAX_DIR_NORMAL = 0;
const int EDAX_DIR_MIRRORED = 1;

// for SetupDACParams:
const int EDAX_MIN_GAIN = 0;
const int EDAX_MAX_GAIN = 32767;
const int EDAX_MIN_OFFSET = -32766;
const int EDAX_MAX_OFFSET = 32767;

// 18500, 17800 are used to match Hitachi settings
const int EDAX_DEFAULT_X_DAC_GAIN = 18500;//((EDAX_MAX_GAIN + EDAX_MIN_GAIN)/2);
const int EDAX_DEFAULT_Y_DAC_GAIN = 17800;//EDAX_DEFAULT_X_DAC_GAIN;
const int EDAX_DEFAULT_Z_ADC_GAIN = EDAX_DEFAULT_X_DAC_GAIN;
// (5000,4000) match the Hitachi settings better than (0,0)
const int EDAX_DEFAULT_X_DAC_OFFSET = 5000;//((EDAX_MAX_OFFSET + EDAX_MIN_OFFSET)/2);
const int EDAX_DEFAULT_Y_DAC_OFFSET = 4000;//((EDAX_MAX_OFFSET + EDAX_MIN_OFFSET)/2);
const int EDAX_DEFAULT_Z_ADC_OFFSET = ((EDAX_MAX_OFFSET + EDAX_MIN_OFFSET)/2);

// for SgSetVideoPolarity
const int EDAX_POLARITY_NORMAL = (0);
const int EDAX_POLARITY_INVERTED = (1);

const int EDAX_NUM_INPUT_CHANNELS =(16);
const int EDAX_ADC1 =(0);
const int EDAX_ADC2 =(1);
const int EDAX_ADC3 =(2);
const int EDAX_ADC4 =(3);
const int EDAX_DIGITAL1 =(4);
const int EDAX_DIGITAL2 =(5);
const int EDAX_DIGITAL3 =(6);
const int EDAX_BITINPUT1 =(7);
const int EDAX_EDS_CROSS_PORT =(8);
const int EDAX_BITINPUT2 =(9);

// for SgSetMaxSpan:
const int EDAX_DEFAULT_MAX_X_SPAN = (65536);//(4096) or (65536)
const int EDAX_DEFAULT_MAX_Y_SPAN = (51200);//(3200) or (51200)

// for SetupSgColl, but affects scan generator settings too
const int EDAX_NUM_SCAN_MATRICES =(7);
extern int EDAX_SCAN_MATRIX_X[EDAX_NUM_SCAN_MATRICES];
extern int EDAX_SCAN_MATRIX_Y[EDAX_NUM_SCAN_MATRICES];
const int EDAX_DEFAULT_SCAN_MATRIX =(4);	// (1024 x 800)

const int EDAX_ADC1_ID =(1);
const int EDAX_ADC2_ID =(2);
const int EDAX_ADC3_ID =(3);
const int EDAX_ADC4_ID =(4);
const int EDAX_DIGITAL1_ID =(5);
const int EDAX_DIGITAL2_ID =(6);
const int EDAX_DIGITAL3_ID =(7);
const int EDAX_BITINPUT1_ID =(8);
const int EDAX_EDS_CROSS_PORT_ID =(9);
const int EDAX_BITINPUT2_ID =(10);

// for SetSgScan:
const int EDAX_FULL_SCAN =(1);
const int EDAX_REDUCED_RASTER =(3);
const int EDAX_SPOT_MODE =(5);

// other
const int EDAX_DEFAULT_BLANK_MODE=(1); // blank between points enabled

// this is based on experiment: approximate time to execute SpMoveEx() as 
// observed on an oscilloscope
const double EDAX_MIN_POINT_DWELL_SEC=(100e-6);

class nmm_EDAX {
 public:
  static int resolutionToIndex(const int res_x, const int res_y);
  static int indexToResolution(const int id, int &res_x, int &res_y);
  /// finds the nearest valid integration time
  static void snapIntegrationTime_nsec(int &time_nsec, vrpn_bool preferLarger);
  /// finds the nearest valid interpixel delay time
  static void snapInterPixelDelayTime_nsec(int &time_nsec,
                                           vrpn_bool preferLarger);
  /// finds the nearest valid resolution
  static void snapResolution(int &res_x, int &res_y, vrpn_bool preferLarger);
};

#endif
