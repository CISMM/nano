/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef NMG_RENDERSERVER_STRATEGIES_H
#define NMG_RENDERSERVER_STRATEGIES_H

// These small objects parameterize class nmg_Graphics_RenderServer.

#include <vrpn_Types.h>

class nmg_Graphics_RenderServer;
class nmg_CloudTexturer;
class nmg_State;

/** \class nmg_RenderServer_ViewStrategy
 * Specifies to a render server how to manage the viewing transform
 * and some other details of the rendering process.
 */

class nmg_RenderServer_ViewStrategy {

  public:

    nmg_RenderServer_ViewStrategy (nmg_Graphics_RenderServer *);
    virtual ~nmg_RenderServer_ViewStrategy (void) = 0;

    virtual vrpn_bool alwaysSendEntireScreen (void) const = 0;
    virtual void setViewingTransform (nmg_State *) = 0;

    virtual void setGraphicsModes (nmg_State *) = 0;

  protected:

    nmg_Graphics_RenderServer * d_server;

};

/** \class nmg_RSViewS_Ortho
 * Manages an orthographic projection of the surface from directly
 * overhead.
 */

class nmg_RSViewS_Ortho : public nmg_RenderServer_ViewStrategy {

  public:

    nmg_RSViewS_Ortho (nmg_Graphics_RenderServer *);
    virtual ~nmg_RSViewS_Ortho (void);

    virtual vrpn_bool alwaysSendEntireScreen (void) const;
    virtual void setViewingTransform (nmg_State *);

    virtual void setGraphicsModes (nmg_State *);
      /**< Turns off chartjunk, measure lines;  sets "planeonly".
       * Ortho wants to capture only the image of the plane.
       */

};

/** \class nmg_RSViewS_Slave
 * Manages a perspective projection of the surface slaved to the
 * user's viewpoint.
 */

class nmg_RSViewS_Slave : public nmg_RenderServer_ViewStrategy {

  public:

    nmg_RSViewS_Slave (nmg_Graphics_RenderServer *);
    virtual ~nmg_RSViewS_Slave (void);

    virtual vrpn_bool alwaysSendEntireScreen (void) const;
    virtual void setViewingTransform (nmg_State *);

    virtual void setGraphicsModes (nmg_State *);
      /**< Turns on chartjunk, measure lines;  not "planeonly".
       * Slave wants to capture the entire scene, plane and decorations.
       */
};

class nmg_RenderServer_Strategy {

  public:

    nmg_RenderServer_Strategy (nmg_Graphics_RenderServer *);
    virtual ~nmg_RenderServer_Strategy (void) = 0;

    virtual void render (nmg_State *);
      ///< Standard implementation calls nmg_RenderServer::defaultRender().
    virtual void captureData (nmg_State *) = 0;
    virtual void sendData (int minx, int maxx, int miny, int maxy) = 0;
    void updatePixelBuffer(int minx, int maxx, int miny, int maxy, vrpn_uint8 *new_buf);
    

  protected:

    nmg_Graphics_RenderServer * d_server;

};

/** \class nmg_RSStrategy_Texture
 * Sends back a
 * high-resolution capture of the surface colors meant to be used as a
 * texture map.  If d_alwaysSendEntireScreen is set this works as a
 * "video" mode.
 */

class nmg_RSStrategy_Texture : public nmg_RenderServer_Strategy {

  public:

    nmg_RSStrategy_Texture (nmg_Graphics_RenderServer *);
    virtual ~nmg_RSStrategy_Texture (void);

    virtual void captureData (nmg_State *);
    virtual void sendData (int minx, int maxx, int miny, int maxy);
};

/** \class nmg_RSStrategy_Vertex
 * Sends back a
 * low-resolution capture of surface colors and depth meant to be used as a
 * vertex mesh.  If d_alwaysSendEntireScreen is set this works as a
 * "IBR" mode.
 */

class nmg_RSStrategy_Vertex : public nmg_RenderServer_Strategy {

  public:

    nmg_RSStrategy_Vertex (nmg_Graphics_RenderServer *);
    virtual ~nmg_RSStrategy_Vertex (void);

    virtual void captureData (nmg_State * );
    virtual void sendData (int minx, int maxx, int miny, int maxy);

};

/** \class nmg_RSStrategy_CloudTexture
 * Sends back a
 * high resolution texture that is generated according to empirical
 * observations of clouds.
 */

class nmg_RSStrategy_CloudTexture : public nmg_RenderServer_Strategy {

  public:

    nmg_RSStrategy_CloudTexture (nmg_Graphics_RenderServer *);
    virtual ~nmg_RSStrategy_CloudTexture (void);

    virtual void render (nmg_State *);
    virtual void captureData (nmg_State *);
    virtual void sendData (int minx, int maxx, int miny, int maxy);

  private:
    vrpn_uint8 *d_frame;
    nmg_CloudTexturer *d_cloud_render;
};

#endif  // NMG_RENDERSERVER_STRATEGIES_H
