/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef NMR_MULTIRESOBJECTIVEMI_EMMA_H
#define NMR_MULTIRESOBJECTIVEMI_EMMA_H

#include "nmr_ObjectiveMI_EMMA.h"

/* nmr_MultiResObjectiveMI_EMMA
  This class is a multiresolution version of nmr_ObjectiveMI_EMMA
*/
class nmr_MultiResObjectiveMI_EMMA {
  public:
    nmr_MultiResObjectiveMI_EMMA();
    nmr_MultiResObjectiveMI_EMMA(int numLevels, float *stddev);
    ~nmr_MultiResObjectiveMI_EMMA();

    int numLevels() {return d_numResolutionLevels;}
    void getBlurStdDev(float *stddev);

    /* **************
    functions that affect the number and meaning of parameters of the
    objective function
    ***************** */

    /// choose between 2D reference or 2.5D reference image
    void setDimensionMode(nmr_DimensionMode mode);
    nmr_DimensionMode getDimensionMode();

    /* **************
    functions that affect the value of the objective function and its gradient
    ***************** */

    /// set/get how big the samples are - this affects how noisy the
    /// objective function value is
    /// return value is 0 if successful or -1 if out of memory
    int setSampleSizes(int sizeA, int sizeB);
    void getSampleSizes(int &sizeA, int &sizeB);

    /// set whether to choose samples randomly, on a regular grid
    /// or randomly with a gradient magnitude-based sample rejection criterion
    void setSamplePositionMode(nmr_SamplePositionMode mode);
    void setSampleRejectionCriterion(nmr_SampleRejectionCriterion crit);
    void setMinSampleSqrGradientMagnitude(double mag);
    void setRefFeaturePoints(int numPnts, double *x, double *y);

    /// set images, if a list is supplied then multiple versions of the
    /// image will be added to the list for the various resolutions
    void setReferenceValueImage(nmb_Image *ref, 
                                nmb_ImageList *monitorList = NULL);
    void setTestValueImage(nmb_Image *test,
                           nmb_ImageList *monitorList = NULL);
    void setReferenceZImage(nmb_Image *ref_z,
                            nmb_ImageList *monitorList = NULL);
 
    /* **************
    objective function value and gradient
    ***************** */

    /// these functions compute objective function value and gradient vector
    /// as a function of the transformation (passed in as a 16 element
    /// array of doubles as used by nmb_TransformMatrix44)
    /// that takes points in the reference image (possibly augmented by
    /// a height value if a z value image has been set)
    /// this transformation should be in terms of pixels

    /// objective function value
    double value(int level, double *testFromReferenceTransform);

    /// get gradient vector
    void gradient(int level, double *testFromReferenceTransform, 
                  double *gradMI);

    /// since we can share some of the computation between value and
    /// gradient computations, if you need both you should call this
    /// function
    void valueAndGradient(int level, double *testFromReferenceTransform,
                double &valueMI, double *gradMI);

    int getJointHistogram(int level,
                           nmb_Image *histogram, 
                           double *transform, vrpn_bool blur, 
                           vrpn_bool setRefScale,
                           float min_ref, float max_ref,
                           vrpn_bool setTestScale,
                           float min_test, float max_test);

    void setCovariance(int level, double sigmaRefRef, double sigmaTestTest);
    void getCovariance(int level, double &sigmaRefRef, double &sigmaTestTest);
    void crossEntropyGradient(int level, double &dHc_dsigma_ref,
                                         double &dHc_dsigma_test);
    void crossEntropy(int level, double &entropy);

    void setTestVariance(int level, double sigma);
    void getTestVariance(int level, double &sigma);
    void testEntropyGradient(int level, double &dH_dsigma_test);
    void testEntropy(int level, double &entropy);

    void setRefVariance(int level, double sigma);
    void getRefVariance(int level, double &sigma);
    void refEntropyGradient(int level, double &dH_dsigma_ref);
    void refEntropy(int level, double &entropy);

  protected:
    int d_numResolutionLevels;
    float *d_stddev;
    nmr_ObjectiveMI_EMMA *d_objectiveMI;
    static int s_defaultNumResolutionLevels;
    static float s_defaultStdDev[];
};

#endif
