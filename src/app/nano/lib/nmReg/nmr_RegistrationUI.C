/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*===3rdtech===
  Copyright (c) 2000 by 3rdTech, Inc.
  All Rights Reserved.

  This file may not be distributed without the permission of 
  3rdTech, Inc. 
  ===3rdtech===*/
#include "nmr_RegistrationUI.h"
#include "nmr_Util.h"
//#include <nmb_Dataset.h>
//#include <microscape.h> // for disableOtherTextures
#include <nmui_ColorMap.h>
#include <nmr_AlignerMI.h>
#include <nmb_Transform_TScShR.h>

#include "matrixcl.h"
using namespace math;
typedef matrix<double> Matrix;

#include <algorithm>

#ifndef M_PI
static double M_PI = 3.14159265358979323846;
#endif

/*
this is annoying because it takes too long to calculate the image pyramid
vrpn_int32 nmr_RegistrationUI::s_defaultNumResolutionLevels = 15;
vrpn_float32 nmr_RegistrationUI::s_defaultStdDev[] = 
               {0.0, 0.6, 1.0, 1.2, 1.4, 
                1.7, 2.0, 2.4, 3,  3.6,
                4.5,   6,  9, 13, 18};
*/
vrpn_int32 nmr_RegistrationUI::s_defaultNumResolutionLevels = 5;
vrpn_float32 nmr_RegistrationUI::s_defaultStdDev[] =
                {0.0,1.0,2.0,4.0,8.0};

vrpn_int32 nmr_RegistrationUI::s_numAutoAlignModes = 3;
nmr_AutoAlignMode nmr_RegistrationUI::s_autoAlignModes[] = 
                {NMR_AUTOALIGN_FROM_MANUAL, NMR_AUTOALIGN_FROM_DEFAULT,
                        NMR_AUTOALIGN_FROM_AUTO};
char * nmr_RegistrationUI::s_autoAlignModeNames[] =
                {"Manual Init", "Default Init", "Auto Init"};

vrpn_int32 nmr_RegistrationUI::s_numTransformationSources = 3;
nmr_RegistrationType nmr_RegistrationUI::s_transformationSources[] =
                {NMR_MANUAL, NMR_DEFAULT, NMR_AUTOMATIC};
char * nmr_RegistrationUI::s_transformationSourceNames[] =
                {"Manual", "Default", "Auto"};

static vector< vector< vector <double> > > markersForReport; // markerForReport[image number][marker index][x or y coordinate]
static vector< vector <bool> > control_markersForReport;

static vector< vector< vector <double> > > orderedMarkers; //[marker number][marker index][x or y coordinate]

nmr_RegistrationUI::nmr_RegistrationUI
  ( nmr_Registration_Proxy *aligner, 
    nmb_ImageDisplay *display):

   d_registrationImageName3D("reg_surface_cm(color_comes_from)", "none"),
   d_refresh3D("reg_refresh_3D", 0),
   d_fiducialSpotTracker3D("reg_fiducial_spot_tracker_3D", "none"),
   d_optimizeSpotTrackerRadius3D("reg_spot_tracker_optimize_radius_3D", 0),
   d_spotTrackerRadius3D("reg_spot_tracker_radius_3D", 5.0),
   d_spotTrackerRadiusAccuracy3D("reg_spot_tracker_radius_accuracy_3D", 0.05),
   d_spotTrackerPixelAccuracy3D("reg_spot_tracker_pixel_accuracy_3D", 0.05),
   d_registrationImageName2D("reg_projection_cm(color_comes_from)", "none"),
   d_refresh2D("reg_refresh_2D", 0),
   d_fiducialSpotTracker2D("reg_fiducial_spot_tracker_2D", "none"),
   d_optimizeSpotTrackerRadius2D("reg_spot_tracker_optimize_radius_2D", 0),
   d_spotTrackerRadius2D("reg_spot_tracker_radius_2D", 5.0),
   d_spotTrackerRadiusAccuracy2D("reg_spot_tracker_radius_accuracy_2D", 0.05),
   d_spotTrackerPixelAccuracy2D("reg_spot_tracker_pixel_accuracy_2D", 0.05),
   d_flipProjectionImageInX("reg_proj_flipX", 0),
   d_newResampleImageName("resample_image_name", ""),
   d_newResamplePlaneName("resample_plane_name", ""),
   d_registrationEnabled("reg_window_open", 0),
   d_constrainToTopography("reg_constrain_to_topography", 0),
   d_invertWarp("reg_invert_warp", 0),
   d_textureDisplayEnabled("reg_display_texture", 0),
   d_textureAlpha("reg_texture_alpha", 1),
   d_resampleResolutionX("resample_resolution_x", 100),
   d_resampleResolutionY("resample_resolution_y", 100),
   d_resampleRatio("reg_resample_ratio", 0),
   d_registrationColorMap3D("reg_surface_cm(color_map)", "none"),
   d_registrationColorMap2D("reg_projection_cm(color_map)", "none"),

   d_autoAlignRequested("auto_align_requested", 0),
   d_numIterations("auto_align_num_iterations", 100),
   d_stepSize("auto_align_step_size", 1.0),
   d_resolutionLevel("auto_align_resolution", "0"),
   d_numResolutionLevels(0),
   d_resolutionLevelList("auto_align_resolution_list"),
   d_saveRegistrationMarkers("save_registration_markers", 0), //new
   d_loadRegistrationMarkers("load_registration_markers", 0), //new
   d_pointsReport("save_Points_report", 0), //new
   d_calculateErrorReport("calculate_Error_report", 0), //new
   d_calculateAveragePointsErrorReport("calculate_Average_Points_Error_Report", 0), //new
   d_saveReport("save_report", 0), //new
   d_runRegistration("run_ransac", 0), //new
   d_setTopoIntensityThreshold("set_topoIntensityThreshold", 10),
   d_setProjIntensityThreshold("set_projIntensityThreshold", 0.7),
   d_calculatePoints("run_calculatePoints", 0), //new
   d_drawTopographyPoints("run_drawTopographyPoints", 0), //new
   d_saveTopographyPoints("run_saveTopographyPoints", 0), //new
   d_drawProjectionPoints("run_drawProjectionPoints", 0), //new
   d_saveProjectionPoints("run_saveProjectionPoints", 0), //new
   d_runDrawRegistration("draw_registration", 0), //new

   d_scaleX("reg_scaleX", 1.0),
   d_scaleY("reg_scaleY", 1.0),
   d_translateX("reg_translateX", 0.0),
   d_translateY("reg_translateY", 0.0),
   d_translateZ("reg_translateZ", 0.0),
   d_rotate2D_Z("reg_rotate2D_Z", 0.0), 
   d_rotate3D_X("reg_rotate3D_X", 0.0), 
   d_rotate3D_Z("reg_rotate3D_Z", 0.0),
   d_shearZ("reg_shearZ", 0.0),

   d_autoAlignMode("auto_align_mode", s_autoAlignModeNames[0]),
   d_autoAlignModeList("auto_align_mode_list"),

   d_transformationSource("reg_transformation_source", 
                          s_transformationSourceNames[0]),
   d_transformationSourceList("reg_transformation_source_list"),

   d_imageDisplay(display),
   d_dataset(NULL),
   d_aligner(aligner),
   d_3DImageCMap(NULL),
   d_2DImageCMap(NULL),
   d_last2DImage(NULL),
   d_last3DImage(NULL),
   d_flipXreference(vrpn_FALSE), 
   d_flipYreference(vrpn_FALSE),
   d_flipYadjustable(vrpn_FALSE),
   d_lastTransformTypeSent(NMR_DEFAULT),

   d_colormap2DCallbackDisabled(false)
{
    d_scaledProjImFromScaledTopoIm = 
        new nmb_TransformMatrix44[s_numTransformationSources];

    d_aligner->registerChangeHandler((void *)this, handle_registrationChange);
    d_3DImageCMap = new nmui_ColorMap("reg_surface_cm", 
              &d_registrationImageName3D,
              &d_registrationColorMap3D);
    d_3DImageCMap->setSurfaceColor(255,255,255);
    d_2DImageCMap = new nmui_ColorMap("reg_projection_cm", 
              &d_registrationImageName2D,
              &d_registrationColorMap2D);
    d_2DImageCMap->setSurfaceColor(255,255,255);

    d_numResolutionLevels = s_defaultNumResolutionLevels;
    int i;
    d_resolutionLevelList.clearList();
    char listEntry[128];
    for (i = 0; i < s_defaultNumResolutionLevels; i++) {
      d_stddev[i] = s_defaultStdDev[i];
      sprintf(listEntry, "%g", d_stddev[i]);
      d_resolutionLevelList.addEntry(listEntry);
    }
    d_aligner->setResolutions(d_numResolutionLevels, d_stddev);
    sendTransformationParameters();

    d_autoAlignModeList.clearList();
    for (i = 0; i < s_numAutoAlignModes; i++) {
      d_autoAlignModeList.addEntry(s_autoAlignModeNames[i]);
    }

    d_transformationSourceList.clearList();
    for (i = 0; i < s_numTransformationSources; i++) {
      d_transformationSourceList.addEntry(s_transformationSourceNames[i]);
    }
}

nmr_RegistrationUI::~nmr_RegistrationUI()
{
  delete [] d_scaledProjImFromScaledTopoIm;
}

void nmr_RegistrationUI::setupCallbacks() 
{
    d_autoAlignRequested.addCallback
         (handle_autoAlignRequested_change, (void *)this);
    d_scaleX.addCallback(handle_transformationParameter_change, this);
    d_scaleY.addCallback(handle_transformationParameter_change, this);
    d_translateX.addCallback(handle_transformationParameter_change, this);
    d_translateY.addCallback(handle_transformationParameter_change, this);
	d_translateZ.addCallback(handle_transformationParameter_change, this);
    d_rotate2D_Z.addCallback(handle_transformationParameter_change, this);
    d_rotate3D_X.addCallback(handle_transformationParameter_change, this);
    d_rotate3D_Z.addCallback(handle_transformationParameter_change, this);
    d_shearZ.addCallback(handle_transformationParameter_change, this);
	d_saveRegistrationMarkers.addCallback(handle_saveRegistrationMarkers_change, (void *)this); //new
	d_loadRegistrationMarkers.addCallback(handle_loadRegistrationMarkers_change, (void *)this); //new
	d_pointsReport.addCallback(handle_savePointsReport_change, (void *)this);
    d_calculateErrorReport.addCallback(handle_calculateErrorReport_change, (void *)this);
	d_calculateAveragePointsErrorReport.addCallback(handle_calculateAveragePointsErrorReport_change, (void *)this);
	d_saveReport.addCallback(handle_saveReport_change, (void *)this); //new
	d_runRegistration.addCallback(handle_runRegistration_change, (void *)this); //new
	d_setTopoIntensityThreshold.addCallback(handle_setTopoIntensityThreshold_change, (void *) this);
	d_setProjIntensityThreshold.addCallback(handle_setProjIntensityThreshold_change, (void *) this);
    d_calculatePoints.addCallback(handle_calculatePoints_change, (void *)this); //new
	d_drawTopographyPoints.addCallback(handle_drawTopographyPoints_change, (void *)this); //new
	d_saveTopographyPoints.addCallback(handle_saveTopographyPoints_change, (void *)this); //new
	d_drawProjectionPoints.addCallback(handle_drawProjectionPoints_change, (void *)this); //new
	d_saveProjectionPoints.addCallback(handle_saveProjectionPoints_change, (void *)this); //new
	d_runDrawRegistration.addCallback(handle_runDrawRegistration_change, (void *)this); //new

    d_registrationEnabled.addCallback
         (handle_registrationEnabled_change, (void *)this);
    d_textureDisplayEnabled.addCallback
         (handle_textureDisplayEnabled_change, (void *)this);
    d_textureAlpha.addCallback
         (handle_textureAlpha_change, (void *)this);
    d_newResampleImageName.addCallback
         (handle_resampleImageName_change, (void *)this);
    d_newResamplePlaneName.addCallback
         (handle_resamplePlaneName_change, (void *)this);

    d_registrationImageName3D.addCallback
       (handle_registrationImage3D_change, (void *)this);
	d_refresh3D.addCallback
		(handle_refresh3D_change, (void *)this);
	d_fiducialSpotTracker3D.addCallback
		(handle_fiducialSpotTracker3D_change, (void *) this);
	d_optimizeSpotTrackerRadius3D.addCallback
		(handle_optimizeSpotTrackerRadius3D_change, (void *) this);
	d_spotTrackerRadius3D.addCallback
		(handle_spotTrackerRadius3D_change, (void *) this);
	d_spotTrackerRadiusAccuracy3D.addCallback
		(handle_spotTrackerRadiusAccuracy3D_change, (void *) this);
	d_spotTrackerPixelAccuracy3D.addCallback
		(handle_spotTrackerPixelAccuracy3D_change, (void *) this);
    d_registrationImageName2D.addCallback
       (handle_registrationImage2D_change, (void *)this);
	d_refresh2D.addCallback
		(handle_refresh2D_change, (void *)this);
	d_fiducialSpotTracker2D.addCallback
		(handle_fiducialSpotTracker2D_change, (void *)this);
	d_optimizeSpotTrackerRadius2D.addCallback
		(handle_optimizeSpotTrackerRadius2D_change, (void *) this);
	d_spotTrackerRadius2D.addCallback
		(handle_spotTrackerRadius2D_change, (void *) this);
	d_spotTrackerRadiusAccuracy2D.addCallback
		(handle_spotTrackerRadiusAccuracy2D_change, (void *) this);
	d_spotTrackerPixelAccuracy2D.addCallback
		(handle_spotTrackerPixelAccuracy2D_change, (void *) this);

	d_flipProjectionImageInX.addCallback
       (handle_flipProjectionImageInX_change, (void *)this);

    d_registrationColorMap3D.addCallback
       (handle_registrationColorMap3D_change, (void *)this);
    d_registrationColorMap2D.addCallback
       (handle_registrationColorMap2D_change, (void *)this);

    d_3DImageCMap->addMinMaxCallback(handle_registrationMinMax3D_change, this);
    d_2DImageCMap->addMinMaxCallback(handle_registrationMinMax2D_change, this);
    d_transformationSource.addCallback
       (handle_textureTransformMode_change, (void *)this);

}

void nmr_RegistrationUI::teardownCallbacks() 
{
    d_autoAlignRequested.removeCallback
         (handle_autoAlignRequested_change, (void *)this);
    d_scaleX.removeCallback(handle_transformationParameter_change, this);
    d_scaleY.removeCallback(handle_transformationParameter_change, this);
    d_translateX.removeCallback(handle_transformationParameter_change, this);
    d_translateY.removeCallback(handle_transformationParameter_change, this);
	d_translateZ.removeCallback(handle_transformationParameter_change, this);
    d_rotate2D_Z.removeCallback(handle_transformationParameter_change, this);
    d_rotate3D_X.removeCallback(handle_transformationParameter_change, this);
    d_rotate3D_Z.removeCallback(handle_transformationParameter_change, this);
    d_shearZ.removeCallback(handle_transformationParameter_change, this);
	d_pointsReport.removeCallback(handle_savePointsReport_change, (void *)this);
    d_calculateErrorReport.removeCallback(handle_calculateErrorReport_change, (void *)this);
	d_calculateAveragePointsErrorReport.removeCallback(handle_calculateAveragePointsErrorReport_change, (void *)this);
	d_saveRegistrationMarkers.removeCallback(handle_saveRegistrationMarkers_change, (void *)this); //new
	d_loadRegistrationMarkers.removeCallback(handle_loadRegistrationMarkers_change, (void *)this); //new		
	d_saveReport.removeCallback(handle_saveReport_change, (void *)this); //new
	d_runRegistration.removeCallback(handle_runRegistration_change, (void *)this); //new
	d_setTopoIntensityThreshold.removeCallback(handle_setTopoIntensityThreshold_change, (void *) this);
	d_setProjIntensityThreshold.removeCallback(handle_setProjIntensityThreshold_change, (void *) this);
    d_calculatePoints.removeCallback(handle_calculatePoints_change, (void *)this); //new
	d_drawTopographyPoints.removeCallback(handle_drawTopographyPoints_change, (void *)this); //new
	d_saveTopographyPoints.removeCallback(handle_saveTopographyPoints_change, (void *)this); //new
	d_drawProjectionPoints.removeCallback(handle_drawProjectionPoints_change, (void *)this); //new
	d_saveProjectionPoints.removeCallback(handle_saveProjectionPoints_change, (void *)this); //new
	d_runDrawRegistration.removeCallback(handle_runDrawRegistration_change, (void *)this); //new

    d_registrationEnabled.removeCallback
         (handle_registrationEnabled_change, (void *)this);
    d_textureDisplayEnabled.removeCallback
         (handle_textureDisplayEnabled_change, (void *)this);
    d_textureAlpha.removeCallback
         (handle_textureAlpha_change, (void *)this);
    d_newResampleImageName.removeCallback
         (handle_resampleImageName_change, (void *)this);
    d_newResamplePlaneName.removeCallback
         (handle_resamplePlaneName_change, (void *)this);

    d_registrationImageName3D.removeCallback
       (handle_registrationImage3D_change, (void *)this);
	d_refresh3D.removeCallback
		(handle_refresh3D_change, (void *)this);
	d_fiducialSpotTracker3D.removeCallback
		(handle_fiducialSpotTracker3D_change, (void *)this);
    d_optimizeSpotTrackerRadius3D.removeCallback
        (handle_optimizeSpotTrackerRadius3D_change, (void *)this);
    d_spotTrackerRadius3D.removeCallback
        (handle_spotTrackerRadius3D_change, (void *)this);
    d_spotTrackerRadiusAccuracy3D.removeCallback
        (handle_spotTrackerRadiusAccuracy3D_change, (void *)this);
    d_spotTrackerPixelAccuracy3D.removeCallback
		(handle_spotTrackerPixelAccuracy3D_change, (void *)this);
    d_registrationImageName2D.removeCallback
       (handle_registrationImage2D_change, (void *)this);
	d_refresh2D.removeCallback
		(handle_refresh2D_change, (void *)this);
	d_fiducialSpotTracker2D.removeCallback
		(handle_fiducialSpotTracker2D_change, (void *)this);
    d_optimizeSpotTrackerRadius2D.removeCallback
		(handle_optimizeSpotTrackerRadius2D_change, (void *) this);
	d_spotTrackerRadius2D.removeCallback
		(handle_spotTrackerRadius2D_change, (void *) this);
	d_spotTrackerRadiusAccuracy2D.removeCallback
		(handle_spotTrackerRadiusAccuracy2D_change, (void *) this);
	d_spotTrackerPixelAccuracy2D.removeCallback
		(handle_spotTrackerPixelAccuracy2D_change, (void *) this);

    d_registrationColorMap3D.removeCallback
       (handle_registrationColorMap3D_change, (void *)this);
    d_registrationColorMap2D.removeCallback
       (handle_registrationColorMap2D_change, (void *)this);

    d_3DImageCMap->removeMinMaxCallback(handle_registrationMinMax3D_change, this);
    d_2DImageCMap->removeMinMaxCallback(handle_registrationMinMax2D_change, this);
    d_transformationSource.removeCallback
        (handle_textureTransformMode_change, (void *)this);
}

void nmr_RegistrationUI::changeDataset(nmb_ImageManager *dataset)
{
  d_dataset = dataset;
}

void nmr_RegistrationUI::handleRegistrationChange
          (const nmr_ProxyChangeHandlerData &info)
{

  switch(info.msg_type) {
    case NMR_IMAGE_PARAM:
      nmr_ImageType which_image;
      vrpn_int32 res_x, res_y;
      vrpn_float32 size_x, size_y;
      vrpn_bool flip_x, flip_y;
      d_aligner->getImageParameters(which_image, res_x, res_y, 
                                    size_x, size_y, flip_x, flip_y);
      break;
    case NMR_TRANSFORM_OPTION:
      nmr_TransformationType xform_type;
      d_aligner->getTransformationOptions(xform_type);
      break;
    case NMR_REG_RESULT:
      //printf("got transformation");
      /* *******************************************************************
         Store the raw result from the registration code and update graphics
         if necessary
       * *******************************************************************/
      double scaledProjImFromScaledTopoIm_matrix[16];
      vrpn_int32 whichTransform = 0;
      d_aligner->getRegistrationResult(whichTransform,
                                       scaledProjImFromScaledTopoIm_matrix);
      int displayedTransformIndex = getDisplayedTransformIndex();
      int sentTransformIndex =
                convertTransformSourceTypeToTransformIndex(whichTransform);
      d_scaledProjImFromScaledTopoIm[sentTransformIndex].setMatrix(
              scaledProjImFromScaledTopoIm_matrix);
     
      //printf(", type=%d\n", whichTransform);
      //d_scaledProjImFromScaledTopoIm[sentTransformIndex].print(); 
      if (displayedTransformIndex == sentTransformIndex) {
        // compose the new transformation with some others and send the
        // result off to the graphics code
        updateTextureTransform();
      }
      switch (whichTransform) {
        case NMR_MANUAL:
		  d_lastTransformTypeSent = NMR_MANUAL;
          setAutoAlignMode(NMR_AUTOALIGN_FROM_MANUAL);
          setTransformationSource(NMR_MANUAL);
          break;
        case NMR_DEFAULT:
		  d_lastTransformTypeSent = NMR_DEFAULT;
          //setAutoAlignMode(NMR_AUTOALIGN_FROM_DEFAULT);
          //setTransformationSource(NMR_DEFAULT);
          break;
        case NMR_AUTOMATIC:
		  d_lastTransformTypeSent = NMR_AUTOMATIC;
          setTransformationSource(NMR_AUTOMATIC);
          setAutoAlignMode(NMR_AUTOALIGN_FROM_AUTO);
          break;
      }
      break;
  }
}

void nmr_RegistrationUI::updateTextureTransform()
{
  if (!d_imageDisplay) return;

  // we know d_scaledProjImFromScaledTopoIm and we want to get
  // projImFromTopoWorld
  nmb_TransformMatrix44 projImFromTopoWorld;

  // first we lookup the images that this transformation applies to and
  // get from them the additional transformations we need to compose
  if (!d_dataset) return;

  nmb_Image *topographyImage = d_dataset->dataImages()->getImageByName
                      (d_registrationImageName3D.string());
  nmb_Image *projectionImage = d_dataset->dataImages()->getImageByName
                      (d_registrationImageName2D.string());
  if (!topographyImage || !projectionImage) {
     fprintf(stderr, "updateTextureTransform: can't find image\n");
     return;
  }
  nmb_TransformMatrix44 projImFromScaledProjIm, scaledTopoImFromTopoWorld;

  projectionImage->getScaledImageToImageTransform(
                                      projImFromScaledProjIm);

  topographyImage->getWorldToScaledImageTransform(
                                      scaledTopoImFromTopoWorld);

  /* ****************************************************************
     ProjImFromTopoWorld = ProjImFromScaledProjIm *
                           ScaledProjImFromScaledTopoImage *
                           ScaledTopoImageFromTopoWorld
   * ****************************************************************/
  projImFromTopoWorld = projImFromScaledProjIm;
  int displayedTransformIndex = getDisplayedTransformIndex();
  projImFromTopoWorld.compose(
                   d_scaledProjImFromScaledTopoIm[displayedTransformIndex]);
  projImFromTopoWorld.compose(scaledTopoImFromTopoWorld);

  double projImFromTopoWorld_matrix[16];
  // send the transformation to the graphics code
  projImFromTopoWorld.getMatrix(projImFromTopoWorld_matrix);

  bool transformIsSelfReferential =
		(strcmp(d_registrationImageName2D, d_registrationImageName3D) == 0);
  d_imageDisplay->updateDisplayTransform(projectionImage, 
                                         projImFromTopoWorld_matrix,
										 transformIsSelfReferential);
}

int nmr_RegistrationUI::getDisplayedTransformIndex()
{
  int i;
  for (i = 0; i < s_numTransformationSources; i++) {
    if (strcmp(s_transformationSourceNames[i],
                   d_transformationSource.string()) == 0) {
       return i;
    }
  }
  fprintf(stderr, "getCurrentTransformIndex: Error, not found\n");
  return 0;
}

int nmr_RegistrationUI::convertTransformSourceTypeToTransformIndex(int type)
{
  int i;
  for (i = 0; i < s_numTransformationSources; i++) {
    if (type == s_transformationSources[i]) {
       return i;
    }
  }
  fprintf(stderr, "convertTransformSourceTypeToTransformIndex: "
                  "Error, not found\n");
  return 0;
}

// static
void nmr_RegistrationUI::handle_registrationChange
          (void *ud, const nmr_ProxyChangeHandlerData &info)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->handleRegistrationChange(info);
}

// static 
void nmr_RegistrationUI::handle_resampleImageName_change(const char *name, 
                                                         void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->createResampleImage(name);

}

// static 
void nmr_RegistrationUI::handle_resamplePlaneName_change(const char *name, 
                                                         void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->createResamplePlane(name);

}

// static
void nmr_RegistrationUI::handle_registrationImage3D_change(const char *name,
                                                           void *ud)
{
    //printf("nmr_RegistrationUI::handle_registrationImage3D_change\n");
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;

    // Don't do anything if reg window is not open - instead we will
    // be called explicitly in handle_registrationEnabled_change below. 
    if (!me->d_dataset || !me->d_registrationEnabled) return;
    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(name);
    if (!im) {
        fprintf(stderr, "nmr_RegistrationUI::image not found: %s\n", name);
        return;
    }
    // If different, send changes. 
    if ( me->d_last3DImage != im) {

        // send image off to the proxy
        me->d_aligner->setImage(NMR_SOURCE, im, me->d_flipXreference, 
			me->d_flipYreference);
        // We have a choice, and I'm not sure which is right. Either
        // Set the new image to use the existing colormap params:
        double dmin,dmax,cmin,cmax;
        me->d_3DImageCMap->getDataColorMinMax(&dmin, &dmax, &cmin, &cmax);
        me->d_3DImageCMap->setColorMinMaxLimit(0,1);
        me->d_aligner->setColorMinMax(NMR_SOURCE, dmin, dmax, cmin, cmax);
        // Or reset the colormap params to their default:
        //me->d_3DImageCMap->setColorMinMaxLimit(0,1);
        me->d_last3DImage = im;
        if (me->d_last2DImage && me->d_lastTransformTypeSent != NMR_DEFAULT) {
          //me->updateTextureTransform();
        }
    }
}

//static 
void nmr_RegistrationUI::handle_refresh3D_change(vrpn_int32 value, void *ud)
{
	nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    if (value && me->d_last3DImage ) {

        // send image off to the proxy
        me->d_aligner->setImage(NMR_SOURCE, me->d_last3DImage, 
			me->d_flipXreference, 
			me->d_flipYreference);
	}
}

// static
void nmr_RegistrationUI::handle_fiducialSpotTracker3D_change(const char *name, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    nmr_FiducialSpotTracker tracker = me->getFiducialSpotTrackerByName(name);
    me->d_aligner->setFiducialSpotTracker(NMR_SOURCE, tracker);
}

// static
void nmr_RegistrationUI::handle_optimizeSpotTrackerRadius3D_change(vrpn_int32 enable, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setOptimizeSpotTrackerRadius(NMR_SOURCE, enable ? vrpn_TRUE : vrpn_FALSE);
}

// static
void nmr_RegistrationUI::handle_spotTrackerRadius3D_change(vrpn_float64 radius, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerRadius(NMR_SOURCE, radius);
}

// static
void nmr_RegistrationUI::handle_spotTrackerRadiusAccuracy3D_change(vrpn_float64 accuracy, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerRadiusAccuracy(NMR_SOURCE, accuracy);
}

// static
void nmr_RegistrationUI::handle_spotTrackerPixelAccuracy3D_change(vrpn_float64 accuracy, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerPixelAccuracy(NMR_SOURCE, accuracy);
}

// static
void nmr_RegistrationUI::handle_fiducialSpotTracker2D_change(const char *name, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    nmr_FiducialSpotTracker tracker = me->getFiducialSpotTrackerByName(name);
    me->d_aligner->setFiducialSpotTracker(NMR_TARGET, tracker);
}

// static
void nmr_RegistrationUI::handle_optimizeSpotTrackerRadius2D_change(vrpn_int32 enable, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setOptimizeSpotTrackerRadius(NMR_TARGET, enable ? vrpn_TRUE : vrpn_FALSE);
}

// static
void nmr_RegistrationUI::handle_spotTrackerRadius2D_change(vrpn_float64 radius, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerRadius(NMR_TARGET, radius);
}

// static
void nmr_RegistrationUI::handle_spotTrackerRadiusAccuracy2D_change(vrpn_float64 accuracy, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerRadiusAccuracy(NMR_TARGET, accuracy);
}

// static
void nmr_RegistrationUI::handle_spotTrackerPixelAccuracy2D_change(vrpn_float64 accuracy, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    me->d_aligner->setSpotTrackerPixelAccuracy(NMR_TARGET, accuracy);
}

// static
void nmr_RegistrationUI::handle_registrationImage2D_change(const char *name,
                                                           void *ud)
{
    //printf("nmr_RegistrationUI::handle_registrationImage2D_change\n");
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;

    // Don't do anything if reg window is not open - instead we will
    // be called explicitly in handle_registrationEnabled_change below. 
    if (!me->d_dataset || !me->d_registrationEnabled) return;
    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(name);
    if (!im) {
        fprintf(stderr, "nmr_RegistrationUI::image not found: %s\n", name);
        return;
    }

    // If different, send changes. 
    if ( me->d_last2DImage != im) {
        // send image off to the proxy
        me->d_aligner->setImage(NMR_TARGET, im, me->d_flipProjectionImageInX, 
			me->d_flipYadjustable);
        
        // We have a choice, and I'm not sure which is right. Either
        // Set the new image to use the existing colormap params:
        double dmin,dmax,cmin,cmax;
        me->d_2DImageCMap->getDataColorMinMax(&dmin, &dmax, &cmin, &cmax);

		me->d_colormap2DCallbackDisabled = true;
        me->d_2DImageCMap->setColorMinMaxLimit(0,1);
		me->d_colormap2DCallbackDisabled = false;
		me->handle_registrationMinMax2D_change(0, me);

        me->d_aligner->setColorMinMax(NMR_TARGET, dmin, dmax, cmin, cmax);
        // Or reset the colormap params to their default:
        //me->d_2DImageCMap->setColorMinMaxLimit(0,1);
 
        me->d_last2DImage = im;
       
        if (me->d_imageDisplay && me->d_textureDisplayEnabled) {
          // set up texture in graphics
          if (im) {
            me->d_imageDisplay->setDisplayColorMap(im,
                  me->d_2DImageCMap->getColorMapName(), "");
            me->d_imageDisplay->setDisplayColorMapRange(im,
                                                          dmin, dmax, 
                                                          cmin,cmax);
            me->d_imageDisplay->addImageToDisplay(im);
            me->d_imageDisplay->updateImage(im);
          }

          if (me->d_last3DImage && me->d_lastTransformTypeSent != NMR_DEFAULT) {
            me->updateTextureTransform();
          }
        }
    }
}

//static 
void nmr_RegistrationUI::handle_refresh2D_change(vrpn_int32 value, void *ud)
{
	nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
	if (value && me->d_last2DImage ) {
        // send image off to the proxy
        me->d_aligner->setImage(NMR_TARGET, me->d_last2DImage, 
			me->d_flipProjectionImageInX, 
			me->d_flipYadjustable);
	}
}

void nmr_RegistrationUI::handle_flipProjectionImageInX_change(vrpn_int32 value, void *ud)
{
	nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
	if (me->d_last2DImage) {
		me->d_aligner->setImage(NMR_TARGET, me->d_last2DImage, me->d_flipProjectionImageInX, 
			me->d_flipYadjustable);
	}
}

// static
void nmr_RegistrationUI::handle_registrationColorMap3D_change(const char *name,
                                                           void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    nmb_ColorMap * cmap =  me->d_3DImageCMap->currentColorMap();
    if (!cmap) {
        fprintf(stderr, "nmr_RegistrationUI::colormap not found: %s\n", name);
        return;
    }
    // send changes off to the proxy
    me->d_aligner->setColorMap(NMR_SOURCE, cmap);
}

// static
void nmr_RegistrationUI::handle_registrationColorMap2D_change(const char *name,
                                                           void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    nmb_ColorMap * cmap =  me->d_2DImageCMap->currentColorMap();
    if (!cmap) {
        fprintf(stderr, "nmr_RegistrationUI::colormap not found: %s\n", name);
        return;
    }
    // send changes off to the proxy
    me->d_aligner->setColorMap(NMR_TARGET, cmap);

    if (!me->d_dataset) return;
    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(
                                me->d_registrationImageName2D.string());

    if (me->d_imageDisplay) {
      me->d_imageDisplay->setDisplayColorMap(im, 
          me->d_2DImageCMap->getColorMapName(), "");
      if(im) me->d_imageDisplay->updateImage(im);
    }

}

//static 
void nmr_RegistrationUI::handle_registrationMinMax3D_change(vrpn_float64, void *ud) {
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    double dmin,dmax,cmin,cmax;
    me->d_3DImageCMap->getDataColorMinMax(&dmin, &dmax, &cmin, &cmax);
    // send changes off to the proxy
    me->d_aligner->setColorMinMax(NMR_SOURCE, dmin, dmax, cmin, cmax);

}

//static 
void nmr_RegistrationUI::handle_registrationMinMax2D_change(vrpn_float64, void *ud) {
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
	if (me->d_colormap2DCallbackDisabled) {
		return;
	}
    double dmin,dmax,cmin,cmax;
     me->d_2DImageCMap->getDataColorMinMax(&dmin, &dmax, &cmin, &cmax);
    // send changes off to the proxy
    me->d_aligner->setColorMinMax(NMR_TARGET, dmin, dmax, cmin, cmax);

    if (!me->d_dataset) return;
    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(
                                me->d_registrationImageName2D.string());

    if (me->d_imageDisplay) {
      me->d_imageDisplay->setDisplayColorMapRange(im, dmin, dmax, cmin, cmax);
	  if(im) me->d_imageDisplay->updateImage(im);
    }
}

// static
void nmr_RegistrationUI::handle_textureTransformMode_change(const char *name,
                                                           void *ud)
{
  nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;

  if (me->d_textureDisplayEnabled) {
    me->updateTextureTransform();
  }
}

// static
void nmr_RegistrationUI::handle_textureDisplayEnabled_change(
      vrpn_int32 value, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    if (!(me->d_imageDisplay)) return;

    if (!(me->d_dataset)) return;

    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(
                                me->d_registrationImageName2D.string());
    if (!im) return;

    if (value) {
      // set up texture in graphics
      double dmin=0,dmax=1,cmin=0,cmax=1;
      me->d_imageDisplay->setDisplayColorMap(im,
         me->d_2DImageCMap->getColorMapName(), "");
      me->d_imageDisplay->setDisplayColorMapRange(im, dmin, dmax,
                                                cmin,cmax);
      me->d_imageDisplay->addImageToDisplay(im);
      me->updateTextureTransform();
      me->d_imageDisplay->updateImage(im);
    } 
    else {
      me->d_imageDisplay->removeImageFromDisplay(im);
    }
}

// static
void nmr_RegistrationUI::handle_textureAlpha_change(
      vrpn_float64 alpha, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;

    if (!(me->d_imageDisplay)) return;

    if (!(me->d_dataset)) return;

    nmb_Image *im = me->d_dataset->dataImages()->getImageByName(
                                me->d_registrationImageName2D.string());
    if (!im) return;

    me->d_imageDisplay->updateColorMapTextureAlpha(alpha);
    
    me->d_imageDisplay->updateImage(im);
}

void nmr_RegistrationUI::autoAlignImages()
{
  vrpn_float32 stddev = atof(d_resolutionLevel.string());
  vrpn_int32 levelIndex;
  for (levelIndex = 0; levelIndex < d_numResolutionLevels; levelIndex++) {
    if (stddev == d_stddev[levelIndex]) break;
  }
  if (levelIndex == d_numResolutionLevels) {
    fprintf(stderr, "Error: autoAlignImages: can't find resolution\n");
    return; 
  }

  int modeIndex;
  for (modeIndex = 0; modeIndex < s_numAutoAlignModes; modeIndex++) {
    if (strcmp(d_autoAlignMode.string(), 
               s_autoAlignModeNames[modeIndex]) == 0) {
      break;
    }
  }
  if (modeIndex == s_numAutoAlignModes) {
    fprintf(stderr, "Error: autoAlignImages: can't find mode\n");
    return;
  }
  nmr_AutoAlignMode mode = s_autoAlignModes[modeIndex];

  d_aligner->setIterationLimit((vrpn_int32)d_numIterations);
  d_aligner->setStepSize((vrpn_float32)d_stepSize);
  d_aligner->setCurrentResolution(levelIndex);
  d_aligner->autoAlignImages(mode);
}

void nmr_RegistrationUI::setTransformationSource(nmr_RegistrationType source) 
{
  int i;
  for (i = 0; i < s_numTransformationSources; i++) {
    if (source == s_transformationSources[i]) {
      d_transformationSource = s_transformationSourceNames[i];
    }
  }
}

void nmr_RegistrationUI::setAutoAlignMode(nmr_AutoAlignMode mode)
{
  int i;
  for (i = 0; i < s_numAutoAlignModes; i++) {
    if (mode == s_autoAlignModes[i]) {
      d_autoAlignMode = s_autoAlignModeNames[i];
    }
  }
}

nmr_FiducialSpotTracker nmr_RegistrationUI::getFiducialSpotTrackerByName(const char *trackerName) {
    if (!strcmp(trackerName, "None"))
        return NMR_NO_TRACKER;
    else if (!strcmp(trackerName, "Local Max"))
        return NMR_LOCAL_MAX_TRACKER;
    else if (!strcmp(trackerName, "Cone"))
        return NMR_CONE_TRACKER;
    else if (!strcmp(trackerName, "Disk"))
        return NMR_DISK_TRACKER;
    else if (!strcmp(trackerName, "FIONA"))
        return NMR_FIONA_TRACKER;
    else if (!strcmp(trackerName, "Symmetric"))
        return NMR_SYMMETRIC_TRACKER;
    else {
        fprintf(stderr, 
            "getFiducialSpotTrackerByName encountered unknown tracker name '%s'. Defaulting to Cone Tracker\n", 
            trackerName);
        return NMR_CONE_TRACKER;
    }
}

// static
void nmr_RegistrationUI::handle_autoAlignRequested_change(
      vrpn_int32 value, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    if (value) {
      me->autoAlignImages();
    
      static vrpn_bool first_time = vrpn_TRUE;
      if (first_time) {
        first_time = vrpn_FALSE;
        // some debugging code that inserts the blurred images used for
        // alignment into the image list so you can easily view them:
//         if (!me->d_dataset) return;
//         nmb_Image *im_3D = me->d_dataset->dataImages()->getImageByName
//                             (me->d_registrationImageName3D.string());
//         nmb_Image *im_2D = me->d_dataset->dataImages()->getImageByName
//                             (me->d_registrationImageName2D.string());
//         nmr_AlignerMI aligner;
//         aligner.initImages(im_3D, im_2D, 
//                            me->d_numResolutionLevels, me->d_stddev, 
//                            NULL, me->d_dataset->dataImages());
      }
    }
}

// static
void nmr_RegistrationUI::handle_transformationParameter_change(
      vrpn_float64 /*value*/, void *ud)
{
  nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
  me->sendTransformationParameters();
}

void nmr_RegistrationUI::handle_saveRegistrationMarkers_change(vrpn_int32 value, void *ud) //(vrpn_float64 /*value*/, void *ud)
{
	// If it is static
//	nmr_RegistrationUI *me = dynamic_cast<nmr_RegistrationUI *>(ud);
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	// Check me for NULL

	Correspondence	c;
	int	src, tgt;
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getCorrespondence(c, src, tgt);

	corr_point_t point_topography;
	corr_point_t point_projection;
	unsigned i;

	FILE * pFile;
	pFile = fopen ("registration_markers.txt","w");
 
	//number of markers in an image
	fprintf(pFile,"%d\n", c.numPoints());

	// Topography Image Point
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(src, i, &point_topography);
		fprintf(pFile,"%g %g ", point_topography.x, point_topography.y);
	}
	fprintf(pFile,"\n");

	// Projection Image Point
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(tgt, i, &point_projection);
		fprintf(pFile,"%g %g ", point_projection.x, point_projection.y);
	}
	fprintf(pFile,"\n");

	fclose (pFile);

} //new

void nmr_RegistrationUI::handle_loadRegistrationMarkers_change(vrpn_int32 value, void *ud) //(vrpn_float64 /*value*/, void *ud)
{
	float x,y;

	FILE * pFile;
	pFile = fopen ("registration_markers.txt","r");

	if (pFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		rewind (pFile);
		int num;
		fscanf (pFile, "%d", &num);

		if(num <= NMR_MAX_FIDUCIAL)
		{
			vrpn_float32 x_src[NMR_MAX_FIDUCIAL], y_src[NMR_MAX_FIDUCIAL], z_src[NMR_MAX_FIDUCIAL],
				x_tgt[NMR_MAX_FIDUCIAL], y_tgt[NMR_MAX_FIDUCIAL], z_tgt[NMR_MAX_FIDUCIAL];

			vrpn_int32 replace = 1;


			printf ("%d ",num);
			printf ("Topography: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_src[i] = x;
				y_src[i] = y;
				z_src[i] = 0;

				if( i == 0 || i == (num-1))
				{
					printf ("source %d %f %f\n", i, x_src[i], y_src[i]);
				}
			}
			printf ("\n");

			printf ("Projection: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_tgt[i] = x;
				y_tgt[i] = y;
				z_tgt[i] = 0;

				if( i == 0 || i == (num-1))
				{
					printf ("target %d %f %f\n", i, x_tgt[i], y_tgt[i]);
				}
			}
			printf ("\n");

			nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
			me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setFiducial(replace,num,x_src,y_src,z_src,x_tgt,y_tgt,z_tgt);
		}
		else
		{
			printf ("Error: Number of markers in the file is bigger than NMR_MAX_FIDUCIAL\n");
		}
		fclose (pFile);
	}
} //new

void nmr_RegistrationUI::handle_savePointsReport_change(vrpn_int32 value, void *ud)
{
	vector< vector <double> > markersFromSingleImage;
	vector<bool> control_markersFromSingleImage;

	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();

	Correspondence	c;
	int	src, tgt;
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getCorrespondence(c, src, tgt);

	corr_point_t point_topography;
	unsigned i;
 
	// Topography Image Point
	for (i = 0; i < c.numPoints(); i++) 
	{
		c.getPoint(src, i, &point_topography);
		vector <double> temp(2);

		//the image has to be a square one
		temp[0] = point_topography.x*(wh[0][0]-1.0);
		temp[1] = point_topography.y*(wh[0][0]-1.0);
		markersFromSingleImage.push_back(temp);
		control_markersFromSingleImage.push_back(false);
	}

	markersForReport.push_back(markersFromSingleImage);
	control_markersForReport.push_back(control_markersFromSingleImage);
}

void nmr_RegistrationUI::handle_calculateErrorReport_change(vrpn_int32 value, void *ud)
{
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	FILE * pFile;
	pFile = fopen ("calculateError.txt","w");
 
	//number of markers in an image
	fprintf(pFile,"number of images: %d\n", markersForReport.size());

	// Topography Image Point
	for(int imnum = 0; imnum < markersForReport.size(); imnum++)
	{
		fprintf(pFile,"image number: %d\n", imnum);
		for (int i = 0; i < markersForReport[imnum].size(); i++) 
		{
			fprintf(pFile,"%g %g ", markersForReport[imnum][i][0], markersForReport[imnum][i][1]);
		}
		fprintf(pFile,"\n\n");
	}

	for(int left_i = 0; left_i < markersForReport.size(); left_i++)
	{
		for(int left_j = 0; left_j < markersForReport[left_i].size(); left_j++)
		{
			if(control_markersForReport[left_i][left_j] == false)
			{
				control_markersForReport[left_i][left_j] = true;
				vector< vector <double> > temp;
				temp.push_back(markersForReport[left_i][left_j]);

				for(int right_i = left_i+1 ; right_i < markersForReport.size(); right_i++)
				{
					for(int right_j = 0; right_j < markersForReport[right_i].size(); right_j++)
					{
						if(control_markersForReport[right_i][right_j] == false)
						{
							double dist =  sqrt(pow((markersForReport[left_i][left_j][0] - markersForReport[right_i][right_j][0]),2) + pow((markersForReport[left_i][left_j][1] - markersForReport[right_i][right_j][1]),2));
							if(dist <= 5)
							{
								control_markersForReport[right_i][right_j] = true;
								temp.push_back(markersForReport[right_i][right_j]);
							}
						}
					}
				}
				orderedMarkers.push_back(temp);
			}
		}
	}

	fprintf(pFile,"\n\n");

	double sum_stddev = 0;
	vector<double> standard_dev(orderedMarkers.size());

	for(int i = 0; i < orderedMarkers.size(); i++)
	{
		double sum_x = 0;
		double sum_y = 0;

		for(int j = 0; j < orderedMarkers[i].size(); j++)
		{
			sum_x += orderedMarkers[i][j][0];
			sum_y += orderedMarkers[i][j][1];
		}

		double avg_x = sum_x/double(orderedMarkers[i].size());
		double avg_y = sum_y/double(orderedMarkers[i].size());

		double sumsqdiff_x = 0;
		double sumsqdiff_y = 0;

		for(int m = 0; m < orderedMarkers[i].size(); m++)
		{
			sumsqdiff_x += pow((orderedMarkers[i][m][0] - avg_x),2);
			sumsqdiff_y += pow((orderedMarkers[i][m][1] - avg_y),2);
		}

		double std_dev_x = sqrt(sumsqdiff_x/double(orderedMarkers[i].size()));
		double std_dev_y = sqrt(sumsqdiff_y/double(orderedMarkers[i].size()));

		double xy_std_dev = sqrt(pow(std_dev_x,2) + pow(std_dev_y,2));
		standard_dev[i] = xy_std_dev;
		sum_stddev += xy_std_dev;
	}


	double sum_std_error = 0; 

	//changing std deviations to into std errors
	for(int i = 0; i < orderedMarkers.size(); i++)
	{
		double std_error = standard_dev[i]/sqrt(double(orderedMarkers[i].size()));
		fprintf(pFile,"std_error %d: %f \n", i, std_error);
		sum_std_error += std_error;
	}

	//calculating the average of standard errors
	double avg_std_err = sum_std_error/orderedMarkers.size();

	fprintf(pFile,"\n average of standard errors : %f \n", avg_std_err);

	fclose (pFile);

}

void nmr_RegistrationUI::handle_calculateAveragePointsErrorReport_change(vrpn_int32 value, void *ud)
{	
	// If it is static
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	Correspondence	c;
	int	src, tgt;
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getCorrespondence(c, src, tgt);

	corr_point_t point_topography;

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();

	FILE * pFile;
	pFile = fopen ("averageImage_ErrorReport.txt","w");
 
	double camera_offset = 10;
	double EM_gain = 80;
	double analog_gain = 5;

	double full_well_capacity = 370000;
	double max_grayscale_value = 255;
	double gain_conversion_factor = full_well_capacity / (max_grayscale_value - camera_offset);

	double pixel_size = 66.7; //nanometers
	double background_value = 9.285; // 8bit greyscale

	vector<double> standard_error(c.numPoints());
	vector<double> gaussian_radius;

	FILE * radiusFile;
	radiusFile = fopen ("radii.txt","r");

	if (radiusFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		float r;
		rewind (radiusFile);

		int num;
		fscanf (radiusFile, "%d", &num);
		printf ("RadiusFile: %d\n", num);

		for(int i = 0; i<num; i++)
		{
			fscanf (radiusFile, "%f", &r);
			std::cout<<"RadiusFile: "<<r<<endl;
			gaussian_radius.push_back(r*pixel_size);
		}
	}
	fclose (radiusFile);

	double sum_std = 0;

	// Topography Image Point
	for (int i = 0; i < c.numPoints(); i++) 
	{
		c.getPoint(src, i, &point_topography);

		cout<<point_topography.x<<" "<<point_topography.y;
		double grayscale_value = (me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getIntensityValue(int(point_topography.x*(wh[0][0]-1.0)),int(point_topography.y*(wh[0][0]-1.0))))*255;
		cout<<" grayscale_value: "<<grayscale_value<<endl;

		double photon_count = (grayscale_value - camera_offset) * gain_conversion_factor / (EM_gain * analog_gain);

		//!!!!change the background value to photon units!!!!
		standard_error[i] = sqrt( pow(gaussian_radius[i],2) / photon_count);
		sum_std += standard_error[i];
		fprintf(pFile,"%f \n", standard_error[i]);
	}
	fprintf(pFile,"\n");

	double avg_std = sum_std/c.numPoints();

	//calculating the average of standard errors
	fprintf(pFile,"average of std errors : %f \n", avg_std);

	fclose (pFile);
}

void nmr_RegistrationUI::handle_saveReport_change(vrpn_int32 value, void *ud) //(vrpn_float64 /*value*/, void *ud)
{
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	FILE * pFile;
	pFile = fopen ("methods section.txt","w");
 
	fprintf(pFile,"rms error between images: %f\n", me->d_aligner->get_d_local_impl()->get_rmsError());

	fclose (pFile);
}

void matrixMultiplication(double resultMatrix[6][6], double leftMatrix[6][6], double rightMatrix[6][6])
{
    for ( int r = 0; r < 6; r++ )
    {
	   for ( int c = 0; c < 6; c++ )
	   {
		  for ( int i = 0; i < 6; i++ )
		  {
			  resultMatrix[r][c] +=  leftMatrix[r][i] * rightMatrix[i][c];
		  }
	  }
	}
}

// static
void nmr_RegistrationUI::handle_setTopoIntensityThreshold_change(vrpn_float64 intensity, void *ud)
{
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setTopoIntensityThreshold(intensity);
}

void nmr_RegistrationUI::handle_setProjIntensityThreshold_change(vrpn_float64 intensity, void *ud)
{
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setProjIntensityThreshold(intensity);
}

void nmr_RegistrationUI::handle_calculatePoints_change(vrpn_int32 value, void *ud) //(vrpn_float64 /*value*/, void *ud)
{

	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	vector< vector< vector <float> > > rawRansac = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->readPixels();

#if(0)
	float x,y;

	FILE * pFile;
	pFile = fopen ("output/ransac_markers.txt","r");

	if (pFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		rewind (pFile);
		int num;
		fscanf (pFile, "%d", &num);

		if(num <= NMR_MAX_FIDUCIAL)
		{
			vrpn_float32 x_src[NMR_MAX_FIDUCIAL], y_src[NMR_MAX_FIDUCIAL], z_src[NMR_MAX_FIDUCIAL],
				x_tgt[NMR_MAX_FIDUCIAL], y_tgt[NMR_MAX_FIDUCIAL], z_tgt[NMR_MAX_FIDUCIAL];

			vrpn_int32 replace = 1;


			printf ("%d ",num);
			printf ("Topography: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_src[i] = x;
				y_src[i] = y;
				z_src[i] = 0;
		//		printf ( "%f %f ", x, y);
				if( i == 0 || i == (num-1))
				{
					printf ("source %d %f %f\n", i, x_src[i], y_src[i]);
				}
			}
			printf ("\n");

			printf ("Projection: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_tgt[i] = x;
				y_tgt[i] = y;
				z_tgt[i] = 0;
		//		printf ( "%f %f ", x, y);
				if( i == 0 || i == (num-1))
				{
					printf ("target %d %f %f\n", i, x_tgt[i], y_tgt[i]);
				}
			}
			printf ("\n");

			nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
			me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setFiducial(replace,num,x_src,y_src,z_src,x_tgt,y_tgt,z_tgt);
		}
		else
		{
			printf ("Error: Number of markers in the file is bigger than NMR_MAX_FIDUCIAL\n");
		}
		fclose (pFile);
	}
#endif
}


void nmr_RegistrationUI::handle_drawTopographyPoints_change(vrpn_int32 value, void *ud)
{
	float x,y;

	FILE * pFile;
	pFile = fopen ("ransac_points_topography.txt","r");

	if (pFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		rewind (pFile);
		int width;
		int height;
		fscanf (pFile, "%d", &width);
		fscanf (pFile, "%d", &height);

		vrpn_float32 x_src[NMR_MAX_FIDUCIAL], y_src[NMR_MAX_FIDUCIAL], z_src[NMR_MAX_FIDUCIAL],
			x_tgt[NMR_MAX_FIDUCIAL], y_tgt[NMR_MAX_FIDUCIAL], z_tgt[NMR_MAX_FIDUCIAL];

		vrpn_int32 replace = 1;

		printf ("handle_drawTopographyPoints_change: ");

		int i = 0;
		for(; !feof(pFile); i++)
		{
			fscanf (pFile, "%f %f", &x, &y);
//			x_src[i] = x/(width-1);
//			y_src[i] = y/(height-1);
			x_src[i] = x;
			y_src[i] = y;
			z_src[i] = 0;

			x_tgt[i] = -1;
			y_tgt[i] = -1;
			z_tgt[i] = -1;

			if( i == 0)
			{
				printf ("source %d %f %f\n", i, x_src[i], y_src[i]);
			}
		}
		printf ("\n");

		printf ("LAST source %d %f %f\n", i-1, x_src[i-1], y_src[i-1]);

		if(i < NMR_MAX_FIDUCIAL)
		{
			nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
			me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setFiducial(replace,(i-1),x_src,y_src,z_src,x_tgt,y_tgt,z_tgt);
		}
		else
		{
			printf ("Error: Number of markers in the file is bigger than NMR_MAX_FIDUCIAL\n");
		}
		fclose (pFile);
	}
}

void nmr_RegistrationUI::handle_saveTopographyPoints_change(vrpn_int32 value, void *ud)
{
	// If it is static
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	// Check me for NULL

	Correspondence	c;
	int	src, tgt;
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getCorrespondence(c, src, tgt);

	corr_point_t point_topography;
	unsigned i;

	FILE * pFile;
	pFile = fopen ("processed_ransac_topography.txt","w");
 
	//number of markers in an image
	fprintf(pFile,"%d\n", c.numPoints());

	// Topography Image Point
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(src, i, &point_topography);
		fprintf(pFile,"%g %g ", point_topography.x, point_topography.y);
	}
	fprintf(pFile,"\n");

	fclose (pFile);

	FILE * IngridFile;
	IngridFile = fopen ("Ingrid_Topography.txt","w");
 
	//number of markers in an image
	fprintf(IngridFile,"%d\n", c.numPoints());

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(src, i, &point_topography);
		fprintf(IngridFile,"%d %g %g\n", i, point_topography.x*(wh[0][0]-1.0), point_topography.y*(wh[0][0]-1.0));
	}
	fprintf(IngridFile,"\n");

	fclose (IngridFile);
}

void nmr_RegistrationUI::handle_drawProjectionPoints_change(vrpn_int32 value, void *ud)
{
	float x,y;

	FILE * pFile;
	pFile = fopen ("ransac_points_projection.txt","r");

	if (pFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		rewind (pFile);
		int width;
		int height;
		fscanf (pFile, "%d", &width);
		fscanf (pFile, "%d", &height);

		vrpn_float32 x_src[NMR_MAX_FIDUCIAL], y_src[NMR_MAX_FIDUCIAL], z_src[NMR_MAX_FIDUCIAL],
			x_tgt[NMR_MAX_FIDUCIAL], y_tgt[NMR_MAX_FIDUCIAL], z_tgt[NMR_MAX_FIDUCIAL];

		vrpn_int32 replace = 1;

		printf ("handle_drawProjectionPoints_change: ");

		int i = 0;
		for(; !feof(pFile); i++)
		{
			fscanf (pFile, "%f %f", &x, &y);
			x_src[i] = -1;
			y_src[i] = -1;
			z_src[i] = -1;

			x_tgt[i] = x;
			y_tgt[i] = y;
			z_tgt[i] = 0;

			if( i == 0)
			{
				printf ("target %d %f %f\n", i, x_tgt[i], y_tgt[i]);
			}
		}
		printf ("\n");

		printf ("LAST target %d %f %f\n", i-1, x_tgt[i-1], y_tgt[i-1]);

		if(i < NMR_MAX_FIDUCIAL)
		{
			nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
			me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setFiducial(replace,(i-1),x_src,y_src,z_src,x_tgt,y_tgt,z_tgt);
		}
		else
		{
			printf ("Error: Number of markers in the file is bigger than NMR_MAX_FIDUCIAL\n");
		}
		fclose (pFile);
	}
}

void nmr_RegistrationUI::handle_saveProjectionPoints_change(vrpn_int32 value, void *ud)
{
	// If it is static
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
	// Check me for NULL

	Correspondence	c;
	int	src, tgt;
	me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getCorrespondence(c, src, tgt);

	corr_point_t point_projection;
	unsigned i;

	FILE * pFile;
	pFile = fopen ("processed_ransac_projection.txt","w");
 
	//number of markers in an image
	fprintf(pFile,"%d\n", c.numPoints());

	// Projection Image Point
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(tgt, i, &point_projection);
		fprintf(pFile,"%g %g ", point_projection.x, point_projection.y);
	}
	fprintf(pFile,"\n");

	fclose (pFile);

	FILE * IngridFile;
	IngridFile = fopen ("Ingrid_Projection.txt","w");
 
	//number of markers in an image
	fprintf(IngridFile,"%d\n", c.numPoints());

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();
	for (i = 0; i < c.numPoints(); i++) {
		c.getPoint(tgt, i, &point_projection);
		fprintf(IngridFile,"%d %g %g\n", i, point_projection.x*(wh[1][0]-1.0), point_projection.y*(wh[1][0]-1.0));
	}
	fprintf(IngridFile,"\n");

	fclose (IngridFile);
}

void nmr_RegistrationUI::handle_runRegistration_change(vrpn_int32 value, void *ud)
{
	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();

#if(1)
	vector< vector< vector <double> > > rawRansac;
	
	FILE * processedTopoFile;
	processedTopoFile = fopen ("processed_ransac_topography.txt","r");

	vector< vector <double> > topo_rawRansac;

	if (processedTopoFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		float x,y;
		rewind (processedTopoFile);
		int num;
		fscanf (processedTopoFile, "%d", &num);

		for(int i = 0; i<num; i++)
		{
			fscanf (processedTopoFile, "%f %f", &x, &y);
			vector <double> tempPoint;
			tempPoint.push_back(x*(wh[0][0]-1));
			tempPoint.push_back(y*(wh[0][1]-1));
//			tempPoint.push_back(x);
//			tempPoint.push_back(y);
			topo_rawRansac.push_back(tempPoint);
		}
	}
	fclose (processedTopoFile);


	FILE * processedProjFile;
	processedProjFile = fopen ("processed_ransac_projection.txt","r");

	vector< vector <double> > proj_rawRansac;

	if (processedProjFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		float x,y;
		rewind (processedProjFile);
		int num;
		fscanf (processedProjFile, "%d", &num);

		for(int i = 0; i<num; i++)
		{
			fscanf (processedProjFile, "%f %f", &x, &y);
			vector <double> tempPoint;
			tempPoint.push_back(x*(wh[1][0]-1));
			tempPoint.push_back(y*(wh[1][1]-1));
//			tempPoint.push_back(x);
//			tempPoint.push_back(y);
			proj_rawRansac.push_back(tempPoint);
		}
	}
	fclose (processedProjFile);

	rawRansac.push_back(topo_rawRansac);
	rawRansac.push_back(proj_rawRansac);
#endif

	//rawRansac[a][b][c]
	// a: 0 --> topography; 1 --> projection
	// b: index of a data point
	// c: 0 --> x-coordinate of the point; 1 --> y-coordinate of the point

	//!!different from the regular way, data point coordinates are NOT divided to 511 to keep them between 0-1. 
	//Here, coordinates are between 0-511 (just to be sure they don't go unnoticed (i.e. get too small) during affine transformation).

	vector< vector< double > > distanceMatrixTopography;
	vector< vector< double > > distanceMatrixProjection;

	for(int topo_i = 0; topo_i < rawRansac[0].size(); topo_i++)
	{
		vector<double> line_i;
		for(int topo_j = 0; topo_j < rawRansac[0].size(); topo_j++)
		{
			double dist = sqrt(pow((rawRansac[0][topo_i][0]-rawRansac[0][topo_j][0]),2) + pow((rawRansac[0][topo_i][1]-rawRansac[0][topo_j][1]),2));
			line_i.push_back(dist);
		}
		distanceMatrixTopography.push_back(line_i);
	}

	for(int proj_i = 0; proj_i < rawRansac[1].size(); proj_i++)
	{
		vector<double> line_i;
		for(int proj_j = 0; proj_j < rawRansac[1].size(); proj_j++)
		{
			double dist = sqrt(pow((rawRansac[1][proj_i][0]-rawRansac[1][proj_j][0]),2) + pow((rawRansac[1][proj_i][1]-rawRansac[1][proj_j][1]),2));
			line_i.push_back(dist);
		}
		distanceMatrixProjection.push_back(line_i);
	}

	vector< vector< vector <double> > > closestneighbors_topo;
	vector<double> distanceratio_closestneighbors_topo;

	//closestneighbors_topo[a][b][c]
	// a: index of a triplet (i.e. point "rawRansac[0][a]" with its two closest neighbors)
	// b: index of one of the points in the triplet
	// b: 0--> the point of interest 1-->closest point to the point of interest 2--> second closest to the point of interest
	// c: 0--> x coordinate, 1--> y coordinate

	//distanceratio_closestneighbors_topo[a]
	// a: ratio of "rawRansac[0][a]"s two closest neigbors --> (closest point's distance to "rawRansac[0][a]") / (second closest point's distance to "rawRansac[0][a]") 

	for(int topo_index = 0; topo_index < rawRansac[0].size(); topo_index++)
	{
		vector< vector <double> > triplet;
		vector<double> topo_index_close_1(2,100000); 
		vector<double> topo_index_close_2(2,100000);
		int indexvalue_topo_close_1 = -1; 
		int indexvalue_topo_close_2 = -1;

		double topo_index_close_1_dist = 100000, topo_index_close_2_dist = 100000;

		for(int i = 0; i < rawRansac[0].size(); i++)
		{
			if(topo_index != i)
			{
				double dist = distanceMatrixTopography[i][topo_index];
				if(dist < topo_index_close_1_dist)
				{
					topo_index_close_2 = topo_index_close_1;
					topo_index_close_1 = rawRansac[0][i];

					indexvalue_topo_close_2 = indexvalue_topo_close_1;
					indexvalue_topo_close_1 = i;

					topo_index_close_2_dist = topo_index_close_1_dist;
					topo_index_close_1_dist = dist;
				}
				else if(dist < topo_index_close_2_dist)
				{
					topo_index_close_2 = rawRansac[0][i];

					indexvalue_topo_close_2 = i;

					topo_index_close_2_dist = dist;
				}
			}
		}
		if(topo_index_close_1[0] == 100000 || topo_index_close_1[1] == 100000 ||  topo_index_close_2[0] == 100000 ||  topo_index_close_2[1] == 100000 || indexvalue_topo_close_1 == -1 || indexvalue_topo_close_2 == -1)
		{
			printf("error at handle_runRegistration_change: %d %d\n", topo_index, rawRansac[0].size());
			printf("topo_index_close_1_dist: %f   topo_index_close_2_dist: %f\n", topo_index_close_1_dist, topo_index_close_2_dist);
		}

		triplet.push_back(rawRansac[0][topo_index]);
		triplet.push_back(topo_index_close_1);
		triplet.push_back(topo_index_close_2);
		closestneighbors_topo.push_back(triplet);

		std::cout<<"distanceratio isleri: "<<indexvalue_topo_close_1<<" "<<topo_index<<" "<<indexvalue_topo_close_2<<" "<<topo_index<<endl;
		distanceratio_closestneighbors_topo.push_back(distanceMatrixTopography[indexvalue_topo_close_1][topo_index]/distanceMatrixTopography[indexvalue_topo_close_2][topo_index]);
	}

	
	
	vector< vector< vector <double> > > closestneighbors_proj;
	vector<double> distanceratio_closestneighbors_proj;

	//closestneighbors_proj[a][b][c]
	// a: index of a triplet (i.e. point "rawRansac[1][a]" with its two closest neighbors)
	// b: index of one of the points in the triplet
	// b: 0--> the point of interest 1-->closest point to the point of interest 2--> second closest to the point of interest
	// c: 0--> x coordinate, 1--> y coordinate

	//distanceratio_closestneighbors_proj[a]
	// a: ratio of "rawRansac[1][a]"s two closest neigbors --> (closest point's distance to "rawRansac[1][a]") / (second closest point's distance to "rawRansac[1][a]") 

	for(int proj_index = 0; proj_index < rawRansac[1].size(); proj_index++)
	{
		vector< vector <double> > triplet;
		vector<double> proj_index_close_1(2,100000); 
		vector<double> proj_index_close_2(2,100000);
		int indexvalue_proj_close_1 = -1; 
		int indexvalue_proj_close_2 = -1;

		double proj_index_close_1_dist = 100000, proj_index_close_2_dist = 100000;

		for(int i = 0; i < rawRansac[1].size(); i++)
		{
			if(proj_index != i)
			{
				double dist = distanceMatrixProjection[i][proj_index];
				if(dist < proj_index_close_1_dist)
				{
					proj_index_close_2 = proj_index_close_1;
					proj_index_close_1 = rawRansac[1][i];

					indexvalue_proj_close_2 = indexvalue_proj_close_1;
					indexvalue_proj_close_1 = i;

					proj_index_close_2_dist = proj_index_close_1_dist;
					proj_index_close_1_dist = dist;
				}
				else if(dist < proj_index_close_2_dist)
				{
					proj_index_close_2 = rawRansac[1][i];
					
					indexvalue_proj_close_2 = i;

					proj_index_close_2_dist = dist;
				}
			}
		}
		if(proj_index_close_1[0] == 100000 || proj_index_close_1[1] == 100000 ||  proj_index_close_2[0] == 100000 ||  proj_index_close_2[1] == 100000 || indexvalue_proj_close_1 == -1 || indexvalue_proj_close_2 == -1)
		{
			printf("error at handle_runRegistration_change: %d %d\n", proj_index, rawRansac[0].size());
			printf("proj_index_close_1_dist: %f   proj_index_close_2_dist: %f\n", proj_index_close_1_dist, proj_index_close_2_dist);
		}

		triplet.push_back(rawRansac[1][proj_index]);
		triplet.push_back(proj_index_close_1);
		triplet.push_back(proj_index_close_2);
		closestneighbors_proj.push_back(triplet);

		distanceratio_closestneighbors_proj.push_back(distanceMatrixProjection[indexvalue_proj_close_1][proj_index]/distanceMatrixProjection[indexvalue_proj_close_2][proj_index]);
	}

	double overall_minimum_median = 100000;
	double overall_minimum_average = 100000;
	int total_used = 0;

	FILE * identityFile;
	identityFile = fopen ("identity.txt","w");

	FILE * ransacFile;
	ransacFile = fopen ("ransac_markers.txt","w");

	vector< vector < double > > ransacmarkers_topo;
	vector< vector < double > > ransacmarkers_proj;

	for(int i = 0; i < distanceratio_closestneighbors_topo.size(); i++)
	{
		for(int j = 0; j < distanceratio_closestneighbors_proj.size(); j++)
		{
			if(distanceratio_closestneighbors_topo[i] <= distanceratio_closestneighbors_proj[j]*1.02 && distanceratio_closestneighbors_topo[i] >= distanceratio_closestneighbors_proj[j]*0.98)
			{

	//closestneighbors_topo[a][b][c]
	// a: index of a triplet (i.e. point "rawRansac[0][a]" with its two closest neighbors)
	// b: index of one of the points in the triplet
	// b: 0--> the point of interest 1-->closest point to the point of interest 2--> second closest to the point of interest
	// c: 0--> x coordinate, 1--> y coordinate	 


				double topo_matrix_M[6][6] = {0};
				topo_matrix_M[0][0] = closestneighbors_topo[i][0][0]; topo_matrix_M[0][1] = closestneighbors_topo[i][0][1]; topo_matrix_M[0][4] = 1;
				topo_matrix_M[1][2] = closestneighbors_topo[i][0][0]; topo_matrix_M[1][3] = closestneighbors_topo[i][0][1]; topo_matrix_M[1][5] = 1;
				topo_matrix_M[2][0] = closestneighbors_topo[i][1][0]; topo_matrix_M[2][1] = closestneighbors_topo[i][1][1]; topo_matrix_M[2][4] = 1;
				topo_matrix_M[3][2] = closestneighbors_topo[i][1][0]; topo_matrix_M[3][3] = closestneighbors_topo[i][1][1]; topo_matrix_M[3][5] = 1;
				topo_matrix_M[4][0] = closestneighbors_topo[i][2][0]; topo_matrix_M[4][1] = closestneighbors_topo[i][2][1]; topo_matrix_M[4][4] = 1;
				topo_matrix_M[5][2] = closestneighbors_topo[i][2][0]; topo_matrix_M[5][3] = closestneighbors_topo[i][2][1]; topo_matrix_M[5][5] = 1;

				double topo_matrix_transpose_M[6][6] = {0};
			    for(int trans_i=0; trans_i < 6; trans_i++)
				{
					for(int trans_j=0; trans_j < 6; trans_j++)
					{
                        topo_matrix_transpose_M[trans_i][trans_j]=topo_matrix_M[trans_j][trans_i];
					}
				}

				double topo_matrix_r[6];
				topo_matrix_r[0] = closestneighbors_proj[j][0][0];
				topo_matrix_r[1] = closestneighbors_proj[j][0][1];
				topo_matrix_r[2] = closestneighbors_proj[j][1][0];
				topo_matrix_r[3] = closestneighbors_proj[j][1][1];
				topo_matrix_r[4] = closestneighbors_proj[j][2][0];
				topo_matrix_r[5] = closestneighbors_proj[j][2][1];

				double topo_matrix_TM_M_multiplied[6][6] = {0};

				matrixMultiplication(topo_matrix_TM_M_multiplied, topo_matrix_transpose_M, topo_matrix_M);

				double inverseMatrix[6][6] = {0};

				Matrix topo_tm_m(6,6);
				topo_tm_m(0,0) = topo_matrix_TM_M_multiplied[0][0];topo_tm_m(0,1) = topo_matrix_TM_M_multiplied[0][1];
				topo_tm_m(0,2) = topo_matrix_TM_M_multiplied[0][2];topo_tm_m(0,3) = topo_matrix_TM_M_multiplied[0][3];
				topo_tm_m(0,4) = topo_matrix_TM_M_multiplied[0][4];topo_tm_m(0,5) = topo_matrix_TM_M_multiplied[0][5];

				topo_tm_m(1,0) = topo_matrix_TM_M_multiplied[1][0];topo_tm_m(1,1) = topo_matrix_TM_M_multiplied[1][1];
				topo_tm_m(1,2) = topo_matrix_TM_M_multiplied[1][2];topo_tm_m(1,3) = topo_matrix_TM_M_multiplied[1][3];
				topo_tm_m(1,4) = topo_matrix_TM_M_multiplied[1][4];topo_tm_m(1,5) = topo_matrix_TM_M_multiplied[1][5];

				topo_tm_m(2,0) = topo_matrix_TM_M_multiplied[2][0];topo_tm_m(2,1) = topo_matrix_TM_M_multiplied[2][1];
				topo_tm_m(2,2) = topo_matrix_TM_M_multiplied[2][2];topo_tm_m(2,3) = topo_matrix_TM_M_multiplied[2][3];
				topo_tm_m(2,4) = topo_matrix_TM_M_multiplied[2][4];topo_tm_m(2,5) = topo_matrix_TM_M_multiplied[2][5];

				topo_tm_m(3,0) = topo_matrix_TM_M_multiplied[3][0];topo_tm_m(3,1) = topo_matrix_TM_M_multiplied[3][1];
				topo_tm_m(3,2) = topo_matrix_TM_M_multiplied[3][2];topo_tm_m(3,3) = topo_matrix_TM_M_multiplied[3][3];
				topo_tm_m(3,4) = topo_matrix_TM_M_multiplied[3][4];topo_tm_m(3,5) = topo_matrix_TM_M_multiplied[3][5];

				topo_tm_m(4,0) = topo_matrix_TM_M_multiplied[4][0];topo_tm_m(4,1) = topo_matrix_TM_M_multiplied[4][1];
				topo_tm_m(4,2) = topo_matrix_TM_M_multiplied[4][2];topo_tm_m(4,3) = topo_matrix_TM_M_multiplied[4][3];
				topo_tm_m(4,4) = topo_matrix_TM_M_multiplied[4][4];topo_tm_m(4,5) = topo_matrix_TM_M_multiplied[4][5];

				topo_tm_m(5,0) = topo_matrix_TM_M_multiplied[5][0];topo_tm_m(5,1) = topo_matrix_TM_M_multiplied[5][1];
				topo_tm_m(5,2) = topo_matrix_TM_M_multiplied[5][2];topo_tm_m(5,3) = topo_matrix_TM_M_multiplied[5][3];
				topo_tm_m(5,4) = topo_matrix_TM_M_multiplied[5][4];topo_tm_m(5,5) = topo_matrix_TM_M_multiplied[5][5];

				if(topo_tm_m.IsSingular())
				{
					printf("\nMATRIX IS NOT INVERSIBLE\n");
				}
				else
				{
					Matrix matinverse = !topo_tm_m;

					inverseMatrix[0][0] = matinverse(0,0); inverseMatrix[0][1] = matinverse(0,1); inverseMatrix[0][2] = matinverse(0,2);
					inverseMatrix[0][3] = matinverse(0,3); inverseMatrix[0][4] = matinverse(0,4); inverseMatrix[0][5] = matinverse(0,5);

					inverseMatrix[1][0] = matinverse(1,0); inverseMatrix[1][1] = matinverse(1,1); inverseMatrix[1][2] = matinverse(1,2);
					inverseMatrix[1][3] = matinverse(1,3); inverseMatrix[1][4] = matinverse(1,4); inverseMatrix[1][5] = matinverse(1,5);

					inverseMatrix[2][0] = matinverse(2,0); inverseMatrix[2][1] = matinverse(2,1); inverseMatrix[2][2] = matinverse(2,2);
					inverseMatrix[2][3] = matinverse(2,3); inverseMatrix[2][4] = matinverse(2,4); inverseMatrix[2][5] = matinverse(2,5);

					inverseMatrix[3][0] = matinverse(3,0); inverseMatrix[3][1] = matinverse(3,1); inverseMatrix[3][2] = matinverse(3,2);
					inverseMatrix[3][3] = matinverse(3,3); inverseMatrix[3][4] = matinverse(3,4); inverseMatrix[3][5] = matinverse(3,5);

					inverseMatrix[4][0] = matinverse(4,0); inverseMatrix[4][1] = matinverse(4,1); inverseMatrix[4][2] = matinverse(4,2);
					inverseMatrix[4][3] = matinverse(4,3); inverseMatrix[4][4] = matinverse(4,4); inverseMatrix[4][5] = matinverse(4,5);

					inverseMatrix[5][0] = matinverse(5,0); inverseMatrix[5][1] = matinverse(5,1); inverseMatrix[5][2] = matinverse(5,2);
					inverseMatrix[5][3] = matinverse(5,3); inverseMatrix[5][4] = matinverse(5,4); inverseMatrix[5][5] = matinverse(5,5);

					double identityCheckMatrix[6][6] = {0};
					matrixMultiplication(identityCheckMatrix, inverseMatrix, topo_matrix_TM_M_multiplied);

					for(int iden_i = 0; iden_i < 6; iden_i++)
					{
						for(int iden_j = 0; iden_j < 6; iden_j++)
						{
							fprintf(identityFile,"%f ", identityCheckMatrix[iden_i][iden_j]);
						}
						fprintf(identityFile,"\n");
					}
					fprintf(identityFile,"\n\n\n");
	
					double topo_matrix_TM_r_multiplied[6] = {0};
						
					for ( int ind_r = 0; ind_r < 6; ind_r++ )
					{
						topo_matrix_TM_r_multiplied[ind_r] = 0.0;
						for ( int ind_i = 0; ind_i < 6; ind_i++ )
						{
							topo_matrix_TM_r_multiplied[ind_r] +=  topo_matrix_transpose_M[ind_r][ind_i] * topo_matrix_r[ind_i];
						}
					}

					double topo_matrix_v[6] = {0};
					for ( int ind_r = 0; ind_r < 6; ind_r++ )
					{
						topo_matrix_v[ind_r] = 0.0;
						for ( int ind_i = 0; ind_i < 6; ind_i++ )
						{
							topo_matrix_v[ind_r] +=  inverseMatrix[ind_r][ind_i] * topo_matrix_TM_r_multiplied[ind_i];
						}
					}

					vector<double> sum_of_errors;

						vector< vector < double > > temp_ransacmarkers_proj;

						for(int den_i = 0; den_i < rawRansac[0].size(); den_i++)
						{
							double tmp_proj_x = topo_matrix_v[0]*rawRansac[0][den_i][0] + topo_matrix_v[1]*rawRansac[0][den_i][1] + topo_matrix_v[4];
							double tmp_proj_y = topo_matrix_v[2]*rawRansac[0][den_i][0] + topo_matrix_v[3]*rawRansac[0][den_i][1] + topo_matrix_v[5];
							double smallest_distance = 100000;
							int minimum_ind = 0;

							vector < double > temp_unit_proj(2,0);
							for(int den_j = 0; den_j < rawRansac[1].size(); den_j++)
							{
								double temp_distance = sqrt(pow((rawRansac[1][den_j][0]-tmp_proj_x),2) + pow((rawRansac[1][den_j][1]-tmp_proj_y),2));
								if(temp_distance < smallest_distance)
								{
									smallest_distance = temp_distance;
									minimum_ind = den_j;
								}
							}

							temp_unit_proj[0] = tmp_proj_x;
							temp_unit_proj[1] = tmp_proj_y;
							temp_ransacmarkers_proj.push_back(temp_unit_proj);

							sum_of_errors.push_back(smallest_distance);
						}

						sort(sum_of_errors.begin(),sum_of_errors.begin()+rawRansac[0].size());

						double median_value;
						if(sum_of_errors.size()%2 == 0)
						{
							median_value = (sum_of_errors[sum_of_errors.size()/2] + sum_of_errors[sum_of_errors.size()/2 - 1])/2;
						}
						else
						{
							median_value = sum_of_errors[sum_of_errors.size()/2];
						}

						double temp_average = 0;
						int valid_dist = 0;
						for(int av_i = 0; av_i < sum_of_errors.size(); av_i++)
						{
							if(sum_of_errors[av_i] <= 4)
							{
								valid_dist++;
								temp_average += sum_of_errors[av_i]; 
							}
						}

						temp_average /= valid_dist;

						if(median_value < overall_minimum_median)
						{
							overall_minimum_median = median_value;
							ransacmarkers_topo = rawRansac[0];
							ransacmarkers_proj = temp_ransacmarkers_proj;
							overall_minimum_average = temp_average;
							total_used = valid_dist;
						}

				}
			}
		}
	}

//	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();

	fprintf(ransacFile,"%d\n", ransacmarkers_topo.size());

	for (int r_i = 0; r_i < ransacmarkers_topo.size(); r_i++) 
	{
		fprintf(ransacFile,"%g %g ", ransacmarkers_topo[r_i][0], ransacmarkers_topo[r_i][1]);
	}
	fprintf(ransacFile,"\n");

	for (int r_i = 0; r_i < ransacmarkers_proj.size(); r_i++) 
	{
		fprintf(ransacFile,"%g %g ", ransacmarkers_proj[r_i][0], ransacmarkers_proj[r_i][1]);
	}
	fprintf(ransacFile,"\n");

	fclose (ransacFile);
	fclose (identityFile);
	printf("\n average coming from overall_minimum_median : %f\n", overall_minimum_average);
	printf("\n total number of used markers for calculation : %d\n", total_used);
}

void nmr_RegistrationUI::handle_runDrawRegistration_change(vrpn_int32 value, void *ud)
{
	float x,y;

	FILE * pFile;
	pFile = fopen ("ransac_markers.txt","r");

	nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);

	vector< vector <float> > wh = me->d_aligner->get_d_local_impl()->get_d_alignerUI()->getWidthHeight();


	if (pFile==NULL) 
	{
		perror ("Error opening file");
	}
	else
	{
		rewind (pFile);
		int num;
		fscanf (pFile, "%d", &num);

		if(num <= NMR_MAX_FIDUCIAL)
		{
			vrpn_float32 x_src[NMR_MAX_FIDUCIAL], y_src[NMR_MAX_FIDUCIAL], z_src[NMR_MAX_FIDUCIAL],
				x_tgt[NMR_MAX_FIDUCIAL], y_tgt[NMR_MAX_FIDUCIAL], z_tgt[NMR_MAX_FIDUCIAL];

			vrpn_int32 replace = 1;


			printf ("%d ",num);
			printf ("Topography: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_src[i] = x/(wh[0][0]-1.0);
				y_src[i] = y/(wh[0][0]-1.0);
				z_src[i] = 0;

				if( i == 0 || i == (num-1))
				{
					printf ("source %d %f %f\n", i, x_src[i], y_src[i]);
				}
			}
			printf ("\n");

			printf ("Projection: ");
			for(int i = 0; i<num; i++)
			{
				fscanf (pFile, "%f %f", &x, &y);
				x_tgt[i] = x/(wh[1][0]-1.0);
				y_tgt[i] = y/(wh[1][0]-1.0);
				z_tgt[i] = 0;

				if( i == 0 || i == (num-1))
				{
					printf ("target %d %f %f\n", i, x_tgt[i], y_tgt[i]);
				}
			}
			printf ("\n");

			nmr_RegistrationUI *me = static_cast<nmr_RegistrationUI *>(ud);
			me->d_aligner->get_d_local_impl()->get_d_alignerUI()->setFiducial(replace,num,x_src,y_src,z_src,x_tgt,y_tgt,z_tgt);
		}
		else
		{
			printf ("Error: Number of markers in the file is bigger than NMR_MAX_FIDUCIAL\n");
		}
		fclose (pFile);
	}
}


void nmr_RegistrationUI::sendTransformationParameters()
{
  vrpn_float32 *parameters = new vrpn_float32[nmb_numTransformParameters];
  nmb_Transform_TScShR transform;
  transform.setParameter(NMB_ROTATE_2D_Z, (double)d_rotate2D_Z*M_PI/180.0);
  transform.setParameter(NMB_ROTATE_3D_X, (double)d_rotate3D_X*M_PI/180.0);
  transform.setParameter(NMB_ROTATE_3D_Z, (double)d_rotate3D_Z*M_PI/180.0);
  transform.setParameter(NMB_TRANSLATE_X, (double)d_translateX);
  transform.setParameter(NMB_TRANSLATE_Y, (double)d_translateY);
  transform.setParameter(NMB_TRANSLATE_Z, (double)d_translateZ);
  transform.setParameter(NMB_SCALE_X, (double)d_scaleX);
  transform.setParameter(NMB_SCALE_Y, (double)d_scaleY);
  transform.setParameter(NMB_SHEAR_Z, (double)d_shearZ);
  transform.setCenter(d_translateX, d_translateY, d_translateZ);
  int i;
  for (i = 0; i < nmb_numTransformParameters; i++) {
    parameters[i] = (vrpn_float32)transform.getParameter(
                                 nmb_transformParameterOrder[i]);
  }
  d_aligner->setTransformationParameters(parameters);
}

// static
void nmr_RegistrationUI::handle_registrationEnabled_change(
      vrpn_int32 value, void *ud)
{
    nmr_RegistrationUI *me = (nmr_RegistrationUI *)ud;
    if (value) {
        me->d_aligner->setGUIEnable(vrpn_TRUE, NMR_ALLWINDOWS);
        //Init images
        handle_registrationImage3D_change(
            me->d_registrationImageName3D.string(), me);
        handle_registrationImage2D_change(
            me->d_registrationImageName2D.string(), me);

        // We're popping up our window. Set the 3D image to 
        // height plane if we have any clue what that is. 
/*
        nmb_Image *dataim;
        if (!me->d_dataset) return;

        if (me->d_dataset->heightPlaneName) {
          me->d_registrationImageName3D = 
                        me->d_dataset->heightPlaneName->string();
        } else 
        if (me->d_dataset->dataImages()->numImages() > 0){
          dataim = me->d_dataset->dataImages()->getImage(0);
          me->d_registrationImageName3D = dataim->name()->c_str();
        }
        // Also guess at the 2D image name
        int i;
        for (i = 1; i < me->d_dataset->dataImages()->numImages(); i++) {
            dataim = me->d_dataset->dataImages()->getImage(i);
            //printf("Considering %s\n", dataim->name()->c_str());
            if (strcmp(dataim->name()->c_str(),
                       me->d_dataset->heightPlaneName->string())) {
                me->d_registrationImageName2D = dataim->name()->c_str();
                break;
            }
        }
*/
    } else {
        me->d_aligner->setGUIEnable(vrpn_FALSE, NMR_ALLWINDOWS);
    }
}


void nmr_RegistrationUI::createResampleImage(const char * /*imageName */)
{
    //printf("nmr_RegistrationUI::createResampleImage\n");
    nmb_Image *new_image;
    if (!d_dataset) return;
    nmb_Image *im_3D = d_dataset->dataImages()->getImageByName
                          (d_registrationImageName3D.string());
    nmb_Image *im_2D = d_dataset->dataImages()->getImageByName
                          (d_registrationImageName2D.string());

    int displayedTransformIndex = getDisplayedTransformIndex();

    // d_imageTransformWorldSpace is the transformation that takes points from
    // height image to points in the texture image

    // Make sure we have all the information we need and
    // see if the user has given a name to the resampled plane
    // other than "".  If so, we should create a new plane and set the value
    // back to "".
    if (!im_3D || !im_2D ||
               (strlen(d_newResampleImageName.string()) == 0)){
        return;

    } else if (d_invertWarp) {    // warp the AFM image to the SEM image
        new_image = new nmb_ImageGrid(
                (const char *)(d_newResampleImageName.string()),
                (const char *)(im_3D->unitsValue()),
                d_resampleResolutionX, d_resampleResolutionY);
        d_newResampleImageName = (const char *) "";
        nmb_ImageBounds im2D_bounds;
        im_2D->getBounds(im2D_bounds);
        new_image->setBounds(im2D_bounds);
        nmb_TransformMatrix44 projImageFromTopoImage;
        nmb_TransformMatrix44 topoImageFromProjImage;

        /*
          projImageFromTopoImage = (scaledProjImToProjImage)*
                                   (d_scaledProjImFromScaledTopoIm)*
                                   (topoImageToScaledTopoImage)
        */
        nmr_Util::computeResampleTransformInImageCoordinates(
                  im_2D, im_3D,
                  d_scaledProjImFromScaledTopoIm[displayedTransformIndex],
                  projImageFromTopoImage);

        if (projImageFromTopoImage.hasInverse()) {
          topoImageFromProjImage = projImageFromTopoImage;
          topoImageFromProjImage.invert();
        } else {
          fprintf(stderr,
                "createResampleImage failed: non-invertible transform\n");
        }

		double intensityRange = im_2D->maxNonZeroValue() - im_2D->minNonZeroValue();
		double nonZeroIntensityOffset = -(im_2D->minNonZeroValue()-0.01*intensityRange);
        nmr_Util::createResampledImageWithImageSpaceTransformation((*im_3D), 
                 (*im_2D),
                 topoImageFromProjImage, (*new_image), nonZeroIntensityOffset);

        // an extra step: combine the two datasets in a somewhat arbitrary
        // way so that you can see features from both in a single image
        // it would be nice to create a color image from these two instead:
        nmr_Util::addImage((*im_2D), (*new_image), (double)d_resampleRatio,
                  1.0-(double)d_resampleRatio);

    } else {                      // warp the SEM image to the AFM image
      if (d_constrainToTopography){
      // resample the SEM data onto the AFM grid only
        // it is possible to change resolution or select a subregion
        // of the height field at this point by just changing what
        // resolution we give to the constructor and what image
        // bounds we set and everything should just work correctly:
        new_image = new nmb_ImageGrid(
                (const char *)(d_newResampleImageName.string()),
                (const char *)(im_2D->unitsValue()),
                d_resampleResolutionX, d_resampleResolutionY);
        nmb_ImageBounds im3D_bounds;
        im_3D->getBounds(im3D_bounds);
        new_image->setBounds(im3D_bounds);
        TopoFile tf;
        im_3D->getTopoFileInfo(tf);
        new_image->setTopoFileInfo(tf);
        d_newResampleImageName = (const char *) "";
        /*
          projWorldFromTopoWorld = projWorldFromScaledProjIm*
                                   d_scaledProjImFromScaledTopoIm*
                                   scaledTopoImFromTopoWorld
        */
        nmb_TransformMatrix44 projImageFromTopoImage;
        if (nmr_Util::computeResampleTransformInImageCoordinates(im_2D, im_3D,
                d_scaledProjImFromScaledTopoIm[displayedTransformIndex],
                projImageFromTopoImage)) {
          fprintf(stderr,
              "createResampleImage failed: worldFromProjIm not invertible\n");
          return;
        }
        
		double intensityRange = im_2D->maxNonZeroValue() - im_2D->minNonZeroValue();
		double nonZeroIntensityOffset = -(im_2D->minNonZeroValue()-0.01*intensityRange);
        nmr_Util::createResampledImageWithImageSpaceTransformation(
            (*im_2D),
            projImageFromTopoImage, 
            (*new_image), nonZeroIntensityOffset);
      } else {
        
        // projWorldFromTopoWorld = identity because the transforms have 
	// already been adjusted inside the nmb_Image objects to make them
        // their world coordinate systems identical

        nmb_TransformMatrix44 projWorldFromTopoWorld;       
        nmb_TransformMatrix44 projImageFromTopoImage;
        if (nmr_Util::computeResampleTransformInImageCoordinates(im_2D, im_3D,
                d_scaledProjImFromScaledTopoIm[displayedTransformIndex],
                projImageFromTopoImage)){
          fprintf(stderr, 
              "createResampleImage failed: worldFromProjIm not invertible\n");
          return;
        }

        // here we figure out what resolution is required to preserve
        // the entire 2D projection image while keeping the resolution of
        // height field constant
        int min_i, min_j, max_i, max_j;
        nmr_Util::computeResampleExtents((*im_3D), (*im_2D), 
            projImageFromTopoImage, 
            min_i, min_j, max_i, max_j);
        int res_x = max_i - min_i;
        int res_y = max_j - min_j;
        //printf("got extents: %d x %d\n", res_x, res_y);

        new_image = new nmb_ImageGrid(
                (const char *)(d_newResampleImageName.string()),
                (const char *)(im_2D->unitsValue()),
                res_x, res_y);
        d_newResampleImageName = (const char *) "";
        //printf("allocated image\n");
        TopoFile tf;
        im_3D->getTopoFileInfo(tf);
        new_image->setTopoFileInfo(tf);
        //printf("%d, %d, %d, %d\n", min_i, min_j, max_i, max_j);
        nmr_Util::setRegionRelative((*im_3D), (*new_image),
                 min_i, min_j, max_i, max_j);
		double intensityRange = im_2D->maxNonZeroValue() - im_2D->minNonZeroValue();
		double nonZeroIntensityOffset = -(im_2D->minNonZeroValue()-0.01*intensityRange);
        nmr_Util::createResampledImageWithImageSpaceTransformation((*im_2D), 
                 (*im_3D), projImageFromTopoImage, (*new_image),
				 nonZeroIntensityOffset);

        // HACK:
        // an extra step: combine the two datasets in a somewhat arbitrary
        // way so that you can see features from both in a single image
        // it would be nice to create a color image from these two instead:
        nmr_Util::addImage((*im_3D), (*new_image), (double)d_resampleRatio,
                  1.0-(double)d_resampleRatio);

      }
    }
    //printf("finished resampling image\n");
    // now make it available elsewhere:
    d_dataset->dataImages()->addImage(new_image);
}

void nmr_RegistrationUI::createResamplePlane(const char * /*imageName */)
{
    //printf("nmr_RegistrationUI::createResamplePlane\n");
    int displayedTransformIndex = getDisplayedTransformIndex();
    nmb_ImageGrid *new_image;
    if (!d_dataset) return;
    nmb_Image *im_3D = d_dataset->dataImages()->getImageByName
                          (d_registrationImageName3D.string());
    nmb_Image *im_2D = d_dataset->dataImages()->getImageByName
                          (d_registrationImageName2D.string());

    // d_imageTransformWorldSpace is the transformation that takes points from
    // height image to points in the texture image

    // Make sure we have all the information we need and
    // see if the user has given a name to the resampled plane
    // other than "".  If so, we should create a new plane and set the value
    // back to "".
    if (!im_3D || !im_2D ||
               (strlen(d_newResamplePlaneName.string()) == 0)){
        return;

    } 
    // resample the SEM data onto the AFM grid only 
    //Region is the same as the AFM grid, resolution is the same as the AFM
    //grid
        new_image = new nmb_ImageGrid(
                (const char *)(d_newResamplePlaneName.string()),
                (const char *)(im_2D->unitsValue()),
                im_3D->width(), im_3D->height());
        nmb_ImageBounds im3D_bounds;
        im_3D->getBounds(im3D_bounds);
        new_image->setBounds(im3D_bounds);
        TopoFile tf;
        im_3D->getTopoFileInfo(tf);
        new_image->setTopoFileInfo(tf);
        d_newResamplePlaneName = (const char *) "";
        nmb_TransformMatrix44 projImageFromTopoImage;
        if (nmr_Util::computeResampleTransformInImageCoordinates(im_2D, im_3D,
            d_scaledProjImFromScaledTopoIm[displayedTransformIndex], 
            projImageFromTopoImage)) {
           fprintf(stderr, 
                 "createResamplePlane Error, non-invertible transform\n");
           return;
        }

		double intensityRange = im_2D->maxNonZeroValue() - im_2D->minNonZeroValue();
		double nonZeroIntensityOffset = -(im_2D->minNonZeroValue()-0.01*intensityRange);
        nmr_Util::createResampledImageWithImageSpaceTransformation(
                 (*im_2D),
                 projImageFromTopoImage, (*new_image),
				 nonZeroIntensityOffset);

    //printf("finished resampling image\n");
    // now make it available elsewhere:
    // this is the code from nmb_Dataset::addImageToGrid(new_image) which
    // had to be copied here now that I've removed dependence on nmb_Dataset
    
    d_dataset->addImageToGrid(new_image);
    //d_imageList->addImage(new_image);
    nmb_Image::deleteImage(new_image);
}

