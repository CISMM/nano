/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include	<stdlib.h>
#include	<stdio.h>
#include	<string.h>
#include	<ctype.h>
#include	"Tcl_Linkvar.h"

#include <tcl.h>
#include <tk.h>

static	const int MAX_INTS =	1000;	// Max number of int variables
static	const int MAX_IB =	1000;	// Max number of int/buttons
static	const int MAX_FLOATS =	1000;	// Max number of float variables
static	const int MAX_FS =	1000;	// Max number of floatscale vars
static	const int MAX_IS =	1000;	// Max number of intscale vars
static	const int MAX_INTENTRY= 1000;	// Max number of intentry vars
static	const int MAX_CHECKENTRY= 1000;	// Max number of intentry vars
static	const int MAX_SELS =	1000;	// Max number of selectors

static	int	num_ints = 0;			// Number of int variables
static	Tclvar_int	*int_list[MAX_INTS];	// Int variables

static	int	num_ib = 0;			// Number of ints with buttons
static	Tclvar_int_with_button	*ib_list[MAX_IB];// IB variables

static	int	num_floats = 0;			// Number of float variables
static	Tclvar_float	*float_list[MAX_FLOATS];// Float variables

static	int	num_fs = 0;			// Number of floats with scales
static	Tclvar_float_with_scale	*fs_list[MAX_FS];// Floatscale variables

static	int	num_is = 0;			// Number of ints with scales
static	Tclvar_int_with_scale	*is_list[MAX_IS];// Intscale variables

static	int	num_intentry = 0;		// Number of ints with scales
static	Tclvar_int_with_entry	*intentry_list[MAX_INTENTRY];// Intscale variables

static	int	num_checkentry = 0;		// Number of ints with scales
static	Tclvar_checklist_with_entry	*checkentry_list[MAX_CHECKENTRY];// Intscale variab

static	int	num_sels = 0;			// Number of selectors
static	Tclvar_selector		*sel_list[MAX_SELS];

static	Tcl_Interp	*interpreter = NULL;	// Tcl interpreter used

// DO NOT USE commands such as Tcl_GetVar2 (with the 2 at the end)
// if we use Tcl_GetVar instead, we wil be able to link with array elements 
// in TCL. 

//	Update the integer variable in the handler that is pointed to
// when the variables changes.

static	char	*handle_int_value_change(ClientData clientData,
	Tcl_Interp *interp, char */*name1*/, char */*name2*/, int /*flags*/)
{
        char    *cvalue;
	int	value;
	Tclvar_int	*intvar = (Tclvar_int*)(clientData);

	// Look up the new value of the variable
	cvalue = Tcl_GetVar(interp, intvar->my_tcl_varname,
		 TCL_GLOBAL_ONLY);
	if (cvalue == NULL) {
		fprintf(stderr,"Warning!  Can't read %s from Tcl\n",
			intvar->my_tcl_varname);
		intvar->dirty = 1;
	} else if (Tcl_GetInt(interp, cvalue, &value) != TCL_OK) {
		fprintf(stderr,"Warning!  %s not int from Tcl\n",
			intvar->my_tcl_varname);
		intvar->dirty = 1;
	} else { //no errors: update the variable
	   intvar->myint = intvar->mylastint = value;

	   // Yank the callback if it has been set
	   if (intvar->callback) {
	      intvar->callback(value, intvar->userdata);
	   }
	}

	return NULL;
};

//	Update the float variable in the handler that is pointed to
// when the variables changes.

static	char	*handle_float_value_change(ClientData clientData,
	Tcl_Interp *interp, char */*name1*/, char */*name2*/, int /*flags*/)
{
        char    *cvalue;
	double	value;
	Tclvar_float	*floatvar = (Tclvar_float*)(clientData);

// 	printf("floatvalchange: %s %s %s\n", name1, name2, floatvar->my_tcl_varname);
	// Look up the new value of the variable
	cvalue = Tcl_GetVar(interp, floatvar->my_tcl_varname, 
		 TCL_GLOBAL_ONLY);
	if (cvalue == NULL) {
		fprintf(stderr,"Warning!  Can't read %s from Tcl\n",
			floatvar->my_tcl_varname);
		floatvar->dirty = 1;
	} else if (Tcl_GetDouble(interp, cvalue, &value) != TCL_OK) {
		fprintf(stderr,"Warning!  %s not double from Tcl\n",
			floatvar->my_tcl_varname);
		floatvar->dirty = 1;
	} else { // no errors: update the variable
//  	printf("floatvalchange: %s %s old %f new %f\n", 
// 	       floatvar->my_tcl_varname, cvalue, floatvar->mylastfloat, value);
	   floatvar->myfloat = floatvar->mylastfloat = value;

	   // Yank the callback if it has been set
	   if (floatvar->callback) {
	      floatvar->callback(value, floatvar->userdata);
	   }

	}
	return NULL;
};

//	Update the string variable in the handler that is pointed to
// when the variables changes.

static	char	*handle_string_value_change(ClientData clientData,
	Tcl_Interp *interp, char */*name1*/, char */*name2*/, int /*flags*/)
{
        char    *cvalue;
	Tclvar_selector	*selvar = (Tclvar_selector*)(clientData);
	// Look up the new value of the variable
	cvalue = Tcl_GetVar(interp, selvar->my_tcl_varname, 
		 TCL_GLOBAL_ONLY);
	if (cvalue == NULL) {
		fprintf(stderr,"Warning!  Can't read %s from Tcl\n",
			selvar->my_tcl_varname);
		selvar->dirty = 1;
	} else { // no errors: update the variable
	   strncpy(selvar->mystring, cvalue, TCLVAR_STRING_LENGTH);
	   strncpy(selvar->mylaststring, cvalue, TCLVAR_STRING_LENGTH);

	   // Yank the callback if it has been set
	   if (selvar->callback) {
	      selvar->callback(cvalue, selvar->userdata);
	   }
	}
	return NULL;
};

//	Set the interpreter to be used by the integers and floats.
//	Put together links for all of the variables that have been created
// before the interpreter was set.
//	Return 0 on success, -1 on failure.

int	Tclvar_init(Tcl_Interp *tcl_interp)
{
	int	i;
	char	cvalue[100];

//fprintf(stderr, "Tclvar_init() called\n");

	// Set the interpreter
	interpreter = tcl_interp;

	// Insert callbacks for the integer variables
	for (i = 0; i < num_ints; i++) {
		// initialize the tcl variable with the value from the
		// C variable
		sprintf(cvalue, "%d", int_list[i]->myint);
		Tcl_SetVar(interpreter, int_list[i]->my_tcl_varname,
			   cvalue, TCL_GLOBAL_ONLY);
		if (Tcl_TraceVar(interpreter, int_list[i]->my_tcl_varname,
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_int_value_change,
			(ClientData)((void*)(int_list[i]))) != TCL_OK) {
			fprintf(stderr, "Tcl_TraceVar(%s) failed: %s\n",
				int_list[i]->my_tcl_varname,
				interpreter->result);
			return(-1);
		}
	}

	// Insert callbacks for the float variables
	for (i = 0; i < num_floats; i++) {
		// initialize the tcl variable with the value from the
		// C variable
		sprintf(cvalue, "%g", float_list[i]->myfloat);
		Tcl_SetVar(interpreter, float_list[i]->my_tcl_varname,
			   cvalue, TCL_GLOBAL_ONLY);
		if (Tcl_TraceVar(interpreter, float_list[i]->my_tcl_varname,
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_float_value_change,
			(ClientData)((void*)(float_list[i]))) != TCL_OK) {
			fprintf(stderr, "Tcl_TraceVar(%s) failed: %s\n",
				float_list[i]->my_tcl_varname,
				interpreter->result);
			return(-1);
		}

	}


	// Set up the checkentries.
	// this must be done before the integer with buttons
	// and intentries
	for (i = 0; i < num_checkentry; i++) {
	    if (checkentry_list[i]->tcl_parent_name != NULL) {
		if (checkentry_list[i]->initialize(interpreter)) return(-1);
	    }
	}

	// Set up the integer with buttons.
	for (i = 0; i < num_ib; i++) {
	    if (ib_list[i]->tcl_widget_name != NULL) {
		if (ib_list[i]->initialize(interpreter)) return(-1);
	    }
	}

	// Set up the floatscales.
	for (i = 0; i < num_fs; i++) {
	    if (fs_list[i]->tcl_widget_name != NULL) {
		if (fs_list[i]->initialize(interpreter)) return(-1);
	    }
	}

	// Set up the intscales.
	for (i = 0; i < num_is; i++) {
	    if (is_list[i]->tcl_widget_name != NULL) {
		if (is_list[i]->initialize(interpreter)) return(-1);
	    }
	}

	// Set up the intentries.
	for (i = 0; i < num_intentry; i++) {
	    if (intentry_list[i]->tcl_widget_name != NULL) {
		if (intentry_list[i]->initialize(interpreter)) return(-1);
	    }
	}

	// Insert callbacks for the selector variables
	// Set up the selectors.
	for (i = 0; i < num_sels; i++) {
            if (sel_list[i]->my_tcl_varname)  // TCH  6 April 98
		if (Tcl_TraceVar(interpreter, sel_list[i]->my_tcl_varname,
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_string_value_change,
			(ClientData)((void*)(sel_list[i]))) != TCL_OK) {
			fprintf(stderr, "Tcl_TraceVar(%s) failed: %s\n",
				sel_list[i]->my_tcl_varname,
				interpreter->result);
			return(-1);
		}
		if (sel_list[i]->tcl_widget_name != NULL) {
			if (sel_list[i]->initialize(interpreter)) return(-1);
		}
	}

	return	0;

}

int	Tclvar_mainloop(void)
{
	int	i;
	char	cvalue[100];

	// Make sure there is a valid interpeter
	if (interpreter == NULL) {
		return -1;
	}

	// Check for changes in the C integers and update the Tcl variables
	// when they occur.
	for (i = 0; i < num_ints; i++) {
		if ((int_list[i]->myint != int_list[i]->mylastint)||
		    (int_list[i]->dirty)){
			int_list[i]->mylastint = int_list[i]->myint;
			int_list[i]->dirty = 0;
			sprintf(cvalue,"%d", int_list[i]->myint);
			Tcl_SetVar(interpreter, int_list[i]->my_tcl_varname,
				cvalue, TCL_GLOBAL_ONLY);
			
		}
	}

	// Check for changes in the C floats and update the Tcl variables
	// when they occur.
	for (i = 0; i < num_floats; i++) {
		if ((float_list[i]->myfloat != float_list[i]->mylastfloat)||
		    (float_list[i]->dirty)) {
			float_list[i]->mylastfloat = float_list[i]->myfloat;
			float_list[i]->dirty = 0;
			sprintf(cvalue,"%g", float_list[i]->myfloat);
			Tcl_SetVar(interpreter, float_list[i]->my_tcl_varname,
				cvalue, TCL_GLOBAL_ONLY);
		}
	}

	// Check for changes in the C selectors and update the Tcl variables
	// when they occur.
	for (i = 0; i < num_sels; i++) {
		if ((strcmp(sel_list[i]->mystring,sel_list[i]->mylaststring))||
		    (sel_list[i]->dirty)){
			strcpy(sel_list[i]->mylaststring,sel_list[i]->mystring);
			sel_list[i]->dirty = 0;
			Tcl_SetVar(interpreter, sel_list[i]->my_tcl_varname,
				sel_list[i]->mystring, TCL_GLOBAL_ONLY);
		}
	}

	return 0;
}

//	Add an entry into the list of active integer Tcl variables, and
// point it to this variable.
//	Add a Tcl callback, if an interpreter has been declared.

Tclvar_int::Tclvar_int(char *tcl_varname, int default_value,
	Linkvar_Intcall c, void *ud)
{
	callback = c;
	userdata = ud;
	dirty = 0;
//fprintf(stderr, "Tclvar_int constructor\n");

	if (num_ints >= (MAX_INTS-1)) {
		fprintf(stderr,"Tclvar_int::Tclvar_int(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		int_list[num_ints] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_int::Tclvar_int(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myint = mylastint = default_value;
			num_ints++;
		}
	}

	// Add a callback for change if there is an interpreter
	if (interpreter != NULL) {
		if (Tcl_TraceVar(interpreter, my_tcl_varname,
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_int_value_change,
			(ClientData)((void*)(this))) != TCL_OK) {
			fprintf(stderr, "Tclvar_int::Tclvar_int(): Tcl_TraceVar(%s) failed: %s\n",
				my_tcl_varname, interpreter->result);
		}
	}
};

//	Remove the entry from the list of active integer Tcl variables.

Tclvar_int::~Tclvar_int()
{
	register int	i = 0;
//fprintf(stderr, "~Tclvar_int() %s", my_tcl_varname);
	// Remove the trace callback, if there is an interpreter
	if (interpreter != NULL) {
		Tcl_UntraceVar(interpreter, my_tcl_varname,
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_int_value_change,
			(ClientData)((void*)(this)));
	}

	// Free the space for the name
	if (my_tcl_varname != NULL) {delete [] my_tcl_varname; }

	// Find this entry in the list of variables
	while ( (i < num_ints) && (int_list[i] != this) ) { i++; };
	if (i >= num_ints) {
		fprintf(stderr,"Tclvar_int::~Tclvar_int(): Internal error -- not in list\n");
		return;
	}
//fprintf(stderr, " %d of %d\n", i, num_ints);

	// Move the last entry to this one
	int_list[i] = int_list[num_ints-1];

	// Reduce the number in the list
	num_ints--;
};

//	Add an entry into the list of active float Tcl variables, and
// point it to this variable.
//	Add a trace callback if there is an interpreter.

Tclvar_float::Tclvar_float(char *tcl_varname, float default_value,
	Linkvar_Floatcall c, void *ud)
{
	callback = c;
	userdata = ud;
	dirty = 0;

//fprintf(stderr, "Tclvar_float constructor\n");

	if (num_floats >= (MAX_FLOATS-1)) {
		fprintf(stderr,"Tclvar_float::Tclvar_float(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		float_list[num_floats] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_float::Tclvar_float(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myfloat = mylastfloat = default_value;
			num_floats++;
		}
	}

        // Add a callback for change if there is an interpreter
        if (interpreter != NULL) {
                if (Tcl_TraceVar(interpreter, my_tcl_varname,
                        TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
                        handle_float_value_change,
			(ClientData)((void*)this)) != TCL_OK) {
                        fprintf(stderr, "Tclvar_float::Tclvar_float(): Tcl_TraceVar(%s) failed: %s\n",
                                my_tcl_varname, interpreter->result);
                }
        }
};

//	Remove the entry from the list of active float Tcl variables.

Tclvar_float::~Tclvar_float()
{
//fprintf(stderr, "~Tclvar_float() %s", my_tcl_varname);
	register int	i = 0;

	// Remove the trace callback, if there is an interpreter
	if (interpreter != NULL) {
		Tcl_UntraceVar(interpreter, my_tcl_varname, 
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_float_value_change,
			(ClientData)((void*)this));
	}

	// Free the space for the name
	if (my_tcl_varname != NULL) { delete [] my_tcl_varname; }

	// Find this entry in the list of variables
	while ( (i < num_floats) && (float_list[i] != this) ) { i++; };
	if (i >= num_floats) {
		fprintf(stderr,"Tclvar_float::~Tclvar_float(): Internal error -- not in list\n");
		return;
	}
//fprintf(stderr, " %d of %d.\n", i, num_floats);

	// Move the last entry to this one
	float_list[i] = float_list[num_floats-1];

	// Reduce the number in the list
	num_floats--;
};

//	Add a trace callback and handler widget if there is an interpreter.

Tclvar_int_with_button::Tclvar_int_with_button(char *tcl_varname,
	char *parent_name, int default_value, Linkvar_Intcall c, void *ud) :
	Tclvar_int(tcl_varname, default_value, c, ud)
{
//fprintf(stderr, "Tclvar_int_with_button constructor\n");

	// Add this to the list of integers with buttons
	if (num_ib >= (MAX_IB-1)) {
		fprintf(stderr,"Tclvar_int_with_button::Tclvar_int_with_button(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		ib_list[num_ib] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_int_with_button::Tclvar_int_with_button(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myint = mylastint = default_value;
			num_ib++;
		}
	}

	// Set the widget name, if there is a parent specified
	// The widget name matches the tcl_varname, unless there are '.'s
	// in the name.  If there are '.'s, the name is just the part after
	// the last '.' (this strips away the prepended widget part).
	if (parent_name != NULL) {
		char	*last_part;

		last_part = strrchr(tcl_varname, '.');
		if (last_part == NULL) {
			last_part = tcl_varname;
		} else {
			last_part++;	// Skip the .
		}
		tcl_widget_name =
			new char[strlen(parent_name) + strlen(last_part) + 2];
		if (tcl_widget_name == NULL) {
			fprintf(stderr,"Tclvar_int_with_button::Tclvar_int_with_button(): Out of memory\n");
		}
		sprintf(tcl_widget_name,"%s.%s",parent_name,last_part);

		// Make sure widget name starts with a lower-case character.
		tcl_widget_name[strlen(parent_name)+1] =
		  tolower(tcl_widget_name[strlen(parent_name)+1]);
	} else {
		tcl_widget_name = NULL;
	}

	// Add and pack a checkbutton if there is an interpreter and a widget
	if ( (interpreter != NULL) && (tcl_widget_name != NULL) ) {
		initialize(interpreter);
	}
};

Tclvar_int_with_button::~Tclvar_int_with_button()
{
	register int	i = 0;

	// Unpack and destroy the checkbutton, if there is an
	// interpreter
	if (interpreter != NULL) {
		char	command[1000];
		sprintf(command,"destroy %s",tcl_widget_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
	}

	// Free the space for the widget name
	if (tcl_widget_name != NULL) { delete [] tcl_widget_name; }

	// Find this entry in the list of variables
	while ( (i < num_ib) && (ib_list[i] != this) ) { i++; };
	if (i >= num_ib) {
		fprintf(stderr,"Tclvar_int_with_button::~Tclvar_int_with_button(): Internal error -- not in list\n");
		return;
	}

	// Move the last entry to this one
	ib_list[i] = ib_list[num_ib-1];

	// Reduce the number in the list
	num_ib--;
};


// Add and pack a checkbutton if there is an interpreter and a widget
// for each intwithbutton variable.  Note that the change callback will
// be handled by the fact that it is derived from an int var.
// Set the value of the variable so it shows up on the display.

int	Tclvar_int_with_button::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	char	cvalue[100];
	char	*last_part;

	// Set the variable to its default value
	sprintf(cvalue,"%d", myint);
	Tcl_SetVar(interpreter, my_tcl_varname, cvalue, TCL_GLOBAL_ONLY);

	// Create the checkbutton.  Only use the truncated name for the
	// text in the widget (the part of the variable name after the
	// last '.').
	last_part = strrchr(my_tcl_varname, '.');
	if (last_part == NULL) {
		last_part = my_tcl_varname;
	} else {
		last_part++;	// Skip the .
	}
	sprintf(command,"checkbutton {%s} -text {%s} -variable {%s} -anchor w",
		tcl_widget_name, last_part, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Pack the checkbutton
	sprintf(command,"pack {%s} -fill x\n", tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	return 0;
}


//	Add an entry into the list of active floatscale Tcl variables, and
// point it to this variable.  Set up the min and max floats.
//	Add a trace callback and handler widget if there is an interpreter.

Tclvar_float_with_scale::Tclvar_float_with_scale(char *tcl_varname,
	char *parent_name, float minval, float maxval, float default_value,
	Linkvar_Floatcall c, void *ud) :
	Tclvar_float(tcl_varname, default_value, c, ud)
{
//fprintf(stderr, "Tclvar_float_with_scale constructor\n");

	minvalue = minval;
	maxvalue = maxval;

	if (num_fs >= (MAX_FS-1)) {
		fprintf(stderr,"Tclvar_float_with_scale::Tclvar_float_with_scale(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		fs_list[num_fs] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_float_with_scale::Tclvar_float_with_scale(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myfloat = mylastfloat = default_value;
			num_fs++;
		}
	}

	// Set the widget and label names, if there is a parent specified
	if (parent_name != NULL) {
		tcl_widget_name =
			new char[strlen(parent_name) + strlen(tcl_varname) + 2];
		if (tcl_widget_name == NULL) {
			fprintf(stderr,"Tclvar_float_with_scale::Tclvar_float_with_scale(): Out of memory\n");
		}
		sprintf(tcl_widget_name,"%s.%s",parent_name,tcl_varname);

		tcl_label_name =
			new char[strlen(parent_name) + strlen(tcl_varname) +12];
		if (tcl_label_name == NULL) {
			fprintf(stderr,"Tclvar_float_with_scale::Tclvar_float_with_scale(): Out of memory\n");
		}
		sprintf(tcl_label_name,"%s.%slabel",parent_name,tcl_varname);
	} else {
		tcl_widget_name = NULL;
	}

	// Add and pack a floatscale if there is an interpreter and a widget
	if ( (interpreter != NULL) && (tcl_widget_name != NULL) ) {
		initialize(interpreter);
	}
};

//	Remove the entry from the list of active float Tcl variables.
//	Base class destructor handles the rest.

Tclvar_float_with_scale::~Tclvar_float_with_scale()
{
	register int	i = 0;

	// Unpack and destroy the floatscale and label, if there is an
	// interpreter
	if (interpreter != NULL) {
		char	command[1000];
		sprintf(command,"destroy %s",tcl_widget_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
		sprintf(command,"destroy %s",tcl_label_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
	}

	// Free the space for the widget name
	if (tcl_widget_name != NULL) { delete [] tcl_widget_name; }
	if (tcl_label_name != NULL) { delete [] tcl_label_name; }

	// Find this entry in the list of variables
	while ( (i < num_fs) && (fs_list[i] != this) ) { i++; };
	if (i >= num_fs) {
		fprintf(stderr,"Tclvar_float_with_scale::~Tclvar_float_with_scale(): Internal error -- not in list\n");
		return;
	}

	// Move the last entry to this one
	fs_list[i] = fs_list[num_fs-1];

	// Reduce the number in the list
	num_fs--;
};

// Add and pack a floatscale if there is an interpreter and a widget
// for each floatscale variable.  Note that the change callback will
// be handled by the fact that it is derived from a float var.
// Set the value of the variable so it shows up on the display.
// Put in a label with the variable's name

int	Tclvar_float_with_scale::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	char	cvalue[100];

	// Set the variable to its default value
	sprintf(cvalue,"%g", myfloat);
	Tcl_SetVar(interpreter, my_tcl_varname, cvalue, TCL_GLOBAL_ONLY);

	// Create the floatscale
	sprintf(command,"floatscale %s %g %g 300 0 1 %s",
		tcl_widget_name, minvalue, maxvalue, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Make the label for the floatscale
	sprintf(tcl_label_name,"%slabel",tcl_widget_name);
	sprintf(command,"label %s -text %s", tcl_label_name, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Pack the label and floatscale
	sprintf(command,"pack %s %s\n", tcl_label_name, tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	return 0;
}


//	Add an entry into the list of active intscale Tcl variables, and
// point it to this variable.  Set up the min and max ints.
//	Add a trace callback and handler widget if there is an interpreter.

Tclvar_int_with_scale::Tclvar_int_with_scale(char *tcl_varname,
	char *parent_name, int minval, int maxval, int default_value,
	Linkvar_Intcall c, void *ud) :
	Tclvar_int(tcl_varname, default_value, c, ud)
{
//fprintf(stderr, "Tclvar_int_with_scale constructor\n");

	minvalue = minval;
	maxvalue = maxval;

	if (num_is >= (MAX_IS-1)) {
		fprintf(stderr,"Tclvar_int_with_scale::Tclvar_int_with_scale(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		is_list[num_is] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_int_with_scale::Tclvar_int_with_scale(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myint = mylastint = default_value;
			num_is++;
		}
	}

	// Set the widget and label names, if there is a parent specified
	if (parent_name != NULL) {
		tcl_widget_name =
			new char[strlen(parent_name) + strlen(tcl_varname) + 2];
		if (tcl_widget_name == NULL) {
			fprintf(stderr,"Tclvar_int_with_scale::Tclvar_int_with_scale(): Out of memory\n");
		}
		sprintf(tcl_widget_name,"%s.%s",parent_name,tcl_varname);

		tcl_label_name =
			new char[strlen(parent_name) + strlen(tcl_varname) +12];
		if (tcl_label_name == NULL) {
			fprintf(stderr,"Tclvar_int_with_scale::Tclvar_int_with_scale(): Out of memory\n");
		}
		sprintf(tcl_label_name,"%s.%slabel",parent_name,tcl_varname);
	} else {
		tcl_widget_name = NULL;
	}

	// Add and pack a intscale if there is an interpreter and a widget
	if ( (interpreter != NULL) && (tcl_widget_name != NULL) ) {
		initialize(interpreter);
	}
};

//	Remove the entry from the list of active int Tcl variables.
//	Base class destructor handles the rest.

Tclvar_int_with_scale::~Tclvar_int_with_scale()
{
	register int	i = 0;

	// Unpack and destroy the intscale and label, if there is an
	// interpreter
	if (interpreter != NULL) {
		char	command[1000];
		sprintf(command,"destroy %s",tcl_widget_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
		sprintf(command,"destroy %s",tcl_label_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
	}

	// Free the space for the widget name
	if (tcl_widget_name != NULL) { delete [] tcl_widget_name; }
	if (tcl_label_name != NULL) { delete [] tcl_label_name; }

	// Find this entry in the list of variables
	while ( (i < num_is) && (is_list[i] != this) ) { i++; };
	if (i >= num_is) {
		fprintf(stderr,"Tclvar_int_with_scale::~Tclvar_int_with_scale(): Internal error -- not in list\n");
		return;
	}

	// Move the last entry to this one
	is_list[i] = is_list[num_is-1];

	// Reduce the number in the list
	num_is--;
};

// Add and pack a intscale if there is an interpreter and a widget
// for each int_entry variable.  Note that the change callback will
// be handled by the fact that it is derived from a int var.
// Set the value of the variable so it shows up on the display.
// Put in a label with the variable's name

int	Tclvar_int_with_scale::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	char	cvalue[100];

	// Set the variable to its default value
	sprintf(cvalue,"%d", myint);
	Tcl_SetVar(interpreter, my_tcl_varname, cvalue, TCL_GLOBAL_ONLY);

	// Create the int_entry
	sprintf(command,"intscale %s %d %d 300 0 1 %s",
		tcl_widget_name, minvalue, maxvalue, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Make the label for the intscale
	sprintf(tcl_label_name,"%slabel",tcl_widget_name);
	sprintf(command,"label %s -text %s", tcl_label_name, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Pack the label and intscale
	sprintf(command,"pack %s %s\n", tcl_label_name, tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	return 0;
}





//	Add an entry into the list of active intentry Tcl variables, and
// point it to this variable.  
//	Add a trace callback and handler widget if there is an interpreter.

Tclvar_int_with_entry::Tclvar_int_with_entry(char *tcl_varname,
	char *parent_name, int default_value,
	Linkvar_Intcall c, void *ud) :
	Tclvar_int(tcl_varname, default_value, c, ud)
{
//fprintf(stderr, "Tclvar_int_with_entry constructor\n");


	if (num_intentry >= (MAX_INTENTRY-1)) {
		fprintf(stderr,"Tclvar_int_with_entry::Tclvar_int_with_entry(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		intentry_list[num_intentry] = this;
		my_tcl_varname = new char[strlen(tcl_varname)+1];
		if (my_tcl_varname == NULL) {
			fprintf(stderr,"Tclvar_int_with_entry::Tclvar_int_with_entry(): Out of memory\n");
		} else {
			strcpy(my_tcl_varname, tcl_varname);
			myint = mylastint = default_value;
			num_intentry++;
		}
	}

	// Set the widget name and label names, if there is a parent specified
	// The widget name matches the tcl_varname, unless there are '.'s
	// in the name.  If there are '.'s, the name is just the part after
	// the last '.' (this strips away the prepended widget part).
	if (parent_name != NULL) {
		char	*last_part;

		last_part = strrchr(tcl_varname, '.');
		if (last_part == NULL) {
			last_part = tcl_varname;
		} else {
			last_part++;	// Skip the .
		}
		tcl_widget_name =
			new char[strlen(parent_name) + strlen(last_part) + 2];
		if (tcl_widget_name == NULL) {
			fprintf(stderr,"Tclvar_int_with_entry::Tclvar_int_with_entry(): Out of memory\n");
		}
		sprintf(tcl_widget_name,"%s.%s",parent_name,last_part);
		// Make sure widget name starts with a lower-case character.
		tcl_widget_name[strlen(parent_name)+1] =
		  tolower(tcl_widget_name[strlen(parent_name)+1]);
		// remove spaces - they are bad for widget names.
		int i;
		for (i = 0; i < strlen(tcl_widget_name); i++)
		   if (tcl_widget_name[i] == ' ')
		      tcl_widget_name[i] = '_';

		tcl_label_name =
			new char[strlen(parent_name) + strlen(last_part) +8];
		if (tcl_label_name == NULL) {
			fprintf(stderr,"Tclvar_int_with_entry::Tclvar_int_with_entry(): Out of memory\n");
		}
		sprintf(tcl_label_name,"%s.%slabel",parent_name,last_part);

		// Make sure label name starts with a lower-case character.
		tcl_label_name[strlen(parent_name)+1] =
		  tolower(tcl_label_name[strlen(parent_name)+1]);
		// remove spaces - they are bad for widget names.
		for (i = 0; i < strlen(tcl_label_name); i++)
		   if (tcl_label_name[i] == ' ')
		      tcl_label_name[i] = '_';

	} else {
		tcl_widget_name = NULL;
	}
	
	//printf("int_w_entry contsr: %s %s %s\n", my_tcl_varname, parent_name,tcl_widget_name); 
	
	// Add and pack a intentry if there is an interpreter and a widget
	if ( (interpreter != NULL) && (tcl_widget_name != NULL) ) {
		initialize(interpreter);
	}
};

//	Remove the entry from the list of active int Tcl variables.
//	Base class destructor handles the rest.

Tclvar_int_with_entry::~Tclvar_int_with_entry()
{
	register int	i = 0;

	// Unpack and destroy the intentry and label, if there is an
	// interpreter
	if ( (interpreter != NULL) && (tcl_widget_name != NULL) ){
		char	command[1000];
		sprintf(command,"destroy %s",tcl_widget_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
		sprintf(command,"destroy %s",tcl_label_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
	}

	// Free the space for the widget name
	if (tcl_widget_name != NULL) { delete [] tcl_widget_name; }
	if (tcl_label_name != NULL) { delete [] tcl_label_name; }

	// Find this entry in the list of variables
	while ( (i < num_intentry) && (intentry_list[i] != this) ) { i++; };
	if (i >= num_intentry) {
		fprintf(stderr,"Tclvar_int_with_entry::~Tclvar_int_with_entry(): Internal error -- not in list\n");
		return;
	}

	// Move the last entry to this one
	intentry_list[i] = intentry_list[num_intentry-1];

	// Reduce the number in the list
	num_intentry--;
};

// Add and pack a intentry if there is an interpreter and a widget
// for each intentry variable.  Note that the change callback will
// be handled by the fact that it is derived from a int var.
// Set the value of the variable so it shows up on the display.
// Put in a label with the variable's name

int	Tclvar_int_with_entry::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	char	cvalue[100];


	// Create the intentry
	sprintf(command,"intentry {%s} {%s}",
		tcl_widget_name, my_tcl_varname);
	TCLEVALCHECK(interpreter, command);

	//set the initial value of the entry field
	// Set the variable to its default value
	sprintf(cvalue,"%d", myint);
	Tcl_SetVar(interpreter, my_tcl_varname, cvalue, TCL_GLOBAL_ONLY);

	// Make the label for the intentry
	sprintf(tcl_label_name,"%slabel",tcl_widget_name);

	return 0;
}




Tclvar_list_of_strings::~Tclvar_list_of_strings()
{
//fprintf(stderr, "~Tclvar_list_of_strings()\n");
	// Delete all of the entries in the list.
	// num_entries will be adjusted by each delete, which makes the
	// loop control look strange.
	while (num_entries)
		Delete_entry(entries[0]);
	// TCH 26 June 98
	// better cleanup (for linux?)
	while (num_selectors)
		Delete_selector(selectors[0]);
}

// Returns 0 on success, 1 on list full, 2 on entry already in the list,
// -1 on other errors.
int	Tclvar_list_of_strings::Add_entry(const char entry[])
{
	int	i;

	// Make sure there is enough room for another entry
	if (num_entries >= NUM_ENTRIES) {
		return(1);
	}

	// Make sure the entry is not already in the list
	for (i = 0; i < num_entries; i++) {
	  if (strncmp(entries[i], entry, TCLVAR_STRING_LENGTH) == 0) {
		return 2;
	  }
	}

	// Add the entry on the end of the list
	strncpy(entries[num_entries], entry, TCLVAR_STRING_LENGTH);
	num_entries++;

//fprintf(stderr, "Added \"%s\".\n", entry);

	// If we have an interpreter and a widget, add the entry into the
	// menu for each of the selectors that are interested in this list
	if (interpreter) {
	  for (i = 0; i < num_selectors; i++) {
	    if (selectors[i]->tcl_widget_name) {
		char	command[1000];
		Tclvar_selector	*sel = selectors[i];

//fprintf(stderr, "  Updating %s with the new entry.\n", sel->my_tcl_varname);

		sprintf(command,"%s.menu add command -label {%s} -underline 0 -command \"set %s {%s}\"", 
			sel->tcl_widget_name, entries[num_entries-1], 
			sel->my_tcl_varname, entries[num_entries-1]);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
			return(-1);
		}
	    }
	  }
	}

	return 0;
}

// Returns 0 on success, 1 on string not found in list, -1 on other error
int	Tclvar_list_of_strings::Delete_entry(const char entry[])
{
	int	i, s;
	int	retval = 0;

	// Find the entry in the list, if we can
	for (i = 0; i < num_entries; i++) {
		if (strncmp(entries[i], entry, TCLVAR_STRING_LENGTH) == 0) {
			break;
		}
	}
	if (i == num_entries) {	// Didn't find it!
		return 1;
	}

	// If we have an interpreter, remove the entry from the menu for each
	// of the selectors that are interested in this list.
	if (interpreter) {
	  for (s = 0; s < num_selectors; s++) {
		char	command[1000];
		Tclvar_selector	*sel = selectors[s];

                // TCH 30 Sep 97:  added the "if (sel->tcl_widget_name)"
                // since Add_entry has the same and the lack here was causing
                // Tcl errors
                if (sel->tcl_widget_name) {
		  sprintf(command, "%s.menu delete {%s}",
                          sel->tcl_widget_name, entries[i]);
		  if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
			retval = -1;
		  }
                }
	  }
	}

	// Remove the entry from the list by moving the last entry to its
	// location and reducing the number of entries by one
	strncpy(entries[i], entries[num_entries-1], TCLVAR_STRING_LENGTH);
	num_entries--;

	return retval;
}

// Returns 0 on success, 1 on list full, 2 on entry already in the list,
// -1 on other errors.
Tclvar_list_of_strings::Add_selector(Tclvar_selector *sel)
{
	int	i;

	// Make sure there is enough room for another entry
	if (num_selectors >= NUM_ENTRIES) {
		return(1);
	}

	// Make sure the entry is not already in the list
	for (i = 0; i < num_selectors; i++) {
	  if (selectors[i] == sel) {
		return 2;
	  }
	}

//if (sel->my_tcl_varname)
//fprintf(stderr, "Added selector \"%s\".\n", sel->my_tcl_varname);
//else
//fprintf(stderr, "Added anonymous selector.\n");

	// Add the entry on the end of the list
	selectors[num_selectors] = sel;
	num_selectors++;

	return 0;
}

// Returns 0 on success, 1 on selector not found in list, -1 on other error
int	Tclvar_list_of_strings::Delete_selector(Tclvar_selector *sel)
{
	int	i;

	if (!sel) return 1;

	// Find the entry in the list, if we can
	for (i = 0; i < num_selectors; i++) {
		if (selectors[i] == sel) {
			break;
		}
	}
	if (i == num_selectors) {	// Didn't find it!
		return 1;
	}

	// Remove the entry from the list by moving the last entry to its
	// location and reducing the number of entries by one
	selectors[i] = selectors[num_selectors - 1];
	num_selectors--;

	// TCH 26 June 98
	// better cleanup (for linux?)
	sel->mylist = NULL;

	return 0;
}

//	Creates a selector, linking it to the list of strings that it
// uses to select from.  Adds the selector to the list of selectors,
// so if we don't have an interpreter yet, it will be called when the
// interpreter is set.
//	If we do have an interpreter, go ahead and build the menu for
// the variable and do all of the cross-linking to ensure that updates
// will happen.

Tclvar_selector::Tclvar_selector (const char * initial_value) :
        my_tcl_varname (NULL),
        tcl_widget_name (NULL),
        tcl_label_name (NULL),
        callback (NULL),
        userdata (NULL),
	dirty (0),
        mylist (NULL),
        d_initialized (0) {

//fprintf(stderr, "~Tclvar_selector()\n");
  if (num_sels >= (MAX_SELS-1)) {
    fprintf(stderr, "Tclvar_selector:  "
                    "Can't link to nameless variable\n");
    fprintf(stderr,"                          (Out of storage)\n");
    return;
  }

  sel_list[num_sels] = this;
  num_sels++;

  Set(initial_value);
}


Tclvar_selector::Tclvar_selector (char * tcl_varname, char * parent_name,
	Tclvar_list_of_strings * list, char * initial_value,
        Linkvar_Selectcall c, void *ud) :
    mylist (NULL),
    d_initialized (0)
{
	callback = c;
	userdata = ud;
	dirty = 0;

//fprintf(stderr, "Tclvar_selector constructor\n");

	tcl_widget_name = NULL;

	// Put us on the list and set the Tcl variable name and parent name.
	if (num_sels >= (MAX_SELS-1)) {
		fprintf(stderr,"Tclvar_selector::Tclvar_selector(): Can't link to %s\n",
			tcl_varname);
		fprintf(stderr,"                          (Out of storage)\n");
	} else {
		sel_list[num_sels] = this;
		Set(initial_value);
		num_sels++;
		initializeTcl(tcl_varname, parent_name);

	        // Store which list of strings we are to use
		// NULL list is legal and expected now,
		// but we want to call this only if it's non-NULL.
	        if (list) bindList(list);
	}

}

void	Tclvar_selector::Set (const char *value)
{
	strncpy(mystring, value, TCLVAR_STRING_LENGTH);
	strncpy(mylaststring, value, TCLVAR_STRING_LENGTH);
}

Tclvar_selector::~Tclvar_selector (void)
{
	int	i = 0;

	// Remove the trace callback, if there is an interpreter
	// Why would my_tcl_varname sometime be null? But sometimes
	// it is, so to avoid a segfault, do a check. 
	if (interpreter && my_tcl_varname) {
		Tcl_UntraceVar(interpreter, my_tcl_varname, 
			TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
			handle_string_value_change,
			(ClientData)((void*)(this)));
	}

	// Free the space for the name
	if (my_tcl_varname != NULL) { delete [] my_tcl_varname; }

	// Unpack and destroy the menu and label, if there is an
	// interpreter and a widget
	if (interpreter && tcl_widget_name) {
		char	command[1000];
		sprintf(command,"destroy %s",tcl_widget_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
		sprintf(command,"destroy %s",tcl_label_name);
		if (Tcl_Eval(interpreter, command) != TCL_OK) {
			fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
				interpreter->result);
		}
	}

	// Free the space for the widget name
	if (tcl_widget_name != NULL) { delete [] tcl_widget_name; }
	if (tcl_label_name != NULL) { delete [] tcl_label_name; }

	// Remove this selector from its list of strings
        if (mylist)
	  mylist->Delete_selector(this);

	// Find this entry in the list of variables
	while ( (i < num_sels) && (sel_list[i] != this) ) { i++; };
	if (i >= num_sels) {
		fprintf(stderr,"Tclvar_selector::~Tclvar_selector(): Internal error -- not in list\n");
		return;
	}

	// Move the last entry to this one
	sel_list[i] = sel_list[num_sels-1];

	// Reduce the number in the list
	num_sels--;
}


void Tclvar_selector::initializeTcl (const char * tcl_varname,
                                     const char * parent_name) {

  if (!tcl_varname) {
    fprintf(stderr, "Tclvar_selector::initializeTcl:  "
                    "NULL variable name!\n");
    return;
  }

  my_tcl_varname = new char [strlen(tcl_varname) + 1];
  if (my_tcl_varname == NULL) {
    fprintf(stderr,"Tclvar_selector:  Out of memory\n");
    return;
  } 
  strcpy(my_tcl_varname, tcl_varname);

  // Set the widget and label names, if there is a parent specified
  if (parent_name) {
    tcl_widget_name =
            new char [strlen(parent_name) + strlen(tcl_varname) + 2];
    if (tcl_widget_name == NULL) {
      fprintf(stderr,"Tclvar_selector:  Out of memory\n");
      return;
    }
    sprintf(tcl_widget_name,"%s.%s",parent_name,tcl_varname);

    tcl_label_name =
      new char[strlen(parent_name) + strlen(tcl_varname) +12];
    if (tcl_label_name == NULL) {
      fprintf(stderr,"Tclvar_selector:  Out of memory\n");
      return;
    }
    sprintf(tcl_label_name,"%s.%slabel",parent_name,tcl_varname);
  } else {
    tcl_widget_name = NULL;
  }

  // Add a callback for change if there is an interpreter
  if (interpreter) {
    if (Tcl_TraceVar(interpreter, my_tcl_varname,
                  TCL_TRACE_WRITES | TCL_GLOBAL_ONLY,
                  handle_string_value_change,
                  (ClientData)((void*)(this))) != TCL_OK) {
      fprintf(stderr, "Tclvar_selector:  Tcl_TraceVar(%s) failed: %s\n",
              my_tcl_varname, interpreter->result);
      return;
    }
  }

  // Build the menu for this selector, if there is an interpreter
  // and a widget name
  if (interpreter && tcl_widget_name) initialize(interpreter);
}

int Tclvar_selector::bindList (Tclvar_list_of_strings * list) {
  int ret = 0;

  if (mylist) {
    fprintf(stderr, "Tclvar_selector::bindList:  Calling twice.\n");
    return -1;
  }

  if (!list) {
    fprintf(stderr, "Tclvar_selector::bindList:  "
                    "Calling with empty input.\n");
    return -1;
  }

  // Set the list of strings used, and insert this selector into
  // the ones the list knows is interested in it
  mylist = list;
  list->Add_selector(this);

  if (d_initialized)
    ret = initializeList();

  return ret;
}




//	Create the menu for the selector, placing it in the parent.
// Use the list of strings to fill in the menu choices, each of which
// will set the variable to its value when selected.
int	Tclvar_selector::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	int ret;

	// Set the variable to its default value
	Tcl_SetVar(interpreter, my_tcl_varname, mystring, TCL_GLOBAL_ONLY);

	// Create the menu button that invokes the menu
	sprintf(command,
	    "menubutton %s -textvariable %s -bd 2 -relief raised -menu %s.menu",
	    tcl_widget_name, my_tcl_varname, tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Cause button 3 to bring up a dialog box, in case the menu gets
	// so long that you can't pick all of its entries
	sprintf(command,
	    "bind %s <Button-3> { newvalue_dialogue %s }",
	    tcl_widget_name, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Create the menu and fill it with the list of strings
	sprintf(command,"menu %s.menu", tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

        if (mylist) {
          ret = initializeList();
          if (ret < 0)
            return -1;
        }


	// Make the label for the menu
	sprintf(tcl_label_name,"%slabel",tcl_widget_name);
	sprintf(command,"label %s -text %s", tcl_label_name, my_tcl_varname);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	// Pack the label and menu
	sprintf(command,"pack %s %s\n", tcl_label_name, tcl_widget_name);
	if (Tcl_Eval(interpreter, command) != TCL_OK) {
		fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
			interpreter->result);
		return(-1);
	}

	d_initialized = 1;

	return 0;
}

int Tclvar_selector::initializeList (void) {
  char command [1000];
  int i;

  for (i = 0; i < mylist->num_entries; i++) {
    sprintf(command, "%s.menu add command -label {%s} -underline 0 "
                     "-command \"set %s {%s}\"",
            tcl_widget_name, mylist->entries[i],
            my_tcl_varname, mylist->entries[i]);
    if (Tcl_Eval(interpreter, command) != TCL_OK) {
      fprintf(stderr, "Tcl_Eval(%s) failed: %s\n", command,
              interpreter->result);
      return(-1);
    }
  }

  return 0;
}

char	*Tclvar_selector::operator =(char *v)
{
	if (v == NULL) {
		mystring[0] = '\0';
	} else {
		strncpy(mystring, v, TCLVAR_STRING_LENGTH);
	}
	return mystring;
}


//-----------------------------------------------------------------------
// Checklist class.  First is listed the type of the data sent to the callback
// and the callback handler for the checkboxes in each list.

typedef	struct {
	Tclvar_checklist	*whos;
	Tclvar_Checkbox	        *which;
} Check_Parm;

//each button added to a checklist calls this callback. 
// This function activates the callback for the whole checklist,
// passing the name of the checkbox which caused the callback.
static	void	checklist_callback(int /*value*/, void *userdata)
{
	Check_Parm	*parm = (Check_Parm*)(userdata);

	if (parm->whos->callback != NULL) {
		parm->whos->callback(parm->which->name,
				     (int)(*(parm->which->button)),
				     parm->whos->userdata);
	}
}

Tclvar_checklist::Tclvar_checklist(char *parent_name)
{
	// Set the defaults
	num_checkboxes = 0;
	callback = NULL;
	userdata = NULL;

//fprintf(stderr, "Tclvar_checklist constructor\n");

	// Set the parent name.
	if (parent_name) {
		tcl_parent_name = new char[strlen(parent_name) + 1];
		if (tcl_parent_name == NULL) {
		  fprintf(stderr,
		    "Tclvar_checklist::Tclvar_checklist(): Out of memory\n");
		  return;
		}
		sprintf(tcl_parent_name,"%s",parent_name);
	} else {
		tcl_parent_name = NULL;
	}
};

Tclvar_checklist::~Tclvar_checklist()
{
	int	i = 0;
//fprintf(stderr, "~Tclvar_checklist()\n");

	// Free the space for the name
	if (tcl_parent_name != NULL) { delete [] tcl_parent_name; }

	// Destroy all of the checkboxes 
	for (i = 0; i < num_checkboxes; i++) {
		delete checkboxes[i].button;
	}
}

int	Tclvar_checklist::Lookup_checkbox (const char * checkbox_name) const
{
	int	i = 0;

	// Are there any checkboxes?
	if (num_checkboxes == 0) return -1;

	// Find this checkbox in the list
	while ( (i < num_checkboxes) &&
		strcmp(checkbox_name,checkboxes[i].name) ) {
		i++;
	};
	if (i >= num_checkboxes) {
		return -1;	// No such checkbox
	}

	return i;
}

int	Tclvar_checklist::Add_checkbox (const char * checkbox_name, int value)
{
	Check_Parm	*parm = new Check_Parm;
	char		button_name[1000];

	if (parm == NULL) {
	    fprintf(stderr,"Tclvar_checklist::Add_checkbox(): Can't do parm\n");
	    return -1;
	}

	if ( (checkbox_name == NULL) || (strlen(checkbox_name) == 0) ) {
	    fprintf(stderr,"Tclvar_checklist::Add_checkbox(): Empty name\n");
	    return -1;
	}

	// Make sure it's not already in the list
	if (Lookup_checkbox(checkbox_name) != -1) {
	    fprintf(stderr,"Tclvar_checklist::Add_checkbox(): Already there\n");
	    return -1;
	}

	// Make sure there is enough room for the new checkbox
	if (num_checkboxes >= NUM_CHECKBOXES) {
		fprintf(stderr,"Tclvar_checklist::Add_checkbox(): Too many\n");
		return -1;
	}

	// Create the new checkbox.
	// The name is that given as a parameter (truncated to fit within the
	// name length).  The name of the button has the parent name prepended,
	// to distinguish the checkboxes of different checklists.
	strncpy(checkboxes[num_checkboxes].name, checkbox_name,
		sizeof(checkboxes[num_checkboxes].name) - 1);
	checkboxes[num_checkboxes].name[sizeof(checkboxes[num_checkboxes].name) - 1] = '\0';

	if (tcl_parent_name) {
		strncpy(button_name, tcl_parent_name, sizeof(button_name));
	} else {
		button_name[0] = '\0';
	}
	if ( (strlen(button_name)+1) < sizeof(button_name)) {
		strcat(button_name,".");
	}
	strncat(button_name, checkbox_name,
		sizeof(button_name)-strlen(button_name) - 2);
	checkboxes[num_checkboxes].button =
		new Tclvar_int_with_button(button_name,tcl_parent_name, value);
	if (checkboxes[num_checkboxes].button == NULL) {
		fprintf(stderr,"Tclvar_checklist::Add_checkbox(): Out of mem\n");
		return -1;
	}
	num_checkboxes++;

	// Set up the callback for this variable.  This tells which checklist
	// set the callback and for which checkbox it was set.  This lets the
	// callback route the result correctly.
	parm->whos = this;
	parm->which = &checkboxes[num_checkboxes-1];
	checkboxes[num_checkboxes-1].button->set_tcl_change_callback(
					checklist_callback, parm);

	return 0;
};

int	Tclvar_checklist::Remove_checkbox (const char * checkbox_name)
{
	int	i = Lookup_checkbox(checkbox_name);

	// Ensure that it is really in the list
	if (i == -1) { return -1; }

	// Delete the checkbox, move the last checkbox to this one
	// and decrement counter
	delete checkboxes[i].button;
	checkboxes[i] = checkboxes[num_checkboxes-1];
	num_checkboxes--;

	return 0;
};

int	Tclvar_checklist::Set_checkbox (const char * checkbox_name)
{
	int i = Lookup_checkbox(checkbox_name);

	if (i == -1) { return -1; }

	*(checkboxes[i].button) = 1;

	return 0;
}

int	Tclvar_checklist::Unset_checkbox (const char * checkbox_name)
{
	int i = Lookup_checkbox(checkbox_name);

	if (i == -1) { return -1; }

	*(checkboxes[i].button) = 0;

	return 0;
}

int	Tclvar_checklist::Is_set (const char *checkbox_name) const
{
	int i = Lookup_checkbox(checkbox_name);

	if (i == -1) { return -1; }

	return *(checkboxes[i].button);
}

const char * Tclvar_checklist::Checkbox_name (const int which) const
{
	if ( (which < 0) || (which >= num_checkboxes) ) { return NULL; }

	return checkboxes[which].name;
}

int	Tclvar_checklist::Is_set (const int which) const
{
	if ( (which < 0) || (which >= num_checkboxes) ) { return -1; }

	return *(checkboxes[which].button);
}

 








//-----------------------------------------------------------------------
// Checklist class.  First is listed the type of the data sent to the callback
// and the callback handler for the checkboxes in each list.

typedef	struct {
	Tclvar_checklist_with_entry	*whos;
	Tclvar_Checkbox	        *which;
} Check_Entry_Parm;

//each button added to a checklist calls this callback. 
// This function activates the callback for the whole checklist,
// passing the name of the checkbox which caused the callback.
static	void	checklist_entry_callback(int /*value*/, void *userdata)
{
	Check_Entry_Parm	*parm = (Check_Entry_Parm*)(userdata);

	if (parm->whos->callback != NULL) {
		parm->whos->callback(parm->which->name,
				     (int)(*(parm->which->button)),
				     parm->whos->userdata);
	}
}

Tclvar_checklist_with_entry::Tclvar_checklist_with_entry(char *parent_name) :
   Tclvar_checklist(parent_name)
{
//fprintf(stderr, "Tclvar_checklist_with_entry constructor\n");

	// Set the defaults
	num_checkboxes = 0;
	callback = NULL;
	userdata = NULL;
	if (num_checkentry >= (MAX_CHECKENTRY-1)) {
		fprintf(stderr,"Tclvar_checklist_with_entry::Tclvar_checklist_with_entry: (Out of storage)\n");
	} else {
		checkentry_list[num_checkentry] = this;
		num_checkentry++;
	}


	// Set the parent name.
	if (parent_name) {
		tcl_parent_name = new char[strlen(parent_name) + 1];
		if (tcl_parent_name == NULL) {
		  fprintf(stderr,
		    "Tclvar_checklist::Tclvar_checklist(): Out of memory\n");
		  return;
		}
		sprintf(tcl_parent_name,"%s",parent_name);
	} else {
		tcl_parent_name = NULL;
	}
};

Tclvar_checklist_with_entry::~Tclvar_checklist_with_entry()
{
	int	i = 0;
//fprintf(stderr, "~Tclvar_checklist_with_entry()\n");

	// Free the space for the name
	if (tcl_parent_name != NULL) { delete [] tcl_parent_name; }

	// Destroy all of the checkboxes and entries
	for (i = 0; i < num_checkboxes; i++) {
		delete checkboxes[i].button;
		if ( checkboxes[i].entry != NULL) delete checkboxes[i].entry;
	}
}

// Make the checkbox name into a widget name.
// Make sure the first letter is lower case, 
// and replace all ' ' with '_'
static void fix_checkbox_name (char * my_checkbox_name) {
	my_checkbox_name[0] = tolower(my_checkbox_name[0]);
	for (int i = 0; i < strlen(my_checkbox_name); i++)
	   if (my_checkbox_name[i] == ' ')
	      my_checkbox_name[i] = '_';
}

// pack the frames necessary for the checkbutton and entry
int	Tclvar_checklist_with_entry::initialize(Tcl_Interp *interpreter)
{
	char	command[1000];
	char * my_checkbox_name;

	int i;
	for (i = 0; i < num_checkboxes; i++) {
	   // create the frames needed. 
	   // This must be done before the checkbox and entry are initialized. 
	   my_checkbox_name = new char[strlen(checkboxes[i].name) + 1];
	   strcpy(my_checkbox_name, checkboxes[i].name);	
	   // make a suitable widget name
	   fix_checkbox_name(my_checkbox_name);

	   sprintf(command, "pack [frame %s.%sf] -expand yes -fill x", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	   sprintf(command, "pack [frame %s.%sf.b] -side left", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	   sprintf(command, "pack [frame %s.%sf.e] -side right", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	   delete my_checkbox_name;
	}
	return 0;
}

// Adds one checkbox/entry combo to the list. Sets default values for both
// depends on the static variable "interpreter" to pack frames
int	Tclvar_checklist_with_entry::Add_checkbox_entry (const char * checkbox_name, int checkval, int entryval)
{
	Check_Parm	*parm = new Check_Parm;
	char		button_name[1000];
	char            entry_name[1000];
	char            command[500];
	char * my_checkbox_name;

	if (parm == NULL) {
	    fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Can't do parm\n");
	    return -1;
	}

	if ( (checkbox_name == NULL) || (strlen(checkbox_name) == 0) ) {
	    fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Empty name\n");
	    return -1;
	}

	// Make sure it's not already in the list
	if (Lookup_checkbox(checkbox_name) != -1) {
	    fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Already there\n");
	    return -1;
	}

	// Make sure there is enough room for the new checkbox
	if (num_checkboxes >= NUM_CHECKBOXES) {
		fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Too many\n");
		return -1;
	}

	// Create the new checkbox.  The name is that given as a
	// parameter (truncated to fit within the name length).  The
	// name of the button has the parent name prepended, to
	// distinguish the checkboxes of different checklists. It has
	// "button" postpended to distinguish it from the entry
	strncpy(checkboxes[num_checkboxes].name, checkbox_name,
		sizeof(checkboxes[num_checkboxes].name) - 1);
	checkboxes[num_checkboxes].name[sizeof(checkboxes[num_checkboxes].name) - 1] = '\0';

	my_checkbox_name = new char[strlen(checkboxes[num_checkboxes].name) + 1];
	strcpy(my_checkbox_name, checkboxes[num_checkboxes].name);	
	// make a suitable widget name
	fix_checkbox_name(my_checkbox_name);
	
	// create spots for the new checkbutton and entry
	// only if the interpreter exists. Otherwise, this will
	// be done when the interpreter is created. 
	if (tcl_parent_name && interpreter ) {
	   
	   sprintf(command, "pack [frame %s.%sf] -expand yes -fill x", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	   sprintf(command, "pack [frame %s.%sf.b] -side left", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	   sprintf(command, "pack [frame %s.%sf.e] -side right", 
		   tcl_parent_name, my_checkbox_name);
	   TCLEVALCHECK(interpreter, command);
	}

	if (tcl_parent_name) {
		strncpy(button_name, tcl_parent_name, sizeof(button_name));
		strncpy(entry_name, tcl_parent_name, sizeof(entry_name));
	} else {
		button_name[0] = '\0';
		entry_name[0] = '\0';
	}
	strncat(button_name, ".",
		sizeof(button_name)-strlen(button_name) - 2);
	strncat(button_name, my_checkbox_name,
		sizeof(button_name)-strlen(button_name) - 2);
	strncat(button_name, "f.b.",
		sizeof(button_name)-strlen(button_name) - 2);
	strncat(button_name, my_checkbox_name,
		sizeof(button_name)-strlen(button_name) - 2);
	// no, I'm not using it as a command, just a convenient string
	sprintf(command, "%s.%sf.b", tcl_parent_name, my_checkbox_name);
	checkboxes[num_checkboxes].button =
		new Tclvar_int_with_button(button_name,command, checkval);
	if (checkboxes[num_checkboxes].button == NULL) {
		fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Out of mem\n");
		return -1;
	}

	// make the entry field, similarly. It has "entry" postpended
	// to distinguish it from the button.
	strncat(entry_name, ".",
		sizeof(entry_name)-strlen(entry_name) - 2);
	strncat(entry_name, my_checkbox_name,
		sizeof(entry_name)-strlen(entry_name) - 2);
	strncat(entry_name, "f.e.",
		sizeof(entry_name)-strlen(entry_name) - 2);
	strncat(entry_name, my_checkbox_name,
		sizeof(entry_name)-strlen(entry_name) - 2);
	// no, I'm not using it as a command, just a convenient string
	sprintf(command, "%s.%sf.e", tcl_parent_name, my_checkbox_name);
	checkboxes[num_checkboxes].entry =
		new Tclvar_int_with_entry(entry_name,command, entryval);
	if (checkboxes[num_checkboxes].entry == NULL) {
		fprintf(stderr,"Tclvar_checklist::add_checkbox_entry(): Out of mem\n");
		return -1;
	}



	num_checkboxes++;

	// Set up the callback for this variable.  This tells which checklist
	// set the callback and for which checkbox it was set.  This lets the
	// callback route the result correctly.
	parm->whos = this;
	parm->which = &checkboxes[num_checkboxes-1];
	checkboxes[num_checkboxes-1].button->set_tcl_change_callback(
					checklist_entry_callback, parm);
	checkboxes[num_checkboxes-1].entry->set_tcl_change_callback(
					checklist_entry_callback, parm);
	delete my_checkbox_name;
	return 0;
};

int	Tclvar_checklist_with_entry::Remove_checkbox (const char * checkbox_name)
{
	int	i = Lookup_checkbox(checkbox_name);

	// Ensure that it is really in the list
	if (i == -1) { return -1; }

	// Delete the checkbox, move the last checkbox to this one
	// and decrement counter
	delete checkboxes[i].button;
	if ( checkboxes[i].entry != NULL) delete checkboxes[i].entry;
	checkboxes[i] = checkboxes[num_checkboxes-1];
	num_checkboxes--;

	return 0;
};

int	Tclvar_checklist_with_entry::Set_checkbox_entry (const char * checkbox_name, int entryval)
{
	int i = Lookup_checkbox(checkbox_name);

	if (i == -1) { return -1; }

	*(checkboxes[i].entry) = entryval;

	return 0;
}


int	Tclvar_checklist_with_entry::Get_entry_val (const char *checkbox_name) const
{
	int i = Lookup_checkbox(checkbox_name);

	if (i == -1) { return -1; }

	return *(checkboxes[i].entry);
}


