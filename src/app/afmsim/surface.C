/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "surface.h"

#include <time.h>
//#include <sys/time.h>
#include <vrpn_Types.h>  // for portable sys/time.h

#include <stdio.h>
#include <iostream>
using namespace std;
#include <stdlib.h>
#include <math.h>

#include <vrpn_Connection.h>

#include <BCGrid.h>
#include <BCPlane.h>
#include <MicroscopeFlavors.h>

#include "simulator_server.h"

#include "nmm_Microscope_Simulator.h"  // for connection

// Added Tom Hudson 10 June 99 to simplify
static BCPlane * g_myZPlane;

/****************************************************************************
 *  Steve's PARSER
 ****************************************************************************/

static short g_numX = 300, g_numY = 300;
static int g_port = vrpn_DEFAULT_LISTEN_PORT_NO;
static char * g_imageName;

static int g_planeShape;

#define PSHAPE_SINUSOIDAL 0
#define PSHAPE_STEP 1
#define PSHAPE_RAMP 2
#define PSHAPE_HEMISPHERES 3
#define PSHAPE_WAVES 4

static vrpn_bool g_isWaiting = vrpn_FALSE;
static float g_waitTime = 0.0f;


void usage (const char * argv0) {
  fprintf(stderr,
    "Usage:  %s [-image <picture>] [-grid <x> <y>] [-port <port>]\n"
    "        [-surface <n>]\n", argv0);
  fprintf(stderr,
    "    -image:  Use picture specified (otherwise use function).\n"
    "    -grid:  Take x by y samples for the grid (default 300 x 300).\n"
    "    -port:  Port number for VRPN server to use (default 4500).\n"
    "    -surface:  Use given surface function:  0 = sinusoidal (default),\n"
	  "      1 = step functions, 2 = ramp, 3 = hemispheres, 4 = waves.\n");

  exit(0);
}



// Parse argv and write the values into s.
// Return nonzero on failure.
// TODO:  add more command-line options from microscape.
      
int parse (int argc, char ** argv) {
  int ret = 0;
  int i;
  i = 1;
  
  while (i < argc) {
    fprintf(stderr, "parse:  arg %d %s\n", i, argv[i]);
    if (!strcmp(argv[i], "-image")) {
      if (++i >= argc) usage(argv[0]);
      g_imageName = argv[i];
    } else if (strcmp(argv[i], "-port") == 0) {
      if (++i >= argc) usage(argv[0]);
      g_port = atoi(argv[i]);
    } else if (strcmp(argv[i], "-grid") == 0) {
      if (++i >= argc) usage(argv[0]);
      g_numX = atoi(argv[i]);
      if (++i >= argc) usage(argv[0]);
      g_numY = atoi(argv[i]);
    } else if (!strcmp(argv[i], "-surface")) {
      if (++i >= argc) usage(argv[0]);
      g_planeShape = atoi(argv[i]);
#if 0
    } else if (!strcmp(argv[i], "-latency")) {
      if (++i >= argc) usage(argv[0]);
      g_isWaiting = vrpn_TRUE;
      g_waitTime = atof(argv[i]);
    } else if (!strcmp(argv[i], "-rude")) {
      g_isRude = 1;
#endif
    } else {
      ret = 1;
    }
    i++;
  }

  // check for mandatory arguments
  //if (!s->microscopeName) 
  //  ret = 1;

  return ret;
}


/******************************************************************
 End Steve's Parser code
 *****************************************************************/




int getImageHeightAtXYLoc (float x, float y, float * z) {
  double zz;
  g_myZPlane->valueAt(&zz, x, y);
  *z = zz;
  return 1;
}

int moveTipToXYLoc( float x , float y, float set_point ) {

  static int last_point_x = 0;
  static int last_point_y = 0;

  const int numsets = 1;
  int j, k;
  //j = (int)x;
  //k = (int)y;
  j = g_myZPlane->xInGrid(x);
  k = g_myZPlane->yInGrid(y);
  if(j>(g_numX-1))
	j = g_numX-1;
  if(j<0)
        j = 0;
  if(k>(g_numY-1))
        k = g_numY-1;
  if(k<0)
        k = 0;
  if(last_point_x)  		// Use Bresenhams Line algorithm to drag tip
  {				// Code by Kenny Hoff
    //------------------------------------------------------------------------
    // INITIALIZE THE COMPONENTS OF THE ALGORITHM THAT ARE NOT AFFECTED BY THE
    // SLOPE OR DIRECTION OF THE LINE
    //------------------------------------------------------------------------
    int Ax = last_point_x;
    int Ay = last_point_y;    
    int Bx = j;
    int By = k;
    int dX = abs(Ax-Bx);    // store the change in X and Y of the line endpoints
    int dY = abs(Ay-By);
        
    //------------------------------------------------------------------------
    // DETERMINE "DIRECTIONS" TO INCREMENT X AND Y (REGARDLESS OF DECISION)
    //------------------------------------------------------------------------
    int Xincr, Yincr;
    if (Ax > Bx) { Xincr=-1; } else { Xincr=1; }    // which direction in X?
    if (Ay > By) { Yincr=-1; } else { Yincr=1; }    // which direction in Y?
        
    //------------------------------------------------------------------------
    // DETERMINE INDEPENDENT VARIABLE (ONE THAT ALWAYS INCREMENTS BY 1 (OR -1) )
    // AND INITIATE APPROPRIATE LINE DRAWING ROUTINE (BASED ON FIRST OCTANT
    // ALWAYS). THE X AND Y'S MAY BE FLIPPED IF Y IS THE INDEPENDENT VARIABLE.
    //------------------------------------------------------------------------
    if (dX >= dY)   // if X is the independent variable
    {           
      int dPr         = dY<<1;           // amount to increment decision if right is chosen (always)
      int dPru        = dPr - (dX<<1);   // amount to increment decision if up is chosen
      int P           = dPr - dX;  	 // decision variable start value

      for (; dX>=0; dX--)            	 // process each point in the line one at a time (just use dX)
      {
        if((g_myZPlane->value( Ax, Ay) - set_point) < 0)
          g_myZPlane->setValue( Ax, Ay, 0);
        else
           g_myZPlane->setValue( Ax, Ay, (g_myZPlane->value( Ax, Ay) - set_point));
        //SetPixel(Ax, Ay, Color); 	 // plot the pixel
        if (P > 0)               	 // is the pixel going right AND up?
        { 
          Ax+=Xincr;	                 // increment independent variable
          Ay+=Yincr;        		 // increment dependent variable
          P+=dPru;          		 // increment decision (for up)
        }
        else	                         // is the pixel just going right?
        {
          Ax+=Xincr;		         // increment independent variable
          P+=dPr;           		 // increment decision (for right)
        }
      }               
    }
    else            		         // if Y is the independent variable
    {
      int dPr         = dX<<1;           // amount to increment decision if right is chosen (always)
      int dPru        = dPr - (dY<<1);   // amount to increment decision if up is chosen
      int P           = dPr - dY; 	 // decision variable start value

      for (; dY>=0; dY--)                // process each point in the line one at a time (just use dY)
      {
        if((g_myZPlane->value( Ax, Ay) - set_point) < 0)
          g_myZPlane->setValue( Ax, Ay, 0);
        else
          g_myZPlane->setValue( Ax, Ay, (g_myZPlane->value( Ax, Ay) - set_point));
	// SetPixel(Ax, Ay, Color);         // plot the pixel
        if (P > 0)                       // is the pixel going up AND right?
        { 
          Ax+=Xincr;                     // increment dependent variable
          Ay+=Yincr;        		 // increment independent variable
          P+=dPru;          		 // increment decision (for up)
        }
        else 	                         // is the pixel just going up?
        {
          Ay+=Yincr;		         // increment independent variable
          P+=dPr;           		 // increment decision (for right)
        }
      }               
    }               
  }
  else
  {
    //float point_value[numsets];
    for(int i = 0; i < numsets; i++)
    if((g_myZPlane->value( j, k) - set_point) < 0)
      g_myZPlane->setValue( j, k, 0);
    else
      g_myZPlane->setValue( j, k, (g_myZPlane->value( j, k) - set_point));
  }

  last_point_x = j;
  last_point_y = k;
  return 0;
}


void initializePlane (BCPlane * zPlane, int planeShape) {
  int x, y;
  float point;
  float rx, ry;
  float radius;
  float targetradius;

  switch (planeShape) {

    case PSHAPE_SINUSOIDAL :
      // sinusoidal surface with 50 nm amplitude and 40*pi nm wavelength
      fprintf(stderr, "Setting up sinusoidal surface.\n");
      for (x = 0; x < g_numX; x++) {
        for (y = 0; y < g_numY; y++) {
          point = fabs(50.0f * (sin((x + y) / 40.0f)));
          zPlane->setValue(x, y, point);
        }
      } 
      break;
    case PSHAPE_STEP :
      // surface with 50 nm steps every 40 nm
      fprintf(stderr, "Setting up stepped surface.\n");
      for (x = 0; x < g_numX; x++) {
        for (y = 0; y < g_numY; y++) {
          point = 50.0f * ceil((x + y) / 40.0f);
          zPlane->setValue(x, y, point);
        }
      }
      break;
    case PSHAPE_RAMP :
      // surface with smooth slope 1.25
      fprintf(stderr, "Setting up ramped surface.\n");
      for (x = 0; x < g_numX; x++) {
        for (y = 0; y < g_numY; y++) {
          point = 1.2f * (x + y);
          zPlane->setValue(x, y, point);
        }
      }
      break;
    case PSHAPE_HEMISPHERES :
      // flat surface with hemispheres of radius 40 nm every 100 nm
      fprintf(stderr, "sortof Setting up regular-hemisphere surface.\n");
      targetradius = 20.0f;
      for (x = 0; x < g_numX; x++) {
        rx = ((x + 50) % 50);
        for (y = 0; y < g_numY; y++) {
          ry = ((y + 50) % 50);
          radius = sqrt(rx * rx + ry * ry);
          if (radius < targetradius) {
            point = targetradius - radius;
          } else {
            point = 0.0f;
          }
          zPlane->setValue(x, y, point);
        }
      }
      break;
  case PSHAPE_WAVES:
    //waves maybe??
    fprintf(stderr, "setting up waves rv 1.\n");
    for(x = 0;x< g_numX; x++){
      for(y = 0; y < g_numY; y++){
	point = 50.0f * ((sin((x/ 20.0f))*sin((x/20.0f)))+(cos((y/20.0f))*cos((y/20.0f))));
	zPlane-> setValue(x,y,point);
      }
    }
    break;		 
    default:
      fprintf(stderr, "Unimplemented plane shape %d\n", planeShape);
      exit(0);

  }
}


int main (int argc, char ** argv) {

  BCGrid * mygrid;

  int readmode;
  int retval;

  retval = parse(argc, argv);
  if (retval) {
    usage(argv[0]);
    exit(0);
  }

  if (g_imageName) {	// CODE USED IF IMAGE IS TO BE USED

    // create new grid
    readmode = READ_FILE;
    TopoFile TF;    // Needs to be passed into the load routine.
    mygrid = new BCGrid (g_numX, g_numY, 0.0, 300.0, 0.0, 300.0,
                         readmode);
    if (mygrid->loadFile(g_imageName, TF) == NULL) {
      fprintf(stderr,"Cannot load file %s\n", g_imageName);
      exit(-1);
    }

    // add plane for Z data
    // Double huh?
    g_myZPlane = mygrid->getPlaneByName("Topography-Forward");

    // Huh?
    g_myZPlane = mygrid->getPlaneByName(g_imageName);

  } else {			// CODE USED IF MATH SURFACE TO BE USED

    mygrid = new BCGrid (g_numX,g_numY,0,300,0,300, READ_FILE);  
    mygrid->addNewPlane("Topography-Forward","nm", 0);
    g_myZPlane = mygrid->getPlaneByName("Topography-Forward");

    initializePlane(g_myZPlane, g_planeShape);
  }

  retval = initJake(g_numX, g_numY, g_port);
  while (!retval) {
    jakeMain(.1, g_isWaiting, g_waitTime);
  }

  return 0;
}










