/* The nanoManipulator and its source code have been released under the
 * Boost software license when nanoManipulator, Inc. ceased operations on
 * January 1, 2014.  At this point, the message below from 3rdTech (who
 * sublicensed from nanoManipulator, Inc.) was superceded.
 * Since that time, the code can be used according to the following
 * license.  Support for this system is now through the NIH/NIBIB
 * National Research Resource at cismm.org.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


#ifndef __MF__
#define __MF__

#include <stdio.h>

/* personal little nothing's - mf
**
** These provide inline documentation with optional printed traces
** in the code.  They progress in detail of debugging downward.
** That is, DOCUMENT_?s should be entry and exit level traces, which
** wouldn't severely inconvenience the user if left on, though they
** might be more confusing than helpful to anyone but the interested
** programmer.  DEBUG0_? are somewhat more detailed, and might annoy
** the user but not especially affect performance otherwise.  This
** progresses to DEBUG3_?'s which might be inside loops or functions
** which are called 1000 times per second, ie. which must be turned
** off for the program to run at a reasonable rate, which in interactive
** systems means for the program to function at all.  In other words,
** we progress downward from program documentation through the levels
** of debugging which demand more and more detail of internals to the
** code.  These don't affect performance unless turned on (good), but
** the code must be recompiled to change whether on or off (bad).
** They are best left in the code for future modification and testing,
** as well as to point out what's going on.
*/

#ifdef DOCUMENT
#define DOCUMENT0(s)		fprintf(stderr,s)
#define DOCUMENT1(s,a)		fprintf(stderr,s,a)
#define DOCUMENT2(s,a,b)	fprintf(stderr,s,a,b)
#define DOCUMENT3(s,a,b,c)	fprintf(stderr,s,a,b,c)
#else
#define DOCUMENT0(s)	
#define DOCUMENT1(s,a)
#define DOCUMENT2(s,a,b)
#define DOCUMENT3(s,a,b,c)
#endif /* DOCUMENT */

#ifdef DEBUG0_
#define DEBUG0_0(s)		fprintf(stderr,s)
#define DEBUG0_1(s,a)		fprintf(stderr,s,a)
#define DEBUG0_2(s,a,b)		fprintf(stderr,s,a,b)
#define DEBUG0_3(s,a,b,c)	fprintf(stderr,s,a,b,c)
#else
#define DEBUG0_0(s)	
#define DEBUG0_1(s,a)
#define DEBUG0_2(s,a,b)
#define DEBUG0_3(s,a,b,c)
#endif /* DEBUG0_ */

#ifdef DEBUG1_
#define DEBUG1_0(s)		fprintf(stderr,s)
#define DEBUG1_1(s,a)		fprintf(stderr,s,a)
#define DEBUG1_2(s,a,b)		fprintf(stderr,s,a,b)
#define DEBUG1_3(s,a,b,c)	fprintf(stderr,s,a,b,c)
#else
#define DEBUG1_0(s)	
#define DEBUG1_1(s,a)
#define DEBUG1_2(s,a,b)
#define DEBUG1_3(s,a,b,c)
#endif /* DEBUG1_ */

#ifdef DEBUG2_
#define DEBUG2_0(s)		fprintf(stderr,s)
#define DEBUG2_1(s,a)		fprintf(stderr,s,a)
#define DEBUG2_2(s,a,b)		fprintf(stderr,s,a,b)
#define DEBUG2_3(s,a,b,c)	fprintf(stderr,s,a,b,c)
#else
#define DEBUG2_0(s)	
#define DEBUG2_1(s,a)
#define DEBUG2_2(s,a,b)
#define DEBUG2_3(s,a,b,c)
#endif /* DEBUG2_ */

#ifdef DEBUG3_
#define DEBUG3_0(s)		fprintf(stderr,s)
#define DEBUG3_1(s,a)		fprintf(stderr,s,a)
#define DEBUG3_2(s,a,b)		fprintf(stderr,s,a,b)
#define DEBUG3_3(s,a,b,c)	fprintf(stderr,s,a,b,c)
#else
#define DEBUG3_0(s)	
#define DEBUG3_1(s,a)
#define DEBUG3_2(s,a,b)
#define DEBUG3_3(s,a,b,c)
#endif /* DEBUG3_ */

#endif
